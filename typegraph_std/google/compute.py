from typegraph.importers.base.importer import Import
from typegraph.runtimes.http import HTTPRuntime
from typegraph import t
from box import Box


def import_compute():
    compute = HTTPRuntime("https://compute.googleapis.com/")

    renames = {
        "ErrorResponse": "_compute_1_ErrorResponse",
        "DiskAsyncReplicationIn": "_compute_2_DiskAsyncReplicationIn",
        "DiskAsyncReplicationOut": "_compute_3_DiskAsyncReplicationOut",
        "DisksAddResourcePoliciesRequestIn": "_compute_4_DisksAddResourcePoliciesRequestIn",
        "DisksAddResourcePoliciesRequestOut": "_compute_5_DisksAddResourcePoliciesRequestOut",
        "LogConfigCloudAuditOptionsIn": "_compute_6_LogConfigCloudAuditOptionsIn",
        "LogConfigCloudAuditOptionsOut": "_compute_7_LogConfigCloudAuditOptionsOut",
        "GlobalOrganizationSetPolicyRequestIn": "_compute_8_GlobalOrganizationSetPolicyRequestIn",
        "GlobalOrganizationSetPolicyRequestOut": "_compute_9_GlobalOrganizationSetPolicyRequestOut",
        "PublicAdvertisedPrefixPublicDelegatedPrefixIn": "_compute_10_PublicAdvertisedPrefixPublicDelegatedPrefixIn",
        "PublicAdvertisedPrefixPublicDelegatedPrefixOut": "_compute_11_PublicAdvertisedPrefixPublicDelegatedPrefixOut",
        "ServiceAttachmentIn": "_compute_12_ServiceAttachmentIn",
        "ServiceAttachmentOut": "_compute_13_ServiceAttachmentOut",
        "BackendServiceCdnPolicyBypassCacheOnRequestHeaderIn": "_compute_14_BackendServiceCdnPolicyBypassCacheOnRequestHeaderIn",
        "BackendServiceCdnPolicyBypassCacheOnRequestHeaderOut": "_compute_15_BackendServiceCdnPolicyBypassCacheOnRequestHeaderOut",
        "VpnGatewaysGetStatusResponseIn": "_compute_16_VpnGatewaysGetStatusResponseIn",
        "VpnGatewaysGetStatusResponseOut": "_compute_17_VpnGatewaysGetStatusResponseOut",
        "PacketMirroringMirroredResourceInfoIn": "_compute_18_PacketMirroringMirroredResourceInfoIn",
        "PacketMirroringMirroredResourceInfoOut": "_compute_19_PacketMirroringMirroredResourceInfoOut",
        "DiskAggregatedListIn": "_compute_20_DiskAggregatedListIn",
        "DiskAggregatedListOut": "_compute_21_DiskAggregatedListOut",
        "FirewallLogConfigIn": "_compute_22_FirewallLogConfigIn",
        "FirewallLogConfigOut": "_compute_23_FirewallLogConfigOut",
        "DiskTypeListIn": "_compute_24_DiskTypeListIn",
        "DiskTypeListOut": "_compute_25_DiskTypeListOut",
        "BfdPacketIn": "_compute_26_BfdPacketIn",
        "BfdPacketOut": "_compute_27_BfdPacketOut",
        "ResourcePolicySnapshotSchedulePolicySnapshotPropertiesIn": "_compute_28_ResourcePolicySnapshotSchedulePolicySnapshotPropertiesIn",
        "ResourcePolicySnapshotSchedulePolicySnapshotPropertiesOut": "_compute_29_ResourcePolicySnapshotSchedulePolicySnapshotPropertiesOut",
        "DiskParamsIn": "_compute_30_DiskParamsIn",
        "DiskParamsOut": "_compute_31_DiskParamsOut",
        "RegionDiskTypeListIn": "_compute_32_RegionDiskTypeListIn",
        "RegionDiskTypeListOut": "_compute_33_RegionDiskTypeListOut",
        "NodeGroupMaintenanceWindowIn": "_compute_34_NodeGroupMaintenanceWindowIn",
        "NodeGroupMaintenanceWindowOut": "_compute_35_NodeGroupMaintenanceWindowOut",
        "DisksStartAsyncReplicationRequestIn": "_compute_36_DisksStartAsyncReplicationRequestIn",
        "DisksStartAsyncReplicationRequestOut": "_compute_37_DisksStartAsyncReplicationRequestOut",
        "TargetHttpProxyListIn": "_compute_38_TargetHttpProxyListIn",
        "TargetHttpProxyListOut": "_compute_39_TargetHttpProxyListOut",
        "TargetHttpsProxiesSetCertificateMapRequestIn": "_compute_40_TargetHttpsProxiesSetCertificateMapRequestIn",
        "TargetHttpsProxiesSetCertificateMapRequestOut": "_compute_41_TargetHttpsProxiesSetCertificateMapRequestOut",
        "LocationPolicyIn": "_compute_42_LocationPolicyIn",
        "LocationPolicyOut": "_compute_43_LocationPolicyOut",
        "InstanceWithNamedPortsIn": "_compute_44_InstanceWithNamedPortsIn",
        "InstanceWithNamedPortsOut": "_compute_45_InstanceWithNamedPortsOut",
        "InterconnectAttachmentConfigurationConstraintsBgpPeerASNRangeIn": "_compute_46_InterconnectAttachmentConfigurationConstraintsBgpPeerASNRangeIn",
        "InterconnectAttachmentConfigurationConstraintsBgpPeerASNRangeOut": "_compute_47_InterconnectAttachmentConfigurationConstraintsBgpPeerASNRangeOut",
        "InstancesGetEffectiveFirewallsResponseIn": "_compute_48_InstancesGetEffectiveFirewallsResponseIn",
        "InstancesGetEffectiveFirewallsResponseOut": "_compute_49_InstancesGetEffectiveFirewallsResponseOut",
        "SignedUrlKeyIn": "_compute_50_SignedUrlKeyIn",
        "SignedUrlKeyOut": "_compute_51_SignedUrlKeyOut",
        "NodeGroupsDeleteNodesRequestIn": "_compute_52_NodeGroupsDeleteNodesRequestIn",
        "NodeGroupsDeleteNodesRequestOut": "_compute_53_NodeGroupsDeleteNodesRequestOut",
        "RouterListIn": "_compute_54_RouterListIn",
        "RouterListOut": "_compute_55_RouterListOut",
        "TargetVpnGatewayAggregatedListIn": "_compute_56_TargetVpnGatewayAggregatedListIn",
        "TargetVpnGatewayAggregatedListOut": "_compute_57_TargetVpnGatewayAggregatedListOut",
        "InstanceGroupManagersListPerInstanceConfigsRespIn": "_compute_58_InstanceGroupManagersListPerInstanceConfigsRespIn",
        "InstanceGroupManagersListPerInstanceConfigsRespOut": "_compute_59_InstanceGroupManagersListPerInstanceConfigsRespOut",
        "DiskResourceStatusAsyncReplicationStatusIn": "_compute_60_DiskResourceStatusAsyncReplicationStatusIn",
        "DiskResourceStatusAsyncReplicationStatusOut": "_compute_61_DiskResourceStatusAsyncReplicationStatusOut",
        "HttpRouteRuleMatchIn": "_compute_62_HttpRouteRuleMatchIn",
        "HttpRouteRuleMatchOut": "_compute_63_HttpRouteRuleMatchOut",
        "InstancesSetLabelsRequestIn": "_compute_64_InstancesSetLabelsRequestIn",
        "InstancesSetLabelsRequestOut": "_compute_65_InstancesSetLabelsRequestOut",
        "InstanceAggregatedListIn": "_compute_66_InstanceAggregatedListIn",
        "InstanceAggregatedListOut": "_compute_67_InstanceAggregatedListOut",
        "TargetSslProxyIn": "_compute_68_TargetSslProxyIn",
        "TargetSslProxyOut": "_compute_69_TargetSslProxyOut",
        "BfdStatusIn": "_compute_70_BfdStatusIn",
        "BfdStatusOut": "_compute_71_BfdStatusOut",
        "SerialPortOutputIn": "_compute_72_SerialPortOutputIn",
        "SerialPortOutputOut": "_compute_73_SerialPortOutputOut",
        "PacketMirroringNetworkInfoIn": "_compute_74_PacketMirroringNetworkInfoIn",
        "PacketMirroringNetworkInfoOut": "_compute_75_PacketMirroringNetworkInfoOut",
        "OperationAggregatedListIn": "_compute_76_OperationAggregatedListIn",
        "OperationAggregatedListOut": "_compute_77_OperationAggregatedListOut",
        "WafExpressionSetExpressionIn": "_compute_78_WafExpressionSetExpressionIn",
        "WafExpressionSetExpressionOut": "_compute_79_WafExpressionSetExpressionOut",
        "TargetVpnGatewayIn": "_compute_80_TargetVpnGatewayIn",
        "TargetVpnGatewayOut": "_compute_81_TargetVpnGatewayOut",
        "ManagedInstanceLastAttemptIn": "_compute_82_ManagedInstanceLastAttemptIn",
        "ManagedInstanceLastAttemptOut": "_compute_83_ManagedInstanceLastAttemptOut",
        "HostRuleIn": "_compute_84_HostRuleIn",
        "HostRuleOut": "_compute_85_HostRuleOut",
        "TargetPoolListIn": "_compute_86_TargetPoolListIn",
        "TargetPoolListOut": "_compute_87_TargetPoolListOut",
        "BfdStatusPacketCountsIn": "_compute_88_BfdStatusPacketCountsIn",
        "BfdStatusPacketCountsOut": "_compute_89_BfdStatusPacketCountsOut",
        "BackendServiceLocalityLoadBalancingPolicyConfigPolicyIn": "_compute_90_BackendServiceLocalityLoadBalancingPolicyConfigPolicyIn",
        "BackendServiceLocalityLoadBalancingPolicyConfigPolicyOut": "_compute_91_BackendServiceLocalityLoadBalancingPolicyConfigPolicyOut",
        "DiskTypeIn": "_compute_92_DiskTypeIn",
        "DiskTypeOut": "_compute_93_DiskTypeOut",
        "AllocationResourceStatusIn": "_compute_94_AllocationResourceStatusIn",
        "AllocationResourceStatusOut": "_compute_95_AllocationResourceStatusOut",
        "SslCertificateManagedSslCertificateIn": "_compute_96_SslCertificateManagedSslCertificateIn",
        "SslCertificateManagedSslCertificateOut": "_compute_97_SslCertificateManagedSslCertificateOut",
        "PolicyIn": "_compute_98_PolicyIn",
        "PolicyOut": "_compute_99_PolicyOut",
        "InterconnectAttachmentAggregatedListIn": "_compute_100_InterconnectAttachmentAggregatedListIn",
        "InterconnectAttachmentAggregatedListOut": "_compute_101_InterconnectAttachmentAggregatedListOut",
        "InstancesSetMachineTypeRequestIn": "_compute_102_InstancesSetMachineTypeRequestIn",
        "InstancesSetMachineTypeRequestOut": "_compute_103_InstancesSetMachineTypeRequestOut",
        "InstanceGroupManagersDeleteInstancesRequestIn": "_compute_104_InstanceGroupManagersDeleteInstancesRequestIn",
        "InstanceGroupManagersDeleteInstancesRequestOut": "_compute_105_InstanceGroupManagersDeleteInstancesRequestOut",
        "BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicyIn": "_compute_106_BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicyIn",
        "BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicyOut": "_compute_107_BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicyOut",
        "LicenseResourceCommitmentIn": "_compute_108_LicenseResourceCommitmentIn",
        "LicenseResourceCommitmentOut": "_compute_109_LicenseResourceCommitmentOut",
        "InterconnectRemoteLocationListIn": "_compute_110_InterconnectRemoteLocationListIn",
        "InterconnectRemoteLocationListOut": "_compute_111_InterconnectRemoteLocationListOut",
        "RegionDisksResizeRequestIn": "_compute_112_RegionDisksResizeRequestIn",
        "RegionDisksResizeRequestOut": "_compute_113_RegionDisksResizeRequestOut",
        "PacketMirroringsScopedListIn": "_compute_114_PacketMirroringsScopedListIn",
        "PacketMirroringsScopedListOut": "_compute_115_PacketMirroringsScopedListOut",
        "TargetPoolInstanceHealthIn": "_compute_116_TargetPoolInstanceHealthIn",
        "TargetPoolInstanceHealthOut": "_compute_117_TargetPoolInstanceHealthOut",
        "RouterNatLogConfigIn": "_compute_118_RouterNatLogConfigIn",
        "RouterNatLogConfigOut": "_compute_119_RouterNatLogConfigOut",
        "InstanceConsumptionDataIn": "_compute_120_InstanceConsumptionDataIn",
        "InstanceConsumptionDataOut": "_compute_121_InstanceConsumptionDataOut",
        "NamedPortIn": "_compute_122_NamedPortIn",
        "NamedPortOut": "_compute_123_NamedPortOut",
        "Uint128In": "_compute_124_Uint128In",
        "Uint128Out": "_compute_125_Uint128Out",
        "HealthCheckServiceIn": "_compute_126_HealthCheckServiceIn",
        "HealthCheckServiceOut": "_compute_127_HealthCheckServiceOut",
        "DurationIn": "_compute_128_DurationIn",
        "DurationOut": "_compute_129_DurationOut",
        "ShareSettingsProjectConfigIn": "_compute_130_ShareSettingsProjectConfigIn",
        "ShareSettingsProjectConfigOut": "_compute_131_ShareSettingsProjectConfigOut",
        "DisplayDeviceIn": "_compute_132_DisplayDeviceIn",
        "DisplayDeviceOut": "_compute_133_DisplayDeviceOut",
        "NetworkPeeringIn": "_compute_134_NetworkPeeringIn",
        "NetworkPeeringOut": "_compute_135_NetworkPeeringOut",
        "DisksResizeRequestIn": "_compute_136_DisksResizeRequestIn",
        "DisksResizeRequestOut": "_compute_137_DisksResizeRequestOut",
        "GlobalSetPolicyRequestIn": "_compute_138_GlobalSetPolicyRequestIn",
        "GlobalSetPolicyRequestOut": "_compute_139_GlobalSetPolicyRequestOut",
        "NodeGroupListIn": "_compute_140_NodeGroupListIn",
        "NodeGroupListOut": "_compute_141_NodeGroupListOut",
        "InterconnectAttachmentListIn": "_compute_142_InterconnectAttachmentListIn",
        "InterconnectAttachmentListOut": "_compute_143_InterconnectAttachmentListOut",
        "TargetHttpsProxiesSetSslCertificatesRequestIn": "_compute_144_TargetHttpsProxiesSetSslCertificatesRequestIn",
        "TargetHttpsProxiesSetSslCertificatesRequestOut": "_compute_145_TargetHttpsProxiesSetSslCertificatesRequestOut",
        "InstanceGroupsListInstancesIn": "_compute_146_InstanceGroupsListInstancesIn",
        "InstanceGroupsListInstancesOut": "_compute_147_InstanceGroupsListInstancesOut",
        "InstanceParamsIn": "_compute_148_InstanceParamsIn",
        "InstanceParamsOut": "_compute_149_InstanceParamsOut",
        "AccessConfigIn": "_compute_150_AccessConfigIn",
        "AccessConfigOut": "_compute_151_AccessConfigOut",
        "NodeGroupsAddNodesRequestIn": "_compute_152_NodeGroupsAddNodesRequestIn",
        "NodeGroupsAddNodesRequestOut": "_compute_153_NodeGroupsAddNodesRequestOut",
        "PathRuleIn": "_compute_154_PathRuleIn",
        "PathRuleOut": "_compute_155_PathRuleOut",
        "MetadataIn": "_compute_156_MetadataIn",
        "MetadataOut": "_compute_157_MetadataOut",
        "InstanceGroupManagerStatusStatefulPerInstanceConfigsIn": "_compute_158_InstanceGroupManagerStatusStatefulPerInstanceConfigsIn",
        "InstanceGroupManagerStatusStatefulPerInstanceConfigsOut": "_compute_159_InstanceGroupManagerStatusStatefulPerInstanceConfigsOut",
        "SecurityPolicyAdaptiveProtectionConfigIn": "_compute_160_SecurityPolicyAdaptiveProtectionConfigIn",
        "SecurityPolicyAdaptiveProtectionConfigOut": "_compute_161_SecurityPolicyAdaptiveProtectionConfigOut",
        "WafExpressionSetIn": "_compute_162_WafExpressionSetIn",
        "WafExpressionSetOut": "_compute_163_WafExpressionSetOut",
        "BackendBucketCdnPolicyIn": "_compute_164_BackendBucketCdnPolicyIn",
        "BackendBucketCdnPolicyOut": "_compute_165_BackendBucketCdnPolicyOut",
        "RouterBgpPeerBfdIn": "_compute_166_RouterBgpPeerBfdIn",
        "RouterBgpPeerBfdOut": "_compute_167_RouterBgpPeerBfdOut",
        "LocalizedMessageIn": "_compute_168_LocalizedMessageIn",
        "LocalizedMessageOut": "_compute_169_LocalizedMessageOut",
        "InterconnectAttachmentConfigurationConstraintsIn": "_compute_170_InterconnectAttachmentConfigurationConstraintsIn",
        "InterconnectAttachmentConfigurationConstraintsOut": "_compute_171_InterconnectAttachmentConfigurationConstraintsOut",
        "DistributionPolicyIn": "_compute_172_DistributionPolicyIn",
        "DistributionPolicyOut": "_compute_173_DistributionPolicyOut",
        "VpnGatewayAggregatedListIn": "_compute_174_VpnGatewayAggregatedListIn",
        "VpnGatewayAggregatedListOut": "_compute_175_VpnGatewayAggregatedListOut",
        "SnapshotIn": "_compute_176_SnapshotIn",
        "SnapshotOut": "_compute_177_SnapshotOut",
        "AcceleratorConfigIn": "_compute_178_AcceleratorConfigIn",
        "AcceleratorConfigOut": "_compute_179_AcceleratorConfigOut",
        "InstanceManagedByIgmErrorInstanceActionDetailsIn": "_compute_180_InstanceManagedByIgmErrorInstanceActionDetailsIn",
        "InstanceManagedByIgmErrorInstanceActionDetailsOut": "_compute_181_InstanceManagedByIgmErrorInstanceActionDetailsOut",
        "TCPHealthCheckIn": "_compute_182_TCPHealthCheckIn",
        "TCPHealthCheckOut": "_compute_183_TCPHealthCheckOut",
        "TargetPoolsScopedListIn": "_compute_184_TargetPoolsScopedListIn",
        "TargetPoolsScopedListOut": "_compute_185_TargetPoolsScopedListOut",
        "MachineImageIn": "_compute_186_MachineImageIn",
        "MachineImageOut": "_compute_187_MachineImageOut",
        "InterconnectsGetDiagnosticsResponseIn": "_compute_188_InterconnectsGetDiagnosticsResponseIn",
        "InterconnectsGetDiagnosticsResponseOut": "_compute_189_InterconnectsGetDiagnosticsResponseOut",
        "BackendIn": "_compute_190_BackendIn",
        "BackendOut": "_compute_191_BackendOut",
        "PacketMirroringAggregatedListIn": "_compute_192_PacketMirroringAggregatedListIn",
        "PacketMirroringAggregatedListOut": "_compute_193_PacketMirroringAggregatedListOut",
        "InstancesSetMinCpuPlatformRequestIn": "_compute_194_InstancesSetMinCpuPlatformRequestIn",
        "InstancesSetMinCpuPlatformRequestOut": "_compute_195_InstancesSetMinCpuPlatformRequestOut",
        "ImageFamilyViewIn": "_compute_196_ImageFamilyViewIn",
        "ImageFamilyViewOut": "_compute_197_ImageFamilyViewOut",
        "AuditLogConfigIn": "_compute_198_AuditLogConfigIn",
        "AuditLogConfigOut": "_compute_199_AuditLogConfigOut",
        "TargetInstanceIn": "_compute_200_TargetInstanceIn",
        "TargetInstanceOut": "_compute_201_TargetInstanceOut",
        "RegionIn": "_compute_202_RegionIn",
        "RegionOut": "_compute_203_RegionOut",
        "InstanceGroupManagersApplyUpdatesRequestIn": "_compute_204_InstanceGroupManagersApplyUpdatesRequestIn",
        "InstanceGroupManagersApplyUpdatesRequestOut": "_compute_205_InstanceGroupManagersApplyUpdatesRequestOut",
        "PublicDelegatedPrefixIn": "_compute_206_PublicDelegatedPrefixIn",
        "PublicDelegatedPrefixOut": "_compute_207_PublicDelegatedPrefixOut",
        "ResourcePolicyHourlyCycleIn": "_compute_208_ResourcePolicyHourlyCycleIn",
        "ResourcePolicyHourlyCycleOut": "_compute_209_ResourcePolicyHourlyCycleOut",
        "SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfigIn": "_compute_210_SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfigIn",
        "SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfigOut": "_compute_211_SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfigOut",
        "InstanceGroupsRemoveInstancesRequestIn": "_compute_212_InstanceGroupsRemoveInstancesRequestIn",
        "InstanceGroupsRemoveInstancesRequestOut": "_compute_213_InstanceGroupsRemoveInstancesRequestOut",
        "InstanceGroupManagersUpdatePerInstanceConfigsReqIn": "_compute_214_InstanceGroupManagersUpdatePerInstanceConfigsReqIn",
        "InstanceGroupManagersUpdatePerInstanceConfigsReqOut": "_compute_215_InstanceGroupManagersUpdatePerInstanceConfigsReqOut",
        "InterconnectCircuitInfoIn": "_compute_216_InterconnectCircuitInfoIn",
        "InterconnectCircuitInfoOut": "_compute_217_InterconnectCircuitInfoOut",
        "InstanceTemplateIn": "_compute_218_InstanceTemplateIn",
        "InstanceTemplateOut": "_compute_219_InstanceTemplateOut",
        "RegionInstanceGroupManagersListErrorsResponseIn": "_compute_220_RegionInstanceGroupManagersListErrorsResponseIn",
        "RegionInstanceGroupManagersListErrorsResponseOut": "_compute_221_RegionInstanceGroupManagersListErrorsResponseOut",
        "RouterIn": "_compute_222_RouterIn",
        "RouterOut": "_compute_223_RouterOut",
        "PublicDelegatedPrefixPublicDelegatedSubPrefixIn": "_compute_224_PublicDelegatedPrefixPublicDelegatedSubPrefixIn",
        "PublicDelegatedPrefixPublicDelegatedSubPrefixOut": "_compute_225_PublicDelegatedPrefixPublicDelegatedSubPrefixOut",
        "SslPoliciesListIn": "_compute_226_SslPoliciesListIn",
        "SslPoliciesListOut": "_compute_227_SslPoliciesListOut",
        "PreservedStateIn": "_compute_228_PreservedStateIn",
        "PreservedStateOut": "_compute_229_PreservedStateOut",
        "UsableSubnetworksAggregatedListIn": "_compute_230_UsableSubnetworksAggregatedListIn",
        "UsableSubnetworksAggregatedListOut": "_compute_231_UsableSubnetworksAggregatedListOut",
        "ReservationAggregatedListIn": "_compute_232_ReservationAggregatedListIn",
        "ReservationAggregatedListOut": "_compute_233_ReservationAggregatedListOut",
        "RegionInstanceGroupsListInstancesIn": "_compute_234_RegionInstanceGroupsListInstancesIn",
        "RegionInstanceGroupsListInstancesOut": "_compute_235_RegionInstanceGroupsListInstancesOut",
        "NetworkAttachmentsScopedListIn": "_compute_236_NetworkAttachmentsScopedListIn",
        "NetworkAttachmentsScopedListOut": "_compute_237_NetworkAttachmentsScopedListOut",
        "RouterStatusResponseIn": "_compute_238_RouterStatusResponseIn",
        "RouterStatusResponseOut": "_compute_239_RouterStatusResponseOut",
        "TargetTcpProxyListIn": "_compute_240_TargetTcpProxyListIn",
        "TargetTcpProxyListOut": "_compute_241_TargetTcpProxyListOut",
        "SecurityPolicyRuleHttpHeaderActionIn": "_compute_242_SecurityPolicyRuleHttpHeaderActionIn",
        "SecurityPolicyRuleHttpHeaderActionOut": "_compute_243_SecurityPolicyRuleHttpHeaderActionOut",
        "SecurityPolicyRuleRedirectOptionsIn": "_compute_244_SecurityPolicyRuleRedirectOptionsIn",
        "SecurityPolicyRuleRedirectOptionsOut": "_compute_245_SecurityPolicyRuleRedirectOptionsOut",
        "NodeTemplateNodeTypeFlexibilityIn": "_compute_246_NodeTemplateNodeTypeFlexibilityIn",
        "NodeTemplateNodeTypeFlexibilityOut": "_compute_247_NodeTemplateNodeTypeFlexibilityOut",
        "InstanceGroupManagersListErrorsResponseIn": "_compute_248_InstanceGroupManagersListErrorsResponseIn",
        "InstanceGroupManagersListErrorsResponseOut": "_compute_249_InstanceGroupManagersListErrorsResponseOut",
        "MetadataFilterIn": "_compute_250_MetadataFilterIn",
        "MetadataFilterOut": "_compute_251_MetadataFilterOut",
        "InstanceReferenceIn": "_compute_252_InstanceReferenceIn",
        "InstanceReferenceOut": "_compute_253_InstanceReferenceOut",
        "DistributionPolicyZoneConfigurationIn": "_compute_254_DistributionPolicyZoneConfigurationIn",
        "DistributionPolicyZoneConfigurationOut": "_compute_255_DistributionPolicyZoneConfigurationOut",
        "NodeGroupNodeIn": "_compute_256_NodeGroupNodeIn",
        "NodeGroupNodeOut": "_compute_257_NodeGroupNodeOut",
        "HttpRedirectActionIn": "_compute_258_HttpRedirectActionIn",
        "HttpRedirectActionOut": "_compute_259_HttpRedirectActionOut",
        "QuotaExceededInfoIn": "_compute_260_QuotaExceededInfoIn",
        "QuotaExceededInfoOut": "_compute_261_QuotaExceededInfoOut",
        "UrlRewriteIn": "_compute_262_UrlRewriteIn",
        "UrlRewriteOut": "_compute_263_UrlRewriteOut",
        "ReservationAffinityIn": "_compute_264_ReservationAffinityIn",
        "ReservationAffinityOut": "_compute_265_ReservationAffinityOut",
        "InterconnectRemoteLocationConstraintsIn": "_compute_266_InterconnectRemoteLocationConstraintsIn",
        "InterconnectRemoteLocationConstraintsOut": "_compute_267_InterconnectRemoteLocationConstraintsOut",
        "SecurityPolicyRuleHttpHeaderActionHttpHeaderOptionIn": "_compute_268_SecurityPolicyRuleHttpHeaderActionHttpHeaderOptionIn",
        "SecurityPolicyRuleHttpHeaderActionHttpHeaderOptionOut": "_compute_269_SecurityPolicyRuleHttpHeaderActionHttpHeaderOptionOut",
        "UrlMapsAggregatedListIn": "_compute_270_UrlMapsAggregatedListIn",
        "UrlMapsAggregatedListOut": "_compute_271_UrlMapsAggregatedListOut",
        "SslPoliciesListAvailableFeaturesResponseIn": "_compute_272_SslPoliciesListAvailableFeaturesResponseIn",
        "SslPoliciesListAvailableFeaturesResponseOut": "_compute_273_SslPoliciesListAvailableFeaturesResponseOut",
        "TargetSslProxyListIn": "_compute_274_TargetSslProxyListIn",
        "TargetSslProxyListOut": "_compute_275_TargetSslProxyListOut",
        "NetworkRoutingConfigIn": "_compute_276_NetworkRoutingConfigIn",
        "NetworkRoutingConfigOut": "_compute_277_NetworkRoutingConfigOut",
        "InstancesStartWithEncryptionKeyRequestIn": "_compute_278_InstancesStartWithEncryptionKeyRequestIn",
        "InstancesStartWithEncryptionKeyRequestOut": "_compute_279_InstancesStartWithEncryptionKeyRequestOut",
        "RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn": "_compute_280_RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn",
        "RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut": "_compute_281_RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut",
        "FirewallPoliciesListAssociationsResponseIn": "_compute_282_FirewallPoliciesListAssociationsResponseIn",
        "FirewallPoliciesListAssociationsResponseOut": "_compute_283_FirewallPoliciesListAssociationsResponseOut",
        "PublicDelegatedPrefixListIn": "_compute_284_PublicDelegatedPrefixListIn",
        "PublicDelegatedPrefixListOut": "_compute_285_PublicDelegatedPrefixListOut",
        "BulkInsertDiskResourceIn": "_compute_286_BulkInsertDiskResourceIn",
        "BulkInsertDiskResourceOut": "_compute_287_BulkInsertDiskResourceOut",
        "SecurityPolicyRecaptchaOptionsConfigIn": "_compute_288_SecurityPolicyRecaptchaOptionsConfigIn",
        "SecurityPolicyRecaptchaOptionsConfigOut": "_compute_289_SecurityPolicyRecaptchaOptionsConfigOut",
        "ResourcePoliciesScopedListIn": "_compute_290_ResourcePoliciesScopedListIn",
        "ResourcePoliciesScopedListOut": "_compute_291_ResourcePoliciesScopedListOut",
        "InstancesAddResourcePoliciesRequestIn": "_compute_292_InstancesAddResourcePoliciesRequestIn",
        "InstancesAddResourcePoliciesRequestOut": "_compute_293_InstancesAddResourcePoliciesRequestOut",
        "InterconnectDiagnosticsLinkLACPStatusIn": "_compute_294_InterconnectDiagnosticsLinkLACPStatusIn",
        "InterconnectDiagnosticsLinkLACPStatusOut": "_compute_295_InterconnectDiagnosticsLinkLACPStatusOut",
        "SecurityPolicyRuleRateLimitOptionsIn": "_compute_296_SecurityPolicyRuleRateLimitOptionsIn",
        "SecurityPolicyRuleRateLimitOptionsOut": "_compute_297_SecurityPolicyRuleRateLimitOptionsOut",
        "SecurityPolicyRulePreconfiguredWafConfigIn": "_compute_298_SecurityPolicyRulePreconfiguredWafConfigIn",
        "SecurityPolicyRulePreconfiguredWafConfigOut": "_compute_299_SecurityPolicyRulePreconfiguredWafConfigOut",
        "NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn": "_compute_300_NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn",
        "NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut": "_compute_301_NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut",
        "VpnGatewayStatusTunnelIn": "_compute_302_VpnGatewayStatusTunnelIn",
        "VpnGatewayStatusTunnelOut": "_compute_303_VpnGatewayStatusTunnelOut",
        "VpnTunnelAggregatedListIn": "_compute_304_VpnTunnelAggregatedListIn",
        "VpnTunnelAggregatedListOut": "_compute_305_VpnTunnelAggregatedListOut",
        "RegionInstanceGroupManagerUpdateInstanceConfigReqIn": "_compute_306_RegionInstanceGroupManagerUpdateInstanceConfigReqIn",
        "RegionInstanceGroupManagerUpdateInstanceConfigReqOut": "_compute_307_RegionInstanceGroupManagerUpdateInstanceConfigReqOut",
        "InterconnectListIn": "_compute_308_InterconnectListIn",
        "InterconnectListOut": "_compute_309_InterconnectListOut",
        "QuotaIn": "_compute_310_QuotaIn",
        "QuotaOut": "_compute_311_QuotaOut",
        "StatefulPolicyPreservedStateDiskDeviceIn": "_compute_312_StatefulPolicyPreservedStateDiskDeviceIn",
        "StatefulPolicyPreservedStateDiskDeviceOut": "_compute_313_StatefulPolicyPreservedStateDiskDeviceOut",
        "GRPCHealthCheckIn": "_compute_314_GRPCHealthCheckIn",
        "GRPCHealthCheckOut": "_compute_315_GRPCHealthCheckOut",
        "RegionInstanceGroupManagerPatchInstanceConfigReqIn": "_compute_316_RegionInstanceGroupManagerPatchInstanceConfigReqIn",
        "RegionInstanceGroupManagerPatchInstanceConfigReqOut": "_compute_317_RegionInstanceGroupManagerPatchInstanceConfigReqOut",
        "BulkInsertInstanceResourceIn": "_compute_318_BulkInsertInstanceResourceIn",
        "BulkInsertInstanceResourceOut": "_compute_319_BulkInsertInstanceResourceOut",
        "DisksRemoveResourcePoliciesRequestIn": "_compute_320_DisksRemoveResourcePoliciesRequestIn",
        "DisksRemoveResourcePoliciesRequestOut": "_compute_321_DisksRemoveResourcePoliciesRequestOut",
        "BackendServiceIn": "_compute_322_BackendServiceIn",
        "BackendServiceOut": "_compute_323_BackendServiceOut",
        "StatefulPolicyIn": "_compute_324_StatefulPolicyIn",
        "StatefulPolicyOut": "_compute_325_StatefulPolicyOut",
        "TargetInstanceAggregatedListIn": "_compute_326_TargetInstanceAggregatedListIn",
        "TargetInstanceAggregatedListOut": "_compute_327_TargetInstanceAggregatedListOut",
        "NodeTemplateAggregatedListIn": "_compute_328_NodeTemplateAggregatedListIn",
        "NodeTemplateAggregatedListOut": "_compute_329_NodeTemplateAggregatedListOut",
        "AcceleratorTypeAggregatedListIn": "_compute_330_AcceleratorTypeAggregatedListIn",
        "AcceleratorTypeAggregatedListOut": "_compute_331_AcceleratorTypeAggregatedListOut",
        "NetworkEndpointGroupIn": "_compute_332_NetworkEndpointGroupIn",
        "NetworkEndpointGroupOut": "_compute_333_NetworkEndpointGroupOut",
        "TargetSslProxiesSetCertificateMapRequestIn": "_compute_334_TargetSslProxiesSetCertificateMapRequestIn",
        "TargetSslProxiesSetCertificateMapRequestOut": "_compute_335_TargetSslProxiesSetCertificateMapRequestOut",
        "HttpsHealthCheckListIn": "_compute_336_HttpsHealthCheckListIn",
        "HttpsHealthCheckListOut": "_compute_337_HttpsHealthCheckListOut",
        "ShieldedInstanceIdentityEntryIn": "_compute_338_ShieldedInstanceIdentityEntryIn",
        "ShieldedInstanceIdentityEntryOut": "_compute_339_ShieldedInstanceIdentityEntryOut",
        "SubnetworkListIn": "_compute_340_SubnetworkListIn",
        "SubnetworkListOut": "_compute_341_SubnetworkListOut",
        "SecurityPolicyIn": "_compute_342_SecurityPolicyIn",
        "SecurityPolicyOut": "_compute_343_SecurityPolicyOut",
        "FixedOrPercentIn": "_compute_344_FixedOrPercentIn",
        "FixedOrPercentOut": "_compute_345_FixedOrPercentOut",
        "InstanceGroupsSetNamedPortsRequestIn": "_compute_346_InstanceGroupsSetNamedPortsRequestIn",
        "InstanceGroupsSetNamedPortsRequestOut": "_compute_347_InstanceGroupsSetNamedPortsRequestOut",
        "AcceleratorTypesScopedListIn": "_compute_348_AcceleratorTypesScopedListIn",
        "AcceleratorTypesScopedListOut": "_compute_349_AcceleratorTypesScopedListOut",
        "NodeGroupsSimulateMaintenanceEventRequestIn": "_compute_350_NodeGroupsSimulateMaintenanceEventRequestIn",
        "NodeGroupsSimulateMaintenanceEventRequestOut": "_compute_351_NodeGroupsSimulateMaintenanceEventRequestOut",
        "NetworkEndpointGroupPscDataIn": "_compute_352_NetworkEndpointGroupPscDataIn",
        "NetworkEndpointGroupPscDataOut": "_compute_353_NetworkEndpointGroupPscDataOut",
        "ProjectsSetDefaultNetworkTierRequestIn": "_compute_354_ProjectsSetDefaultNetworkTierRequestIn",
        "ProjectsSetDefaultNetworkTierRequestOut": "_compute_355_ProjectsSetDefaultNetworkTierRequestOut",
        "RouterBgpPeerCustomLearnedIpRangeIn": "_compute_356_RouterBgpPeerCustomLearnedIpRangeIn",
        "RouterBgpPeerCustomLearnedIpRangeOut": "_compute_357_RouterBgpPeerCustomLearnedIpRangeOut",
        "DiskTypeAggregatedListIn": "_compute_358_DiskTypeAggregatedListIn",
        "DiskTypeAggregatedListOut": "_compute_359_DiskTypeAggregatedListOut",
        "InstanceGroupManagersSetInstanceTemplateRequestIn": "_compute_360_InstanceGroupManagersSetInstanceTemplateRequestIn",
        "InstanceGroupManagersSetInstanceTemplateRequestOut": "_compute_361_InstanceGroupManagersSetInstanceTemplateRequestOut",
        "DiskTypesScopedListIn": "_compute_362_DiskTypesScopedListIn",
        "DiskTypesScopedListOut": "_compute_363_DiskTypesScopedListOut",
        "InterconnectLocationRegionInfoIn": "_compute_364_InterconnectLocationRegionInfoIn",
        "InterconnectLocationRegionInfoOut": "_compute_365_InterconnectLocationRegionInfoOut",
        "ProjectsGetXpnResourcesIn": "_compute_366_ProjectsGetXpnResourcesIn",
        "ProjectsGetXpnResourcesOut": "_compute_367_ProjectsGetXpnResourcesOut",
        "ScreenshotIn": "_compute_368_ScreenshotIn",
        "ScreenshotOut": "_compute_369_ScreenshotOut",
        "HttpHealthCheckIn": "_compute_370_HttpHealthCheckIn",
        "HttpHealthCheckOut": "_compute_371_HttpHealthCheckOut",
        "RoutersPreviewResponseIn": "_compute_372_RoutersPreviewResponseIn",
        "RoutersPreviewResponseOut": "_compute_373_RoutersPreviewResponseOut",
        "ServiceAccountIn": "_compute_374_ServiceAccountIn",
        "ServiceAccountOut": "_compute_375_ServiceAccountOut",
        "RouterAggregatedListIn": "_compute_376_RouterAggregatedListIn",
        "RouterAggregatedListOut": "_compute_377_RouterAggregatedListOut",
        "PacketMirroringForwardingRuleInfoIn": "_compute_378_PacketMirroringForwardingRuleInfoIn",
        "PacketMirroringForwardingRuleInfoOut": "_compute_379_PacketMirroringForwardingRuleInfoOut",
        "HealthCheckIn": "_compute_380_HealthCheckIn",
        "HealthCheckOut": "_compute_381_HealthCheckOut",
        "SecurityPoliciesAggregatedListIn": "_compute_382_SecurityPoliciesAggregatedListIn",
        "SecurityPoliciesAggregatedListOut": "_compute_383_SecurityPoliciesAggregatedListOut",
        "ForwardingRuleIn": "_compute_384_ForwardingRuleIn",
        "ForwardingRuleOut": "_compute_385_ForwardingRuleOut",
        "ImageIn": "_compute_386_ImageIn",
        "ImageOut": "_compute_387_ImageOut",
        "ShieldedInstanceConfigIn": "_compute_388_ShieldedInstanceConfigIn",
        "ShieldedInstanceConfigOut": "_compute_389_ShieldedInstanceConfigOut",
        "ZoneSetLabelsRequestIn": "_compute_390_ZoneSetLabelsRequestIn",
        "ZoneSetLabelsRequestOut": "_compute_391_ZoneSetLabelsRequestOut",
        "NetworkEndpointWithHealthStatusIn": "_compute_392_NetworkEndpointWithHealthStatusIn",
        "NetworkEndpointWithHealthStatusOut": "_compute_393_NetworkEndpointWithHealthStatusOut",
        "MetadataFilterLabelMatchIn": "_compute_394_MetadataFilterLabelMatchIn",
        "MetadataFilterLabelMatchOut": "_compute_395_MetadataFilterLabelMatchOut",
        "RegionUrlMapsValidateRequestIn": "_compute_396_RegionUrlMapsValidateRequestIn",
        "RegionUrlMapsValidateRequestOut": "_compute_397_RegionUrlMapsValidateRequestOut",
        "RegionDisksAddResourcePoliciesRequestIn": "_compute_398_RegionDisksAddResourcePoliciesRequestIn",
        "RegionDisksAddResourcePoliciesRequestOut": "_compute_399_RegionDisksAddResourcePoliciesRequestOut",
        "PublicAdvertisedPrefixListIn": "_compute_400_PublicAdvertisedPrefixListIn",
        "PublicAdvertisedPrefixListOut": "_compute_401_PublicAdvertisedPrefixListOut",
        "GuestOsFeatureIn": "_compute_402_GuestOsFeatureIn",
        "GuestOsFeatureOut": "_compute_403_GuestOsFeatureOut",
        "SecuritySettingsIn": "_compute_404_SecuritySettingsIn",
        "SecuritySettingsOut": "_compute_405_SecuritySettingsOut",
        "ExchangedPeeringRouteIn": "_compute_406_ExchangedPeeringRouteIn",
        "ExchangedPeeringRouteOut": "_compute_407_ExchangedPeeringRouteOut",
        "InstanceGroupManagersCreateInstancesRequestIn": "_compute_408_InstanceGroupManagersCreateInstancesRequestIn",
        "InstanceGroupManagersCreateInstancesRequestOut": "_compute_409_InstanceGroupManagersCreateInstancesRequestOut",
        "SslPolicyIn": "_compute_410_SslPolicyIn",
        "SslPolicyOut": "_compute_411_SslPolicyOut",
        "RouterBgpPeerIn": "_compute_412_RouterBgpPeerIn",
        "RouterBgpPeerOut": "_compute_413_RouterBgpPeerOut",
        "GuestAttributesEntryIn": "_compute_414_GuestAttributesEntryIn",
        "GuestAttributesEntryOut": "_compute_415_GuestAttributesEntryOut",
        "CommitmentIn": "_compute_416_CommitmentIn",
        "CommitmentOut": "_compute_417_CommitmentOut",
        "ResourcePolicyInstanceSchedulePolicyIn": "_compute_418_ResourcePolicyInstanceSchedulePolicyIn",
        "ResourcePolicyInstanceSchedulePolicyOut": "_compute_419_ResourcePolicyInstanceSchedulePolicyOut",
        "NetworkEndpointGroupCloudFunctionIn": "_compute_420_NetworkEndpointGroupCloudFunctionIn",
        "NetworkEndpointGroupCloudFunctionOut": "_compute_421_NetworkEndpointGroupCloudFunctionOut",
        "ZoneIn": "_compute_422_ZoneIn",
        "ZoneOut": "_compute_423_ZoneOut",
        "NodeTemplateListIn": "_compute_424_NodeTemplateListIn",
        "NodeTemplateListOut": "_compute_425_NodeTemplateListOut",
        "HTTPSHealthCheckIn": "_compute_426_HTTPSHealthCheckIn",
        "HTTPSHealthCheckOut": "_compute_427_HTTPSHealthCheckOut",
        "InstancesSetNameRequestIn": "_compute_428_InstancesSetNameRequestIn",
        "InstancesSetNameRequestOut": "_compute_429_InstancesSetNameRequestOut",
        "Int64RangeMatchIn": "_compute_430_Int64RangeMatchIn",
        "Int64RangeMatchOut": "_compute_431_Int64RangeMatchOut",
        "OperationIn": "_compute_432_OperationIn",
        "OperationOut": "_compute_433_OperationOut",
        "NetworkEdgeSecurityServicesScopedListIn": "_compute_434_NetworkEdgeSecurityServicesScopedListIn",
        "NetworkEdgeSecurityServicesScopedListOut": "_compute_435_NetworkEdgeSecurityServicesScopedListOut",
        "TargetTcpProxiesScopedListIn": "_compute_436_TargetTcpProxiesScopedListIn",
        "TargetTcpProxiesScopedListOut": "_compute_437_TargetTcpProxiesScopedListOut",
        "UsageExportLocationIn": "_compute_438_UsageExportLocationIn",
        "UsageExportLocationOut": "_compute_439_UsageExportLocationOut",
        "TargetHttpProxiesScopedListIn": "_compute_440_TargetHttpProxiesScopedListIn",
        "TargetHttpProxiesScopedListOut": "_compute_441_TargetHttpProxiesScopedListOut",
        "AdvancedMachineFeaturesIn": "_compute_442_AdvancedMachineFeaturesIn",
        "AdvancedMachineFeaturesOut": "_compute_443_AdvancedMachineFeaturesOut",
        "LicenseResourceRequirementsIn": "_compute_444_LicenseResourceRequirementsIn",
        "LicenseResourceRequirementsOut": "_compute_445_LicenseResourceRequirementsOut",
        "SubnetworkSecondaryRangeIn": "_compute_446_SubnetworkSecondaryRangeIn",
        "SubnetworkSecondaryRangeOut": "_compute_447_SubnetworkSecondaryRangeOut",
        "NetworkEndpointGroupsScopedListIn": "_compute_448_NetworkEndpointGroupsScopedListIn",
        "NetworkEndpointGroupsScopedListOut": "_compute_449_NetworkEndpointGroupsScopedListOut",
        "ResourcePolicyInstanceSchedulePolicyScheduleIn": "_compute_450_ResourcePolicyInstanceSchedulePolicyScheduleIn",
        "ResourcePolicyInstanceSchedulePolicyScheduleOut": "_compute_451_ResourcePolicyInstanceSchedulePolicyScheduleOut",
        "SSLHealthCheckIn": "_compute_452_SSLHealthCheckIn",
        "SSLHealthCheckOut": "_compute_453_SSLHealthCheckOut",
        "NetworkEndpointGroupAppEngineIn": "_compute_454_NetworkEndpointGroupAppEngineIn",
        "NetworkEndpointGroupAppEngineOut": "_compute_455_NetworkEndpointGroupAppEngineOut",
        "CustomerEncryptionKeyProtectedDiskIn": "_compute_456_CustomerEncryptionKeyProtectedDiskIn",
        "CustomerEncryptionKeyProtectedDiskOut": "_compute_457_CustomerEncryptionKeyProtectedDiskOut",
        "SecurityPolicyRuleMatcherConfigIn": "_compute_458_SecurityPolicyRuleMatcherConfigIn",
        "SecurityPolicyRuleMatcherConfigOut": "_compute_459_SecurityPolicyRuleMatcherConfigOut",
        "InstanceGroupManagerStatusVersionTargetIn": "_compute_460_InstanceGroupManagerStatusVersionTargetIn",
        "InstanceGroupManagerStatusVersionTargetOut": "_compute_461_InstanceGroupManagerStatusVersionTargetOut",
        "TargetHttpProxyAggregatedListIn": "_compute_462_TargetHttpProxyAggregatedListIn",
        "TargetHttpProxyAggregatedListOut": "_compute_463_TargetHttpProxyAggregatedListOut",
        "TargetVpnGatewayListIn": "_compute_464_TargetVpnGatewayListIn",
        "TargetVpnGatewayListOut": "_compute_465_TargetVpnGatewayListOut",
        "ExprIn": "_compute_466_ExprIn",
        "ExprOut": "_compute_467_ExprOut",
        "HTTPHealthCheckIn": "_compute_468_HTTPHealthCheckIn",
        "HTTPHealthCheckOut": "_compute_469_HTTPHealthCheckOut",
        "VpnGatewayStatusVpnConnectionIn": "_compute_470_VpnGatewayStatusVpnConnectionIn",
        "VpnGatewayStatusVpnConnectionOut": "_compute_471_VpnGatewayStatusVpnConnectionOut",
        "ProjectsEnableXpnResourceRequestIn": "_compute_472_ProjectsEnableXpnResourceRequestIn",
        "ProjectsEnableXpnResourceRequestOut": "_compute_473_ProjectsEnableXpnResourceRequestOut",
        "InstanceGroupManagerVersionIn": "_compute_474_InstanceGroupManagerVersionIn",
        "InstanceGroupManagerVersionOut": "_compute_475_InstanceGroupManagerVersionOut",
        "ForwardingRuleAggregatedListIn": "_compute_476_ForwardingRuleAggregatedListIn",
        "ForwardingRuleAggregatedListOut": "_compute_477_ForwardingRuleAggregatedListOut",
        "NodeGroupAggregatedListIn": "_compute_478_NodeGroupAggregatedListIn",
        "NodeGroupAggregatedListOut": "_compute_479_NodeGroupAggregatedListOut",
        "XpnHostListIn": "_compute_480_XpnHostListIn",
        "XpnHostListOut": "_compute_481_XpnHostListOut",
        "NetworkPerformanceConfigIn": "_compute_482_NetworkPerformanceConfigIn",
        "NetworkPerformanceConfigOut": "_compute_483_NetworkPerformanceConfigOut",
        "TargetSslProxiesSetBackendServiceRequestIn": "_compute_484_TargetSslProxiesSetBackendServiceRequestIn",
        "TargetSslProxiesSetBackendServiceRequestOut": "_compute_485_TargetSslProxiesSetBackendServiceRequestOut",
        "CommitmentListIn": "_compute_486_CommitmentListIn",
        "CommitmentListOut": "_compute_487_CommitmentListOut",
        "NetworkListIn": "_compute_488_NetworkListIn",
        "NetworkListOut": "_compute_489_NetworkListOut",
        "AddressesScopedListIn": "_compute_490_AddressesScopedListIn",
        "AddressesScopedListOut": "_compute_491_AddressesScopedListOut",
        "SslPoliciesAggregatedListIn": "_compute_492_SslPoliciesAggregatedListIn",
        "SslPoliciesAggregatedListOut": "_compute_493_SslPoliciesAggregatedListOut",
        "InstancesSetServiceAccountRequestIn": "_compute_494_InstancesSetServiceAccountRequestIn",
        "InstancesSetServiceAccountRequestOut": "_compute_495_InstancesSetServiceAccountRequestOut",
        "UsableSubnetworkIn": "_compute_496_UsableSubnetworkIn",
        "UsableSubnetworkOut": "_compute_497_UsableSubnetworkOut",
        "RegionInstanceGroupManagersSetTargetPoolsRequestIn": "_compute_498_RegionInstanceGroupManagersSetTargetPoolsRequestIn",
        "RegionInstanceGroupManagersSetTargetPoolsRequestOut": "_compute_499_RegionInstanceGroupManagersSetTargetPoolsRequestOut",
        "FirewallPolicyAssociationIn": "_compute_500_FirewallPolicyAssociationIn",
        "FirewallPolicyAssociationOut": "_compute_501_FirewallPolicyAssociationOut",
        "HttpRouteActionIn": "_compute_502_HttpRouteActionIn",
        "HttpRouteActionOut": "_compute_503_HttpRouteActionOut",
        "SourceInstancePropertiesIn": "_compute_504_SourceInstancePropertiesIn",
        "SourceInstancePropertiesOut": "_compute_505_SourceInstancePropertiesOut",
        "InstanceGroupManagerUpdatePolicyIn": "_compute_506_InstanceGroupManagerUpdatePolicyIn",
        "InstanceGroupManagerUpdatePolicyOut": "_compute_507_InstanceGroupManagerUpdatePolicyOut",
        "TargetPoolsRemoveHealthCheckRequestIn": "_compute_508_TargetPoolsRemoveHealthCheckRequestIn",
        "TargetPoolsRemoveHealthCheckRequestOut": "_compute_509_TargetPoolsRemoveHealthCheckRequestOut",
        "ZoneListIn": "_compute_510_ZoneListIn",
        "ZoneListOut": "_compute_511_ZoneListOut",
        "BackendServiceCdnPolicyNegativeCachingPolicyIn": "_compute_512_BackendServiceCdnPolicyNegativeCachingPolicyIn",
        "BackendServiceCdnPolicyNegativeCachingPolicyOut": "_compute_513_BackendServiceCdnPolicyNegativeCachingPolicyOut",
        "SslCertificatesScopedListIn": "_compute_514_SslCertificatesScopedListIn",
        "SslCertificatesScopedListOut": "_compute_515_SslCertificatesScopedListOut",
        "NodeGroupsListNodesIn": "_compute_516_NodeGroupsListNodesIn",
        "NodeGroupsListNodesOut": "_compute_517_NodeGroupsListNodesOut",
        "BackendServiceLogConfigIn": "_compute_518_BackendServiceLogConfigIn",
        "BackendServiceLogConfigOut": "_compute_519_BackendServiceLogConfigOut",
        "BackendServiceReferenceIn": "_compute_520_BackendServiceReferenceIn",
        "BackendServiceReferenceOut": "_compute_521_BackendServiceReferenceOut",
        "BackendBucketIn": "_compute_522_BackendBucketIn",
        "BackendBucketOut": "_compute_523_BackendBucketOut",
        "RouterStatusNatStatusIn": "_compute_524_RouterStatusNatStatusIn",
        "RouterStatusNatStatusOut": "_compute_525_RouterStatusNatStatusOut",
        "TargetSslProxiesSetSslCertificatesRequestIn": "_compute_526_TargetSslProxiesSetSslCertificatesRequestIn",
        "TargetSslProxiesSetSslCertificatesRequestOut": "_compute_527_TargetSslProxiesSetSslCertificatesRequestOut",
        "ProjectsListXpnHostsRequestIn": "_compute_528_ProjectsListXpnHostsRequestIn",
        "ProjectsListXpnHostsRequestOut": "_compute_529_ProjectsListXpnHostsRequestOut",
        "UrlMapListIn": "_compute_530_UrlMapListIn",
        "UrlMapListOut": "_compute_531_UrlMapListOut",
        "GuestAttributesIn": "_compute_532_GuestAttributesIn",
        "GuestAttributesOut": "_compute_533_GuestAttributesOut",
        "InstancesSetMachineResourcesRequestIn": "_compute_534_InstancesSetMachineResourcesRequestIn",
        "InstancesSetMachineResourcesRequestOut": "_compute_535_InstancesSetMachineResourcesRequestOut",
        "InterconnectDiagnosticsLinkOpticalPowerIn": "_compute_536_InterconnectDiagnosticsLinkOpticalPowerIn",
        "InterconnectDiagnosticsLinkOpticalPowerOut": "_compute_537_InterconnectDiagnosticsLinkOpticalPowerOut",
        "SchedulingNodeAffinityIn": "_compute_538_SchedulingNodeAffinityIn",
        "SchedulingNodeAffinityOut": "_compute_539_SchedulingNodeAffinityOut",
        "GlobalNetworkEndpointGroupsDetachEndpointsRequestIn": "_compute_540_GlobalNetworkEndpointGroupsDetachEndpointsRequestIn",
        "GlobalNetworkEndpointGroupsDetachEndpointsRequestOut": "_compute_541_GlobalNetworkEndpointGroupsDetachEndpointsRequestOut",
        "FileContentBufferIn": "_compute_542_FileContentBufferIn",
        "FileContentBufferOut": "_compute_543_FileContentBufferOut",
        "LogConfigCounterOptionsIn": "_compute_544_LogConfigCounterOptionsIn",
        "LogConfigCounterOptionsOut": "_compute_545_LogConfigCounterOptionsOut",
        "InterconnectRemoteLocationPermittedConnectionsIn": "_compute_546_InterconnectRemoteLocationPermittedConnectionsIn",
        "InterconnectRemoteLocationPermittedConnectionsOut": "_compute_547_InterconnectRemoteLocationPermittedConnectionsOut",
        "ServiceAttachmentConsumerProjectLimitIn": "_compute_548_ServiceAttachmentConsumerProjectLimitIn",
        "ServiceAttachmentConsumerProjectLimitOut": "_compute_549_ServiceAttachmentConsumerProjectLimitOut",
        "ResourcePolicyDiskConsistencyGroupPolicyIn": "_compute_550_ResourcePolicyDiskConsistencyGroupPolicyIn",
        "ResourcePolicyDiskConsistencyGroupPolicyOut": "_compute_551_ResourcePolicyDiskConsistencyGroupPolicyOut",
        "VpnTunnelsScopedListIn": "_compute_552_VpnTunnelsScopedListIn",
        "VpnTunnelsScopedListOut": "_compute_553_VpnTunnelsScopedListOut",
        "TargetHttpsProxiesSetQuicOverrideRequestIn": "_compute_554_TargetHttpsProxiesSetQuicOverrideRequestIn",
        "TargetHttpsProxiesSetQuicOverrideRequestOut": "_compute_555_TargetHttpsProxiesSetQuicOverrideRequestOut",
        "ReservationIn": "_compute_556_ReservationIn",
        "ReservationOut": "_compute_557_ReservationOut",
        "RouterNatIn": "_compute_558_RouterNatIn",
        "RouterNatOut": "_compute_559_RouterNatOut",
        "InterconnectDiagnosticsLinkStatusIn": "_compute_560_InterconnectDiagnosticsLinkStatusIn",
        "InterconnectDiagnosticsLinkStatusOut": "_compute_561_InterconnectDiagnosticsLinkStatusOut",
        "NetworksUpdatePeeringRequestIn": "_compute_562_NetworksUpdatePeeringRequestIn",
        "NetworksUpdatePeeringRequestOut": "_compute_563_NetworksUpdatePeeringRequestOut",
        "MachineImageListIn": "_compute_564_MachineImageListIn",
        "MachineImageListOut": "_compute_565_MachineImageListOut",
        "InitialStateConfigIn": "_compute_566_InitialStateConfigIn",
        "InitialStateConfigOut": "_compute_567_InitialStateConfigOut",
        "FirewallPolicyRuleMatcherLayer4ConfigIn": "_compute_568_FirewallPolicyRuleMatcherLayer4ConfigIn",
        "FirewallPolicyRuleMatcherLayer4ConfigOut": "_compute_569_FirewallPolicyRuleMatcherLayer4ConfigOut",
        "HealthCheckReferenceIn": "_compute_570_HealthCheckReferenceIn",
        "HealthCheckReferenceOut": "_compute_571_HealthCheckReferenceOut",
        "UrlMapTestHeaderIn": "_compute_572_UrlMapTestHeaderIn",
        "UrlMapTestHeaderOut": "_compute_573_UrlMapTestHeaderOut",
        "LicenseCodeLicenseAliasIn": "_compute_574_LicenseCodeLicenseAliasIn",
        "LicenseCodeLicenseAliasOut": "_compute_575_LicenseCodeLicenseAliasOut",
        "NetworkEndpointIn": "_compute_576_NetworkEndpointIn",
        "NetworkEndpointOut": "_compute_577_NetworkEndpointOut",
        "InstanceGroupListIn": "_compute_578_InstanceGroupListIn",
        "InstanceGroupListOut": "_compute_579_InstanceGroupListOut",
        "PreservedStatePreservedDiskIn": "_compute_580_PreservedStatePreservedDiskIn",
        "PreservedStatePreservedDiskOut": "_compute_581_PreservedStatePreservedDiskOut",
        "SecurityPolicyAdvancedOptionsConfigIn": "_compute_582_SecurityPolicyAdvancedOptionsConfigIn",
        "SecurityPolicyAdvancedOptionsConfigOut": "_compute_583_SecurityPolicyAdvancedOptionsConfigOut",
        "TargetReferenceIn": "_compute_584_TargetReferenceIn",
        "TargetReferenceOut": "_compute_585_TargetReferenceOut",
        "RegionSetLabelsRequestIn": "_compute_586_RegionSetLabelsRequestIn",
        "RegionSetLabelsRequestOut": "_compute_587_RegionSetLabelsRequestOut",
        "NodeTemplatesScopedListIn": "_compute_588_NodeTemplatesScopedListIn",
        "NodeTemplatesScopedListOut": "_compute_589_NodeTemplatesScopedListOut",
        "SecurityPolicyRuleRateLimitOptionsThresholdIn": "_compute_590_SecurityPolicyRuleRateLimitOptionsThresholdIn",
        "SecurityPolicyRuleRateLimitOptionsThresholdOut": "_compute_591_SecurityPolicyRuleRateLimitOptionsThresholdOut",
        "InterconnectOutageNotificationIn": "_compute_592_InterconnectOutageNotificationIn",
        "InterconnectOutageNotificationOut": "_compute_593_InterconnectOutageNotificationOut",
        "AddressListIn": "_compute_594_AddressListIn",
        "AddressListOut": "_compute_595_AddressListOut",
        "AuditConfigIn": "_compute_596_AuditConfigIn",
        "AuditConfigOut": "_compute_597_AuditConfigOut",
        "ResourcePolicyAggregatedListIn": "_compute_598_ResourcePolicyAggregatedListIn",
        "ResourcePolicyAggregatedListOut": "_compute_599_ResourcePolicyAggregatedListOut",
        "HttpHeaderOptionIn": "_compute_600_HttpHeaderOptionIn",
        "HttpHeaderOptionOut": "_compute_601_HttpHeaderOptionOut",
        "AttachedDiskIn": "_compute_602_AttachedDiskIn",
        "AttachedDiskOut": "_compute_603_AttachedDiskOut",
        "NetworkEndpointGroupAggregatedListIn": "_compute_604_NetworkEndpointGroupAggregatedListIn",
        "NetworkEndpointGroupAggregatedListOut": "_compute_605_NetworkEndpointGroupAggregatedListOut",
        "InstanceGroupManagersRecreateInstancesRequestIn": "_compute_606_InstanceGroupManagersRecreateInstancesRequestIn",
        "InstanceGroupManagersRecreateInstancesRequestOut": "_compute_607_InstanceGroupManagersRecreateInstancesRequestOut",
        "HttpFaultAbortIn": "_compute_608_HttpFaultAbortIn",
        "HttpFaultAbortOut": "_compute_609_HttpFaultAbortOut",
        "RegionInstanceGroupsListInstancesRequestIn": "_compute_610_RegionInstanceGroupsListInstancesRequestIn",
        "RegionInstanceGroupsListInstancesRequestOut": "_compute_611_RegionInstanceGroupsListInstancesRequestOut",
        "VmEndpointNatMappingsListIn": "_compute_612_VmEndpointNatMappingsListIn",
        "VmEndpointNatMappingsListOut": "_compute_613_VmEndpointNatMappingsListOut",
        "HealthCheckServicesListIn": "_compute_614_HealthCheckServicesListIn",
        "HealthCheckServicesListOut": "_compute_615_HealthCheckServicesListOut",
        "RuleIn": "_compute_616_RuleIn",
        "RuleOut": "_compute_617_RuleOut",
        "VpnTunnelIn": "_compute_618_VpnTunnelIn",
        "VpnTunnelOut": "_compute_619_VpnTunnelOut",
        "InstanceGroupManagersDeletePerInstanceConfigsReqIn": "_compute_620_InstanceGroupManagersDeletePerInstanceConfigsReqIn",
        "InstanceGroupManagersDeletePerInstanceConfigsReqOut": "_compute_621_InstanceGroupManagersDeletePerInstanceConfigsReqOut",
        "GlobalNetworkEndpointGroupsAttachEndpointsRequestIn": "_compute_622_GlobalNetworkEndpointGroupsAttachEndpointsRequestIn",
        "GlobalNetworkEndpointGroupsAttachEndpointsRequestOut": "_compute_623_GlobalNetworkEndpointGroupsAttachEndpointsRequestOut",
        "TargetInstanceListIn": "_compute_624_TargetInstanceListIn",
        "TargetInstanceListOut": "_compute_625_TargetInstanceListOut",
        "AutoscalerListIn": "_compute_626_AutoscalerListIn",
        "AutoscalerListOut": "_compute_627_AutoscalerListOut",
        "InstanceGroupAggregatedListIn": "_compute_628_InstanceGroupAggregatedListIn",
        "InstanceGroupAggregatedListOut": "_compute_629_InstanceGroupAggregatedListOut",
        "AttachedDiskInitializeParamsIn": "_compute_630_AttachedDiskInitializeParamsIn",
        "AttachedDiskInitializeParamsOut": "_compute_631_AttachedDiskInitializeParamsOut",
        "NotificationEndpointIn": "_compute_632_NotificationEndpointIn",
        "NotificationEndpointOut": "_compute_633_NotificationEndpointOut",
        "HelpIn": "_compute_634_HelpIn",
        "HelpOut": "_compute_635_HelpOut",
        "RegionDisksRemoveResourcePoliciesRequestIn": "_compute_636_RegionDisksRemoveResourcePoliciesRequestIn",
        "RegionDisksRemoveResourcePoliciesRequestOut": "_compute_637_RegionDisksRemoveResourcePoliciesRequestOut",
        "TargetPoolIn": "_compute_638_TargetPoolIn",
        "TargetPoolOut": "_compute_639_TargetPoolOut",
        "RegionInstanceGroupManagersRecreateRequestIn": "_compute_640_RegionInstanceGroupManagersRecreateRequestIn",
        "RegionInstanceGroupManagersRecreateRequestOut": "_compute_641_RegionInstanceGroupManagersRecreateRequestOut",
        "HttpsHealthCheckIn": "_compute_642_HttpsHealthCheckIn",
        "HttpsHealthCheckOut": "_compute_643_HttpsHealthCheckOut",
        "InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn": "_compute_644_InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn",
        "InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut": "_compute_645_InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut",
        "AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskIn": "_compute_646_AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskIn",
        "AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskOut": "_compute_647_AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskOut",
        "NetworkEndpointGroupsAttachEndpointsRequestIn": "_compute_648_NetworkEndpointGroupsAttachEndpointsRequestIn",
        "NetworkEndpointGroupsAttachEndpointsRequestOut": "_compute_649_NetworkEndpointGroupsAttachEndpointsRequestOut",
        "RouterNatRuleActionIn": "_compute_650_RouterNatRuleActionIn",
        "RouterNatRuleActionOut": "_compute_651_RouterNatRuleActionOut",
        "ResourcePolicySnapshotSchedulePolicyScheduleIn": "_compute_652_ResourcePolicySnapshotSchedulePolicyScheduleIn",
        "ResourcePolicySnapshotSchedulePolicyScheduleOut": "_compute_653_ResourcePolicySnapshotSchedulePolicyScheduleOut",
        "ShieldedInstanceIdentityIn": "_compute_654_ShieldedInstanceIdentityIn",
        "ShieldedInstanceIdentityOut": "_compute_655_ShieldedInstanceIdentityOut",
        "TargetPoolsRemoveInstanceRequestIn": "_compute_656_TargetPoolsRemoveInstanceRequestIn",
        "TargetPoolsRemoveInstanceRequestOut": "_compute_657_TargetPoolsRemoveInstanceRequestOut",
        "SecurityPolicyAdvancedOptionsConfigJsonCustomConfigIn": "_compute_658_SecurityPolicyAdvancedOptionsConfigJsonCustomConfigIn",
        "SecurityPolicyAdvancedOptionsConfigJsonCustomConfigOut": "_compute_659_SecurityPolicyAdvancedOptionsConfigJsonCustomConfigOut",
        "InstancesRemoveResourcePoliciesRequestIn": "_compute_660_InstancesRemoveResourcePoliciesRequestIn",
        "InstancesRemoveResourcePoliciesRequestOut": "_compute_661_InstancesRemoveResourcePoliciesRequestOut",
        "UrlMapReferenceIn": "_compute_662_UrlMapReferenceIn",
        "UrlMapReferenceOut": "_compute_663_UrlMapReferenceOut",
        "SubnetworksExpandIpCidrRangeRequestIn": "_compute_664_SubnetworksExpandIpCidrRangeRequestIn",
        "SubnetworksExpandIpCidrRangeRequestOut": "_compute_665_SubnetworksExpandIpCidrRangeRequestOut",
        "InstanceGroupManagerAggregatedListIn": "_compute_666_InstanceGroupManagerAggregatedListIn",
        "InstanceGroupManagerAggregatedListOut": "_compute_667_InstanceGroupManagerAggregatedListOut",
        "OperationListIn": "_compute_668_OperationListIn",
        "OperationListOut": "_compute_669_OperationListOut",
        "InterconnectAttachmentPartnerMetadataIn": "_compute_670_InterconnectAttachmentPartnerMetadataIn",
        "InterconnectAttachmentPartnerMetadataOut": "_compute_671_InterconnectAttachmentPartnerMetadataOut",
        "AutoscalingPolicyCpuUtilizationIn": "_compute_672_AutoscalingPolicyCpuUtilizationIn",
        "AutoscalingPolicyCpuUtilizationOut": "_compute_673_AutoscalingPolicyCpuUtilizationOut",
        "TagsIn": "_compute_674_TagsIn",
        "TagsOut": "_compute_675_TagsOut",
        "CustomerEncryptionKeyIn": "_compute_676_CustomerEncryptionKeyIn",
        "CustomerEncryptionKeyOut": "_compute_677_CustomerEncryptionKeyOut",
        "RouterMd5AuthenticationKeyIn": "_compute_678_RouterMd5AuthenticationKeyIn",
        "RouterMd5AuthenticationKeyOut": "_compute_679_RouterMd5AuthenticationKeyOut",
        "RegionInstanceGroupManagersCreateInstancesRequestIn": "_compute_680_RegionInstanceGroupManagersCreateInstancesRequestIn",
        "RegionInstanceGroupManagersCreateInstancesRequestOut": "_compute_681_RegionInstanceGroupManagersCreateInstancesRequestOut",
        "AutoscalersScopedListIn": "_compute_682_AutoscalersScopedListIn",
        "AutoscalersScopedListOut": "_compute_683_AutoscalersScopedListOut",
        "InstanceGroupManagerStatusStatefulIn": "_compute_684_InstanceGroupManagerStatusStatefulIn",
        "InstanceGroupManagerStatusStatefulOut": "_compute_685_InstanceGroupManagerStatusStatefulOut",
        "NodeTypeAggregatedListIn": "_compute_686_NodeTypeAggregatedListIn",
        "NodeTypeAggregatedListOut": "_compute_687_NodeTypeAggregatedListOut",
        "NodeTypesScopedListIn": "_compute_688_NodeTypesScopedListIn",
        "NodeTypesScopedListOut": "_compute_689_NodeTypesScopedListOut",
        "HealthCheckServiceReferenceIn": "_compute_690_HealthCheckServiceReferenceIn",
        "HealthCheckServiceReferenceOut": "_compute_691_HealthCheckServiceReferenceOut",
        "HealthCheckListIn": "_compute_692_HealthCheckListIn",
        "HealthCheckListOut": "_compute_693_HealthCheckListOut",
        "VmEndpointNatMappingsIn": "_compute_694_VmEndpointNatMappingsIn",
        "VmEndpointNatMappingsOut": "_compute_695_VmEndpointNatMappingsOut",
        "VpnGatewayVpnGatewayInterfaceIn": "_compute_696_VpnGatewayVpnGatewayInterfaceIn",
        "VpnGatewayVpnGatewayInterfaceOut": "_compute_697_VpnGatewayVpnGatewayInterfaceOut",
        "ZoneSetPolicyRequestIn": "_compute_698_ZoneSetPolicyRequestIn",
        "ZoneSetPolicyRequestOut": "_compute_699_ZoneSetPolicyRequestOut",
        "FirewallListIn": "_compute_700_FirewallListIn",
        "FirewallListOut": "_compute_701_FirewallListOut",
        "HttpQueryParameterMatchIn": "_compute_702_HttpQueryParameterMatchIn",
        "HttpQueryParameterMatchOut": "_compute_703_HttpQueryParameterMatchOut",
        "SourceInstanceParamsIn": "_compute_704_SourceInstanceParamsIn",
        "SourceInstanceParamsOut": "_compute_705_SourceInstanceParamsOut",
        "InterconnectIn": "_compute_706_InterconnectIn",
        "InterconnectOut": "_compute_707_InterconnectOut",
        "InstanceGroupManagerStatusIn": "_compute_708_InstanceGroupManagerStatusIn",
        "InstanceGroupManagerStatusOut": "_compute_709_InstanceGroupManagerStatusOut",
        "RouteListIn": "_compute_710_RouteListIn",
        "RouteListOut": "_compute_711_RouteListOut",
        "ResourcePolicyListIn": "_compute_712_ResourcePolicyListIn",
        "ResourcePolicyListOut": "_compute_713_ResourcePolicyListOut",
        "ConditionIn": "_compute_714_ConditionIn",
        "ConditionOut": "_compute_715_ConditionOut",
        "ShieldedInstanceIntegrityPolicyIn": "_compute_716_ShieldedInstanceIntegrityPolicyIn",
        "ShieldedInstanceIntegrityPolicyOut": "_compute_717_ShieldedInstanceIntegrityPolicyOut",
        "FirewallIn": "_compute_718_FirewallIn",
        "FirewallOut": "_compute_719_FirewallOut",
        "TargetHttpsProxiesScopedListIn": "_compute_720_TargetHttpsProxiesScopedListIn",
        "TargetHttpsProxiesScopedListOut": "_compute_721_TargetHttpsProxiesScopedListOut",
        "TargetHttpProxyIn": "_compute_722_TargetHttpProxyIn",
        "TargetHttpProxyOut": "_compute_723_TargetHttpProxyOut",
        "SubnetworkAggregatedListIn": "_compute_724_SubnetworkAggregatedListIn",
        "SubnetworkAggregatedListOut": "_compute_725_SubnetworkAggregatedListOut",
        "NotificationEndpointGrpcSettingsIn": "_compute_726_NotificationEndpointGrpcSettingsIn",
        "NotificationEndpointGrpcSettingsOut": "_compute_727_NotificationEndpointGrpcSettingsOut",
        "TargetTcpProxyIn": "_compute_728_TargetTcpProxyIn",
        "TargetTcpProxyOut": "_compute_729_TargetTcpProxyOut",
        "FirewallPolicyIn": "_compute_730_FirewallPolicyIn",
        "FirewallPolicyOut": "_compute_731_FirewallPolicyOut",
        "ResourcePolicyDailyCycleIn": "_compute_732_ResourcePolicyDailyCycleIn",
        "ResourcePolicyDailyCycleOut": "_compute_733_ResourcePolicyDailyCycleOut",
        "NotificationEndpointListIn": "_compute_734_NotificationEndpointListIn",
        "NotificationEndpointListOut": "_compute_735_NotificationEndpointListOut",
        "CacheKeyPolicyIn": "_compute_736_CacheKeyPolicyIn",
        "CacheKeyPolicyOut": "_compute_737_CacheKeyPolicyOut",
        "CommitmentsScopedListIn": "_compute_738_CommitmentsScopedListIn",
        "CommitmentsScopedListOut": "_compute_739_CommitmentsScopedListOut",
        "ResourcePolicyResourceStatusInstanceSchedulePolicyStatusIn": "_compute_740_ResourcePolicyResourceStatusInstanceSchedulePolicyStatusIn",
        "ResourcePolicyResourceStatusInstanceSchedulePolicyStatusOut": "_compute_741_ResourcePolicyResourceStatusInstanceSchedulePolicyStatusOut",
        "RegionInstanceGroupManagersListInstancesResponseIn": "_compute_742_RegionInstanceGroupManagersListInstancesResponseIn",
        "RegionInstanceGroupManagersListInstancesResponseOut": "_compute_743_RegionInstanceGroupManagersListInstancesResponseOut",
        "ErrorInfoIn": "_compute_744_ErrorInfoIn",
        "ErrorInfoOut": "_compute_745_ErrorInfoOut",
        "XpnResourceIdIn": "_compute_746_XpnResourceIdIn",
        "XpnResourceIdOut": "_compute_747_XpnResourceIdOut",
        "InstanceListReferrersIn": "_compute_748_InstanceListReferrersIn",
        "InstanceListReferrersOut": "_compute_749_InstanceListReferrersOut",
        "NodeGroupIn": "_compute_750_NodeGroupIn",
        "NodeGroupOut": "_compute_751_NodeGroupOut",
        "RouterNatRuleIn": "_compute_752_RouterNatRuleIn",
        "RouterNatRuleOut": "_compute_753_RouterNatRuleOut",
        "BackendServiceCdnPolicyIn": "_compute_754_BackendServiceCdnPolicyIn",
        "BackendServiceCdnPolicyOut": "_compute_755_BackendServiceCdnPolicyOut",
        "ServerBindingIn": "_compute_756_ServerBindingIn",
        "ServerBindingOut": "_compute_757_ServerBindingOut",
        "TargetGrpcProxyListIn": "_compute_758_TargetGrpcProxyListIn",
        "TargetGrpcProxyListOut": "_compute_759_TargetGrpcProxyListOut",
        "AutoscalerAggregatedListIn": "_compute_760_AutoscalerAggregatedListIn",
        "AutoscalerAggregatedListOut": "_compute_761_AutoscalerAggregatedListOut",
        "DiskListIn": "_compute_762_DiskListIn",
        "DiskListOut": "_compute_763_DiskListOut",
        "SecurityPolicyRuleMatcherIn": "_compute_764_SecurityPolicyRuleMatcherIn",
        "SecurityPolicyRuleMatcherOut": "_compute_765_SecurityPolicyRuleMatcherOut",
        "TargetPoolsAddInstanceRequestIn": "_compute_766_TargetPoolsAddInstanceRequestIn",
        "TargetPoolsAddInstanceRequestOut": "_compute_767_TargetPoolsAddInstanceRequestOut",
        "VmEndpointNatMappingsInterfaceNatMappingsIn": "_compute_768_VmEndpointNatMappingsInterfaceNatMappingsIn",
        "VmEndpointNatMappingsInterfaceNatMappingsOut": "_compute_769_VmEndpointNatMappingsInterfaceNatMappingsOut",
        "TargetHttpsProxyAggregatedListIn": "_compute_770_TargetHttpsProxyAggregatedListIn",
        "TargetHttpsProxyAggregatedListOut": "_compute_771_TargetHttpsProxyAggregatedListOut",
        "VpnGatewaysScopedListIn": "_compute_772_VpnGatewaysScopedListIn",
        "VpnGatewaysScopedListOut": "_compute_773_VpnGatewaysScopedListOut",
        "BackendServiceIAPIn": "_compute_774_BackendServiceIAPIn",
        "BackendServiceIAPOut": "_compute_775_BackendServiceIAPOut",
        "TargetVpnGatewaysScopedListIn": "_compute_776_TargetVpnGatewaysScopedListIn",
        "TargetVpnGatewaysScopedListOut": "_compute_777_TargetVpnGatewaysScopedListOut",
        "RegionInstanceGroupManagersAbandonInstancesRequestIn": "_compute_778_RegionInstanceGroupManagersAbandonInstancesRequestIn",
        "RegionInstanceGroupManagersAbandonInstancesRequestOut": "_compute_779_RegionInstanceGroupManagersAbandonInstancesRequestOut",
        "SslPoliciesScopedListIn": "_compute_780_SslPoliciesScopedListIn",
        "SslPoliciesScopedListOut": "_compute_781_SslPoliciesScopedListOut",
        "AutoscalerIn": "_compute_782_AutoscalerIn",
        "AutoscalerOut": "_compute_783_AutoscalerOut",
        "RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseIn": "_compute_784_RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseIn",
        "RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseOut": "_compute_785_RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseOut",
        "MachineTypesScopedListIn": "_compute_786_MachineTypesScopedListIn",
        "MachineTypesScopedListOut": "_compute_787_MachineTypesScopedListOut",
        "InstanceMoveRequestIn": "_compute_788_InstanceMoveRequestIn",
        "InstanceMoveRequestOut": "_compute_789_InstanceMoveRequestOut",
        "ExchangedPeeringRoutesListIn": "_compute_790_ExchangedPeeringRoutesListIn",
        "ExchangedPeeringRoutesListOut": "_compute_791_ExchangedPeeringRoutesListOut",
        "RouterAdvertisedIpRangeIn": "_compute_792_RouterAdvertisedIpRangeIn",
        "RouterAdvertisedIpRangeOut": "_compute_793_RouterAdvertisedIpRangeOut",
        "FirewallPolicyRuleMatcherIn": "_compute_794_FirewallPolicyRuleMatcherIn",
        "FirewallPolicyRuleMatcherOut": "_compute_795_FirewallPolicyRuleMatcherOut",
        "LicenseCodeIn": "_compute_796_LicenseCodeIn",
        "LicenseCodeOut": "_compute_797_LicenseCodeOut",
        "SslCertificateListIn": "_compute_798_SslCertificateListIn",
        "SslCertificateListOut": "_compute_799_SslCertificateListOut",
        "ConsistentHashLoadBalancerSettingsIn": "_compute_800_ConsistentHashLoadBalancerSettingsIn",
        "ConsistentHashLoadBalancerSettingsOut": "_compute_801_ConsistentHashLoadBalancerSettingsOut",
        "ResourcePolicyIn": "_compute_802_ResourcePolicyIn",
        "ResourcePolicyOut": "_compute_803_ResourcePolicyOut",
        "ImageListIn": "_compute_804_ImageListIn",
        "ImageListOut": "_compute_805_ImageListOut",
        "InstanceGroupManagersScopedListIn": "_compute_806_InstanceGroupManagersScopedListIn",
        "InstanceGroupManagersScopedListOut": "_compute_807_InstanceGroupManagersScopedListOut",
        "RegionInstanceGroupManagersDeleteInstancesRequestIn": "_compute_808_RegionInstanceGroupManagersDeleteInstancesRequestIn",
        "RegionInstanceGroupManagersDeleteInstancesRequestOut": "_compute_809_RegionInstanceGroupManagersDeleteInstancesRequestOut",
        "ForwardingRuleReferenceIn": "_compute_810_ForwardingRuleReferenceIn",
        "ForwardingRuleReferenceOut": "_compute_811_ForwardingRuleReferenceOut",
        "LicensesListResponseIn": "_compute_812_LicensesListResponseIn",
        "LicensesListResponseOut": "_compute_813_LicensesListResponseOut",
        "ReferenceIn": "_compute_814_ReferenceIn",
        "ReferenceOut": "_compute_815_ReferenceOut",
        "InstanceGroupManagerIn": "_compute_816_InstanceGroupManagerIn",
        "InstanceGroupManagerOut": "_compute_817_InstanceGroupManagerOut",
        "ProjectsDisableXpnResourceRequestIn": "_compute_818_ProjectsDisableXpnResourceRequestIn",
        "ProjectsDisableXpnResourceRequestOut": "_compute_819_ProjectsDisableXpnResourceRequestOut",
        "InstanceManagedByIgmErrorIn": "_compute_820_InstanceManagedByIgmErrorIn",
        "InstanceManagedByIgmErrorOut": "_compute_821_InstanceManagedByIgmErrorOut",
        "ManagedInstanceVersionIn": "_compute_822_ManagedInstanceVersionIn",
        "ManagedInstanceVersionOut": "_compute_823_ManagedInstanceVersionOut",
        "PacketMirroringIn": "_compute_824_PacketMirroringIn",
        "PacketMirroringOut": "_compute_825_PacketMirroringOut",
        "InstanceGroupManagerListIn": "_compute_826_InstanceGroupManagerListIn",
        "InstanceGroupManagerListOut": "_compute_827_InstanceGroupManagerListOut",
        "BackendBucketCdnPolicyNegativeCachingPolicyIn": "_compute_828_BackendBucketCdnPolicyNegativeCachingPolicyIn",
        "BackendBucketCdnPolicyNegativeCachingPolicyOut": "_compute_829_BackendBucketCdnPolicyNegativeCachingPolicyOut",
        "RegionInstanceGroupListIn": "_compute_830_RegionInstanceGroupListIn",
        "RegionInstanceGroupListOut": "_compute_831_RegionInstanceGroupListOut",
        "BackendBucketListIn": "_compute_832_BackendBucketListIn",
        "BackendBucketListOut": "_compute_833_BackendBucketListOut",
        "BackendServiceGroupHealthIn": "_compute_834_BackendServiceGroupHealthIn",
        "BackendServiceGroupHealthOut": "_compute_835_BackendServiceGroupHealthOut",
        "LicenseIn": "_compute_836_LicenseIn",
        "LicenseOut": "_compute_837_LicenseOut",
        "ProjectIn": "_compute_838_ProjectIn",
        "ProjectOut": "_compute_839_ProjectOut",
        "GuestAttributesValueIn": "_compute_840_GuestAttributesValueIn",
        "GuestAttributesValueOut": "_compute_841_GuestAttributesValueOut",
        "PacketMirroringFilterIn": "_compute_842_PacketMirroringFilterIn",
        "PacketMirroringFilterOut": "_compute_843_PacketMirroringFilterOut",
        "ReservationsResizeRequestIn": "_compute_844_ReservationsResizeRequestIn",
        "ReservationsResizeRequestOut": "_compute_845_ReservationsResizeRequestOut",
        "ConnectionDrainingIn": "_compute_846_ConnectionDrainingIn",
        "ConnectionDrainingOut": "_compute_847_ConnectionDrainingOut",
        "GlobalAddressesMoveRequestIn": "_compute_848_GlobalAddressesMoveRequestIn",
        "GlobalAddressesMoveRequestOut": "_compute_849_GlobalAddressesMoveRequestOut",
        "AutoscalingPolicyLoadBalancingUtilizationIn": "_compute_850_AutoscalingPolicyLoadBalancingUtilizationIn",
        "AutoscalingPolicyLoadBalancingUtilizationOut": "_compute_851_AutoscalingPolicyLoadBalancingUtilizationOut",
        "TargetTcpProxiesSetProxyHeaderRequestIn": "_compute_852_TargetTcpProxiesSetProxyHeaderRequestIn",
        "TargetTcpProxiesSetProxyHeaderRequestOut": "_compute_853_TargetTcpProxiesSetProxyHeaderRequestOut",
        "WeightedBackendServiceIn": "_compute_854_WeightedBackendServiceIn",
        "WeightedBackendServiceOut": "_compute_855_WeightedBackendServiceOut",
        "DiskResourceStatusIn": "_compute_856_DiskResourceStatusIn",
        "DiskResourceStatusOut": "_compute_857_DiskResourceStatusOut",
        "RegionInstanceGroupsSetNamedPortsRequestIn": "_compute_858_RegionInstanceGroupsSetNamedPortsRequestIn",
        "RegionInstanceGroupsSetNamedPortsRequestOut": "_compute_859_RegionInstanceGroupsSetNamedPortsRequestOut",
        "TargetPoolsAddHealthCheckRequestIn": "_compute_860_TargetPoolsAddHealthCheckRequestIn",
        "TargetPoolsAddHealthCheckRequestOut": "_compute_861_TargetPoolsAddHealthCheckRequestOut",
        "PerInstanceConfigIn": "_compute_862_PerInstanceConfigIn",
        "PerInstanceConfigOut": "_compute_863_PerInstanceConfigOut",
        "RouterNatSubnetworkToNatIn": "_compute_864_RouterNatSubnetworkToNatIn",
        "RouterNatSubnetworkToNatOut": "_compute_865_RouterNatSubnetworkToNatOut",
        "HttpFaultInjectionIn": "_compute_866_HttpFaultInjectionIn",
        "HttpFaultInjectionOut": "_compute_867_HttpFaultInjectionOut",
        "DiskIn": "_compute_868_DiskIn",
        "DiskOut": "_compute_869_DiskOut",
        "AcceleratorTypeListIn": "_compute_870_AcceleratorTypeListIn",
        "AcceleratorTypeListOut": "_compute_871_AcceleratorTypeListOut",
        "UrlMapsScopedListIn": "_compute_872_UrlMapsScopedListIn",
        "UrlMapsScopedListOut": "_compute_873_UrlMapsScopedListOut",
        "RouterStatusIn": "_compute_874_RouterStatusIn",
        "RouterStatusOut": "_compute_875_RouterStatusOut",
        "PacketMirroringMirroredResourceInfoInstanceInfoIn": "_compute_876_PacketMirroringMirroredResourceInfoInstanceInfoIn",
        "PacketMirroringMirroredResourceInfoInstanceInfoOut": "_compute_877_PacketMirroringMirroredResourceInfoInstanceInfoOut",
        "SecurityPolicyReferenceIn": "_compute_878_SecurityPolicyReferenceIn",
        "SecurityPolicyReferenceOut": "_compute_879_SecurityPolicyReferenceOut",
        "SecurityPolicyRuleIn": "_compute_880_SecurityPolicyRuleIn",
        "SecurityPolicyRuleOut": "_compute_881_SecurityPolicyRuleOut",
        "ExternalVpnGatewayIn": "_compute_882_ExternalVpnGatewayIn",
        "ExternalVpnGatewayOut": "_compute_883_ExternalVpnGatewayOut",
        "SourceDiskEncryptionKeyIn": "_compute_884_SourceDiskEncryptionKeyIn",
        "SourceDiskEncryptionKeyOut": "_compute_885_SourceDiskEncryptionKeyOut",
        "MachineTypeIn": "_compute_886_MachineTypeIn",
        "MachineTypeOut": "_compute_887_MachineTypeOut",
        "ResourcePolicyResourceStatusIn": "_compute_888_ResourcePolicyResourceStatusIn",
        "ResourcePolicyResourceStatusOut": "_compute_889_ResourcePolicyResourceStatusOut",
        "BackendServicesScopedListIn": "_compute_890_BackendServicesScopedListIn",
        "BackendServicesScopedListOut": "_compute_891_BackendServicesScopedListOut",
        "TargetSslProxiesSetProxyHeaderRequestIn": "_compute_892_TargetSslProxiesSetProxyHeaderRequestIn",
        "TargetSslProxiesSetProxyHeaderRequestOut": "_compute_893_TargetSslProxiesSetProxyHeaderRequestOut",
        "HttpHeaderActionIn": "_compute_894_HttpHeaderActionIn",
        "HttpHeaderActionOut": "_compute_895_HttpHeaderActionOut",
        "SslCertificateIn": "_compute_896_SslCertificateIn",
        "SslCertificateOut": "_compute_897_SslCertificateOut",
        "TargetGrpcProxyIn": "_compute_898_TargetGrpcProxyIn",
        "TargetGrpcProxyOut": "_compute_899_TargetGrpcProxyOut",
        "BackendBucketCdnPolicyBypassCacheOnRequestHeaderIn": "_compute_900_BackendBucketCdnPolicyBypassCacheOnRequestHeaderIn",
        "BackendBucketCdnPolicyBypassCacheOnRequestHeaderOut": "_compute_901_BackendBucketCdnPolicyBypassCacheOnRequestHeaderOut",
        "FirewallPolicyRuleIn": "_compute_902_FirewallPolicyRuleIn",
        "FirewallPolicyRuleOut": "_compute_903_FirewallPolicyRuleOut",
        "LogConfigCounterOptionsCustomFieldIn": "_compute_904_LogConfigCounterOptionsCustomFieldIn",
        "LogConfigCounterOptionsCustomFieldOut": "_compute_905_LogConfigCounterOptionsCustomFieldOut",
        "InstanceConsumptionInfoIn": "_compute_906_InstanceConsumptionInfoIn",
        "InstanceConsumptionInfoOut": "_compute_907_InstanceConsumptionInfoOut",
        "ForwardingRuleListIn": "_compute_908_ForwardingRuleListIn",
        "ForwardingRuleListOut": "_compute_909_ForwardingRuleListOut",
        "ServiceAttachmentAggregatedListIn": "_compute_910_ServiceAttachmentAggregatedListIn",
        "ServiceAttachmentAggregatedListOut": "_compute_911_ServiceAttachmentAggregatedListOut",
        "InterconnectRemoteLocationConstraintsSubnetLengthRangeIn": "_compute_912_InterconnectRemoteLocationConstraintsSubnetLengthRangeIn",
        "InterconnectRemoteLocationConstraintsSubnetLengthRangeOut": "_compute_913_InterconnectRemoteLocationConstraintsSubnetLengthRangeOut",
        "ManagedInstanceIn": "_compute_914_ManagedInstanceIn",
        "ManagedInstanceOut": "_compute_915_ManagedInstanceOut",
        "InterconnectAttachmentsScopedListIn": "_compute_916_InterconnectAttachmentsScopedListIn",
        "InterconnectAttachmentsScopedListOut": "_compute_917_InterconnectAttachmentsScopedListOut",
        "ResourcePolicySnapshotSchedulePolicyRetentionPolicyIn": "_compute_918_ResourcePolicySnapshotSchedulePolicyRetentionPolicyIn",
        "ResourcePolicySnapshotSchedulePolicyRetentionPolicyOut": "_compute_919_ResourcePolicySnapshotSchedulePolicyRetentionPolicyOut",
        "OutlierDetectionIn": "_compute_920_OutlierDetectionIn",
        "OutlierDetectionOut": "_compute_921_OutlierDetectionOut",
        "PublicDelegatedPrefixAggregatedListIn": "_compute_922_PublicDelegatedPrefixAggregatedListIn",
        "PublicDelegatedPrefixAggregatedListOut": "_compute_923_PublicDelegatedPrefixAggregatedListOut",
        "NetworksRemovePeeringRequestIn": "_compute_924_NetworksRemovePeeringRequestIn",
        "NetworksRemovePeeringRequestOut": "_compute_925_NetworksRemovePeeringRequestOut",
        "SecurityPoliciesScopedListIn": "_compute_926_SecurityPoliciesScopedListIn",
        "SecurityPoliciesScopedListOut": "_compute_927_SecurityPoliciesScopedListOut",
        "NodeTypeIn": "_compute_928_NodeTypeIn",
        "NodeTypeOut": "_compute_929_NodeTypeOut",
        "PacketMirroringMirroredResourceInfoSubnetInfoIn": "_compute_930_PacketMirroringMirroredResourceInfoSubnetInfoIn",
        "PacketMirroringMirroredResourceInfoSubnetInfoOut": "_compute_931_PacketMirroringMirroredResourceInfoSubnetInfoOut",
        "BulkInsertInstanceResourcePerInstancePropertiesIn": "_compute_932_BulkInsertInstanceResourcePerInstancePropertiesIn",
        "BulkInsertInstanceResourcePerInstancePropertiesOut": "_compute_933_BulkInsertInstanceResourcePerInstancePropertiesOut",
        "AutoscalingPolicyCustomMetricUtilizationIn": "_compute_934_AutoscalingPolicyCustomMetricUtilizationIn",
        "AutoscalingPolicyCustomMetricUtilizationOut": "_compute_935_AutoscalingPolicyCustomMetricUtilizationOut",
        "HttpHeaderMatchIn": "_compute_936_HttpHeaderMatchIn",
        "HttpHeaderMatchOut": "_compute_937_HttpHeaderMatchOut",
        "BindingIn": "_compute_938_BindingIn",
        "BindingOut": "_compute_939_BindingOut",
        "RegionListIn": "_compute_940_RegionListIn",
        "RegionListOut": "_compute_941_RegionListOut",
        "NetworksGetEffectiveFirewallsResponseIn": "_compute_942_NetworksGetEffectiveFirewallsResponseIn",
        "NetworksGetEffectiveFirewallsResponseOut": "_compute_943_NetworksGetEffectiveFirewallsResponseOut",
        "SslCertificateAggregatedListIn": "_compute_944_SslCertificateAggregatedListIn",
        "SslCertificateAggregatedListOut": "_compute_945_SslCertificateAggregatedListOut",
        "HTTP2HealthCheckIn": "_compute_946_HTTP2HealthCheckIn",
        "HTTP2HealthCheckOut": "_compute_947_HTTP2HealthCheckOut",
        "DeprecationStatusIn": "_compute_948_DeprecationStatusIn",
        "DeprecationStatusOut": "_compute_949_DeprecationStatusOut",
        "SslPolicyReferenceIn": "_compute_950_SslPolicyReferenceIn",
        "SslPolicyReferenceOut": "_compute_951_SslPolicyReferenceOut",
        "InstancePropertiesIn": "_compute_952_InstancePropertiesIn",
        "InstancePropertiesOut": "_compute_953_InstancePropertiesOut",
        "LogConfigDataAccessOptionsIn": "_compute_954_LogConfigDataAccessOptionsIn",
        "LogConfigDataAccessOptionsOut": "_compute_955_LogConfigDataAccessOptionsOut",
        "NetworkAttachmentConnectedEndpointIn": "_compute_956_NetworkAttachmentConnectedEndpointIn",
        "NetworkAttachmentConnectedEndpointOut": "_compute_957_NetworkAttachmentConnectedEndpointOut",
        "NodeTypeListIn": "_compute_958_NodeTypeListIn",
        "NodeTypeListOut": "_compute_959_NodeTypeListOut",
        "DisksStopGroupAsyncReplicationResourceIn": "_compute_960_DisksStopGroupAsyncReplicationResourceIn",
        "DisksStopGroupAsyncReplicationResourceOut": "_compute_961_DisksStopGroupAsyncReplicationResourceOut",
        "InstanceTemplateAggregatedListIn": "_compute_962_InstanceTemplateAggregatedListIn",
        "InstanceTemplateAggregatedListOut": "_compute_963_InstanceTemplateAggregatedListOut",
        "MachineTypeListIn": "_compute_964_MachineTypeListIn",
        "MachineTypeListOut": "_compute_965_MachineTypeListOut",
        "SecurityPolicyRulePreconfiguredWafConfigExclusionIn": "_compute_966_SecurityPolicyRulePreconfiguredWafConfigExclusionIn",
        "SecurityPolicyRulePreconfiguredWafConfigExclusionOut": "_compute_967_SecurityPolicyRulePreconfiguredWafConfigExclusionOut",
        "RouterBgpIn": "_compute_968_RouterBgpIn",
        "RouterBgpOut": "_compute_969_RouterBgpOut",
        "LocationPolicyLocationIn": "_compute_970_LocationPolicyLocationIn",
        "LocationPolicyLocationOut": "_compute_971_LocationPolicyLocationOut",
        "RegionInstanceGroupManagersListInstanceConfigsRespIn": "_compute_972_RegionInstanceGroupManagersListInstanceConfigsRespIn",
        "RegionInstanceGroupManagersListInstanceConfigsRespOut": "_compute_973_RegionInstanceGroupManagersListInstanceConfigsRespOut",
        "CircuitBreakersIn": "_compute_974_CircuitBreakersIn",
        "CircuitBreakersOut": "_compute_975_CircuitBreakersOut",
        "ResourcePolicySnapshotSchedulePolicyIn": "_compute_976_ResourcePolicySnapshotSchedulePolicyIn",
        "ResourcePolicySnapshotSchedulePolicyOut": "_compute_977_ResourcePolicySnapshotSchedulePolicyOut",
        "HelpLinkIn": "_compute_978_HelpLinkIn",
        "HelpLinkOut": "_compute_979_HelpLinkOut",
        "AutoscalingPolicyScalingScheduleIn": "_compute_980_AutoscalingPolicyScalingScheduleIn",
        "AutoscalingPolicyScalingScheduleOut": "_compute_981_AutoscalingPolicyScalingScheduleOut",
        "SubsettingIn": "_compute_982_SubsettingIn",
        "SubsettingOut": "_compute_983_SubsettingOut",
        "RegionInstanceGroupManagersApplyUpdatesRequestIn": "_compute_984_RegionInstanceGroupManagersApplyUpdatesRequestIn",
        "RegionInstanceGroupManagersApplyUpdatesRequestOut": "_compute_985_RegionInstanceGroupManagersApplyUpdatesRequestOut",
        "AliasIpRangeIn": "_compute_986_AliasIpRangeIn",
        "AliasIpRangeOut": "_compute_987_AliasIpRangeOut",
        "StatefulPolicyPreservedStateIn": "_compute_988_StatefulPolicyPreservedStateIn",
        "StatefulPolicyPreservedStateOut": "_compute_989_StatefulPolicyPreservedStateOut",
        "ResourcePolicyWeeklyCycleIn": "_compute_990_ResourcePolicyWeeklyCycleIn",
        "ResourcePolicyWeeklyCycleOut": "_compute_991_ResourcePolicyWeeklyCycleOut",
        "PacketMirroringListIn": "_compute_992_PacketMirroringListIn",
        "PacketMirroringListOut": "_compute_993_PacketMirroringListOut",
        "HealthChecksAggregatedListIn": "_compute_994_HealthChecksAggregatedListIn",
        "HealthChecksAggregatedListOut": "_compute_995_HealthChecksAggregatedListOut",
        "ServiceAttachmentsScopedListIn": "_compute_996_ServiceAttachmentsScopedListIn",
        "ServiceAttachmentsScopedListOut": "_compute_997_ServiceAttachmentsScopedListOut",
        "NetworkEndpointGroupsListNetworkEndpointsIn": "_compute_998_NetworkEndpointGroupsListNetworkEndpointsIn",
        "NetworkEndpointGroupsListNetworkEndpointsOut": "_compute_999_NetworkEndpointGroupsListNetworkEndpointsOut",
        "InterconnectAttachmentIn": "_compute_1000_InterconnectAttachmentIn",
        "InterconnectAttachmentOut": "_compute_1001_InterconnectAttachmentOut",
        "SavedAttachedDiskIn": "_compute_1002_SavedAttachedDiskIn",
        "SavedAttachedDiskOut": "_compute_1003_SavedAttachedDiskOut",
        "FirewallPolicyListIn": "_compute_1004_FirewallPolicyListIn",
        "FirewallPolicyListOut": "_compute_1005_FirewallPolicyListOut",
        "HealthCheckLogConfigIn": "_compute_1006_HealthCheckLogConfigIn",
        "HealthCheckLogConfigOut": "_compute_1007_HealthCheckLogConfigOut",
        "DiskInstantiationConfigIn": "_compute_1008_DiskInstantiationConfigIn",
        "DiskInstantiationConfigOut": "_compute_1009_DiskInstantiationConfigOut",
        "NodeGroupAutoscalingPolicyIn": "_compute_1010_NodeGroupAutoscalingPolicyIn",
        "NodeGroupAutoscalingPolicyOut": "_compute_1011_NodeGroupAutoscalingPolicyOut",
        "InterconnectLocationListIn": "_compute_1012_InterconnectLocationListIn",
        "InterconnectLocationListOut": "_compute_1013_InterconnectLocationListOut",
        "MachineTypeAggregatedListIn": "_compute_1014_MachineTypeAggregatedListIn",
        "MachineTypeAggregatedListOut": "_compute_1015_MachineTypeAggregatedListOut",
        "AddressAggregatedListIn": "_compute_1016_AddressAggregatedListIn",
        "AddressAggregatedListOut": "_compute_1017_AddressAggregatedListOut",
        "SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigIn": "_compute_1018_SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigIn",
        "SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigOut": "_compute_1019_SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigOut",
        "AllocationSpecificSKUAllocationReservedInstancePropertiesIn": "_compute_1020_AllocationSpecificSKUAllocationReservedInstancePropertiesIn",
        "AllocationSpecificSKUAllocationReservedInstancePropertiesOut": "_compute_1021_AllocationSpecificSKUAllocationReservedInstancePropertiesOut",
        "InstanceGroupManagerActionsSummaryIn": "_compute_1022_InstanceGroupManagerActionsSummaryIn",
        "InstanceGroupManagerActionsSummaryOut": "_compute_1023_InstanceGroupManagerActionsSummaryOut",
        "VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappingsIn": "_compute_1024_VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappingsIn",
        "VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappingsOut": "_compute_1025_VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappingsOut",
        "VpnGatewayStatusHighAvailabilityRequirementStateIn": "_compute_1026_VpnGatewayStatusHighAvailabilityRequirementStateIn",
        "VpnGatewayStatusHighAvailabilityRequirementStateOut": "_compute_1027_VpnGatewayStatusHighAvailabilityRequirementStateOut",
        "ServiceAttachmentListIn": "_compute_1028_ServiceAttachmentListIn",
        "ServiceAttachmentListOut": "_compute_1029_ServiceAttachmentListOut",
        "NetworkEndpointGroupsListEndpointsRequestIn": "_compute_1030_NetworkEndpointGroupsListEndpointsRequestIn",
        "NetworkEndpointGroupsListEndpointsRequestOut": "_compute_1031_NetworkEndpointGroupsListEndpointsRequestOut",
        "ReservationsScopedListIn": "_compute_1032_ReservationsScopedListIn",
        "ReservationsScopedListOut": "_compute_1033_ReservationsScopedListOut",
        "BackendServiceConnectionTrackingPolicyIn": "_compute_1034_BackendServiceConnectionTrackingPolicyIn",
        "BackendServiceConnectionTrackingPolicyOut": "_compute_1035_BackendServiceConnectionTrackingPolicyOut",
        "UrlMapsValidateResponseIn": "_compute_1036_UrlMapsValidateResponseIn",
        "UrlMapsValidateResponseOut": "_compute_1037_UrlMapsValidateResponseOut",
        "PreconfiguredWafSetIn": "_compute_1038_PreconfiguredWafSetIn",
        "PreconfiguredWafSetOut": "_compute_1039_PreconfiguredWafSetOut",
        "LocalDiskIn": "_compute_1040_LocalDiskIn",
        "LocalDiskOut": "_compute_1041_LocalDiskOut",
        "RouterStatusNatStatusNatRuleStatusIn": "_compute_1042_RouterStatusNatStatusNatRuleStatusIn",
        "RouterStatusNatStatusNatRuleStatusOut": "_compute_1043_RouterStatusNatStatusNatRuleStatusOut",
        "DiskAsyncReplicationListIn": "_compute_1044_DiskAsyncReplicationListIn",
        "DiskAsyncReplicationListOut": "_compute_1045_DiskAsyncReplicationListOut",
        "NetworkEdgeSecurityServiceAggregatedListIn": "_compute_1046_NetworkEdgeSecurityServiceAggregatedListIn",
        "NetworkEdgeSecurityServiceAggregatedListOut": "_compute_1047_NetworkEdgeSecurityServiceAggregatedListOut",
        "InstancesScopedListIn": "_compute_1048_InstancesScopedListIn",
        "InstancesScopedListOut": "_compute_1049_InstancesScopedListOut",
        "HttpRetryPolicyIn": "_compute_1050_HttpRetryPolicyIn",
        "HttpRetryPolicyOut": "_compute_1051_HttpRetryPolicyOut",
        "ForwardingRulesScopedListIn": "_compute_1052_ForwardingRulesScopedListIn",
        "ForwardingRulesScopedListOut": "_compute_1053_ForwardingRulesScopedListOut",
        "InstanceGroupsScopedListIn": "_compute_1054_InstanceGroupsScopedListIn",
        "InstanceGroupsScopedListOut": "_compute_1055_InstanceGroupsScopedListOut",
        "AuthorizationLoggingOptionsIn": "_compute_1056_AuthorizationLoggingOptionsIn",
        "AuthorizationLoggingOptionsOut": "_compute_1057_AuthorizationLoggingOptionsOut",
        "SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsIn": "_compute_1058_SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsIn",
        "SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsOut": "_compute_1059_SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsOut",
        "AcceleratorTypeIn": "_compute_1060_AcceleratorTypeIn",
        "AcceleratorTypeOut": "_compute_1061_AcceleratorTypeOut",
        "SecurityPolicyDdosProtectionConfigIn": "_compute_1062_SecurityPolicyDdosProtectionConfigIn",
        "SecurityPolicyDdosProtectionConfigOut": "_compute_1063_SecurityPolicyDdosProtectionConfigOut",
        "AutoscalerStatusDetailsIn": "_compute_1064_AutoscalerStatusDetailsIn",
        "AutoscalerStatusDetailsOut": "_compute_1065_AutoscalerStatusDetailsOut",
        "NodeGroupsScopedListIn": "_compute_1066_NodeGroupsScopedListIn",
        "NodeGroupsScopedListOut": "_compute_1067_NodeGroupsScopedListOut",
        "VpnGatewayIn": "_compute_1068_VpnGatewayIn",
        "VpnGatewayOut": "_compute_1069_VpnGatewayOut",
        "AllocationResourceStatusSpecificSKUAllocationIn": "_compute_1070_AllocationResourceStatusSpecificSKUAllocationIn",
        "AllocationResourceStatusSpecificSKUAllocationOut": "_compute_1071_AllocationResourceStatusSpecificSKUAllocationOut",
        "AllocationSpecificSKUReservationIn": "_compute_1072_AllocationSpecificSKUReservationIn",
        "AllocationSpecificSKUReservationOut": "_compute_1073_AllocationSpecificSKUReservationOut",
        "SubnetworksSetPrivateIpGoogleAccessRequestIn": "_compute_1074_SubnetworksSetPrivateIpGoogleAccessRequestIn",
        "SubnetworksSetPrivateIpGoogleAccessRequestOut": "_compute_1075_SubnetworksSetPrivateIpGoogleAccessRequestOut",
        "UsableSubnetworkSecondaryRangeIn": "_compute_1076_UsableSubnetworkSecondaryRangeIn",
        "UsableSubnetworkSecondaryRangeOut": "_compute_1077_UsableSubnetworkSecondaryRangeOut",
        "SubnetworkLogConfigIn": "_compute_1078_SubnetworkLogConfigIn",
        "SubnetworkLogConfigOut": "_compute_1079_SubnetworkLogConfigOut",
        "HealthStatusForNetworkEndpointIn": "_compute_1080_HealthStatusForNetworkEndpointIn",
        "HealthStatusForNetworkEndpointOut": "_compute_1081_HealthStatusForNetworkEndpointOut",
        "AutoscalingPolicyScaleInControlIn": "_compute_1082_AutoscalingPolicyScaleInControlIn",
        "AutoscalingPolicyScaleInControlOut": "_compute_1083_AutoscalingPolicyScaleInControlOut",
        "InterconnectDiagnosticsIn": "_compute_1084_InterconnectDiagnosticsIn",
        "InterconnectDiagnosticsOut": "_compute_1085_InterconnectDiagnosticsOut",
        "NetworkAttachmentAggregatedListIn": "_compute_1086_NetworkAttachmentAggregatedListIn",
        "NetworkAttachmentAggregatedListOut": "_compute_1087_NetworkAttachmentAggregatedListOut",
        "HealthStatusIn": "_compute_1088_HealthStatusIn",
        "HealthStatusOut": "_compute_1089_HealthStatusOut",
        "AddressIn": "_compute_1090_AddressIn",
        "AddressOut": "_compute_1091_AddressOut",
        "ResourcePolicyWeeklyCycleDayOfWeekIn": "_compute_1092_ResourcePolicyWeeklyCycleDayOfWeekIn",
        "ResourcePolicyWeeklyCycleDayOfWeekOut": "_compute_1093_ResourcePolicyWeeklyCycleDayOfWeekOut",
        "ResourceCommitmentIn": "_compute_1094_ResourceCommitmentIn",
        "ResourceCommitmentOut": "_compute_1095_ResourceCommitmentOut",
        "AutoscalingPolicyIn": "_compute_1096_AutoscalingPolicyIn",
        "AutoscalingPolicyOut": "_compute_1097_AutoscalingPolicyOut",
        "VpnGatewayStatusIn": "_compute_1098_VpnGatewayStatusIn",
        "VpnGatewayStatusOut": "_compute_1099_VpnGatewayStatusOut",
        "ResourcePolicyGroupPlacementPolicyIn": "_compute_1100_ResourcePolicyGroupPlacementPolicyIn",
        "ResourcePolicyGroupPlacementPolicyOut": "_compute_1101_ResourcePolicyGroupPlacementPolicyOut",
        "SecurityPoliciesWafConfigIn": "_compute_1102_SecurityPoliciesWafConfigIn",
        "SecurityPoliciesWafConfigOut": "_compute_1103_SecurityPoliciesWafConfigOut",
        "ScalingScheduleStatusIn": "_compute_1104_ScalingScheduleStatusIn",
        "ScalingScheduleStatusOut": "_compute_1105_ScalingScheduleStatusOut",
        "RoutersScopedListIn": "_compute_1106_RoutersScopedListIn",
        "RoutersScopedListOut": "_compute_1107_RoutersScopedListOut",
        "BackendServiceFailoverPolicyIn": "_compute_1108_BackendServiceFailoverPolicyIn",
        "BackendServiceFailoverPolicyOut": "_compute_1109_BackendServiceFailoverPolicyOut",
        "RegionAutoscalerListIn": "_compute_1110_RegionAutoscalerListIn",
        "RegionAutoscalerListOut": "_compute_1111_RegionAutoscalerListOut",
        "InterconnectRemoteLocationIn": "_compute_1112_InterconnectRemoteLocationIn",
        "InterconnectRemoteLocationOut": "_compute_1113_InterconnectRemoteLocationOut",
        "HttpRouteRuleIn": "_compute_1114_HttpRouteRuleIn",
        "HttpRouteRuleOut": "_compute_1115_HttpRouteRuleOut",
        "ExternalVpnGatewayInterfaceIn": "_compute_1116_ExternalVpnGatewayInterfaceIn",
        "ExternalVpnGatewayInterfaceOut": "_compute_1117_ExternalVpnGatewayInterfaceOut",
        "NetworkEndpointGroupListIn": "_compute_1118_NetworkEndpointGroupListIn",
        "NetworkEndpointGroupListOut": "_compute_1119_NetworkEndpointGroupListOut",
        "UrlMapIn": "_compute_1120_UrlMapIn",
        "UrlMapOut": "_compute_1121_UrlMapOut",
        "DiskMoveRequestIn": "_compute_1122_DiskMoveRequestIn",
        "DiskMoveRequestOut": "_compute_1123_DiskMoveRequestOut",
        "NetworkIn": "_compute_1124_NetworkIn",
        "NetworkOut": "_compute_1125_NetworkOut",
        "OperationsScopedListIn": "_compute_1126_OperationsScopedListIn",
        "OperationsScopedListOut": "_compute_1127_OperationsScopedListOut",
        "DisksScopedListIn": "_compute_1128_DisksScopedListIn",
        "DisksScopedListOut": "_compute_1129_DisksScopedListOut",
        "InterconnectAttachmentPrivateInfoIn": "_compute_1130_InterconnectAttachmentPrivateInfoIn",
        "InterconnectAttachmentPrivateInfoOut": "_compute_1131_InterconnectAttachmentPrivateInfoOut",
        "NetworksAddPeeringRequestIn": "_compute_1132_NetworksAddPeeringRequestIn",
        "NetworksAddPeeringRequestOut": "_compute_1133_NetworksAddPeeringRequestOut",
        "RequestMirrorPolicyIn": "_compute_1134_RequestMirrorPolicyIn",
        "RequestMirrorPolicyOut": "_compute_1135_RequestMirrorPolicyOut",
        "InstanceManagedByIgmErrorManagedInstanceErrorIn": "_compute_1136_InstanceManagedByIgmErrorManagedInstanceErrorIn",
        "InstanceManagedByIgmErrorManagedInstanceErrorOut": "_compute_1137_InstanceManagedByIgmErrorManagedInstanceErrorOut",
        "RegionInstanceGroupManagerDeleteInstanceConfigReqIn": "_compute_1138_RegionInstanceGroupManagerDeleteInstanceConfigReqIn",
        "RegionInstanceGroupManagerDeleteInstanceConfigReqOut": "_compute_1139_RegionInstanceGroupManagerDeleteInstanceConfigReqOut",
        "ShareSettingsIn": "_compute_1140_ShareSettingsIn",
        "ShareSettingsOut": "_compute_1141_ShareSettingsOut",
        "RegionInstanceGroupManagerListIn": "_compute_1142_RegionInstanceGroupManagerListIn",
        "RegionInstanceGroupManagerListOut": "_compute_1143_RegionInstanceGroupManagerListOut",
        "PublicAdvertisedPrefixIn": "_compute_1144_PublicAdvertisedPrefixIn",
        "PublicAdvertisedPrefixOut": "_compute_1145_PublicAdvertisedPrefixOut",
        "BackendServiceAggregatedListIn": "_compute_1146_BackendServiceAggregatedListIn",
        "BackendServiceAggregatedListOut": "_compute_1147_BackendServiceAggregatedListOut",
        "RegionInstanceGroupManagersSetTemplateRequestIn": "_compute_1148_RegionInstanceGroupManagersSetTemplateRequestIn",
        "RegionInstanceGroupManagersSetTemplateRequestOut": "_compute_1149_RegionInstanceGroupManagersSetTemplateRequestOut",
        "RegionSetPolicyRequestIn": "_compute_1150_RegionSetPolicyRequestIn",
        "RegionSetPolicyRequestOut": "_compute_1151_RegionSetPolicyRequestOut",
        "VpnTunnelListIn": "_compute_1152_VpnTunnelListIn",
        "VpnTunnelListOut": "_compute_1153_VpnTunnelListOut",
        "BackendServiceListIn": "_compute_1154_BackendServiceListIn",
        "BackendServiceListOut": "_compute_1155_BackendServiceListOut",
        "InstanceTemplatesScopedListIn": "_compute_1156_InstanceTemplatesScopedListIn",
        "InstanceTemplatesScopedListOut": "_compute_1157_InstanceTemplatesScopedListOut",
        "RouteIn": "_compute_1158_RouteIn",
        "RouteOut": "_compute_1159_RouteOut",
        "ManagedInstanceInstanceHealthIn": "_compute_1160_ManagedInstanceInstanceHealthIn",
        "ManagedInstanceInstanceHealthOut": "_compute_1161_ManagedInstanceInstanceHealthOut",
        "InterconnectLocationIn": "_compute_1162_InterconnectLocationIn",
        "InterconnectLocationOut": "_compute_1163_InterconnectLocationOut",
        "LogConfigIn": "_compute_1164_LogConfigIn",
        "LogConfigOut": "_compute_1165_LogConfigOut",
        "SubnetworkIn": "_compute_1166_SubnetworkIn",
        "SubnetworkOut": "_compute_1167_SubnetworkOut",
        "TargetPoolAggregatedListIn": "_compute_1168_TargetPoolAggregatedListIn",
        "TargetPoolAggregatedListOut": "_compute_1169_TargetPoolAggregatedListOut",
        "InstanceGroupsAddInstancesRequestIn": "_compute_1170_InstanceGroupsAddInstancesRequestIn",
        "InstanceGroupsAddInstancesRequestOut": "_compute_1171_InstanceGroupsAddInstancesRequestOut",
        "InstanceGroupIn": "_compute_1172_InstanceGroupIn",
        "InstanceGroupOut": "_compute_1173_InstanceGroupOut",
        "FirewallPolicyRuleSecureTagIn": "_compute_1174_FirewallPolicyRuleSecureTagIn",
        "FirewallPolicyRuleSecureTagOut": "_compute_1175_FirewallPolicyRuleSecureTagOut",
        "SnapshotListIn": "_compute_1176_SnapshotListIn",
        "SnapshotListOut": "_compute_1177_SnapshotListOut",
        "GlobalSetLabelsRequestIn": "_compute_1178_GlobalSetLabelsRequestIn",
        "GlobalSetLabelsRequestOut": "_compute_1179_GlobalSetLabelsRequestOut",
        "RegionAddressesMoveRequestIn": "_compute_1180_RegionAddressesMoveRequestIn",
        "RegionAddressesMoveRequestOut": "_compute_1181_RegionAddressesMoveRequestOut",
        "InstanceGroupManagersListManagedInstancesResponseIn": "_compute_1182_InstanceGroupManagersListManagedInstancesResponseIn",
        "InstanceGroupManagersListManagedInstancesResponseOut": "_compute_1183_InstanceGroupManagersListManagedInstancesResponseOut",
        "InstanceGroupManagersPatchPerInstanceConfigsReqIn": "_compute_1184_InstanceGroupManagersPatchPerInstanceConfigsReqIn",
        "InstanceGroupManagersPatchPerInstanceConfigsReqOut": "_compute_1185_InstanceGroupManagersPatchPerInstanceConfigsReqOut",
        "NetworkAttachmentListIn": "_compute_1186_NetworkAttachmentListIn",
        "NetworkAttachmentListOut": "_compute_1187_NetworkAttachmentListOut",
        "NodeGroupsSetNodeTemplateRequestIn": "_compute_1188_NodeGroupsSetNodeTemplateRequestIn",
        "NodeGroupsSetNodeTemplateRequestOut": "_compute_1189_NodeGroupsSetNodeTemplateRequestOut",
        "NetworkInterfaceIn": "_compute_1190_NetworkInterfaceIn",
        "NetworkInterfaceOut": "_compute_1191_NetworkInterfaceOut",
        "TargetHttpsProxyIn": "_compute_1192_TargetHttpsProxyIn",
        "TargetHttpsProxyOut": "_compute_1193_TargetHttpsProxyOut",
        "HttpFaultDelayIn": "_compute_1194_HttpFaultDelayIn",
        "HttpFaultDelayOut": "_compute_1195_HttpFaultDelayOut",
        "BackendServiceLocalityLoadBalancingPolicyConfigIn": "_compute_1196_BackendServiceLocalityLoadBalancingPolicyConfigIn",
        "BackendServiceLocalityLoadBalancingPolicyConfigOut": "_compute_1197_BackendServiceLocalityLoadBalancingPolicyConfigOut",
        "RouteAsPathIn": "_compute_1198_RouteAsPathIn",
        "RouteAsPathOut": "_compute_1199_RouteAsPathOut",
        "ReservationListIn": "_compute_1200_ReservationListIn",
        "ReservationListOut": "_compute_1201_ReservationListOut",
        "UrlMapsValidateRequestIn": "_compute_1202_UrlMapsValidateRequestIn",
        "UrlMapsValidateRequestOut": "_compute_1203_UrlMapsValidateRequestOut",
        "NodeTemplateIn": "_compute_1204_NodeTemplateIn",
        "NodeTemplateOut": "_compute_1205_NodeTemplateOut",
        "TargetHttpsProxyListIn": "_compute_1206_TargetHttpsProxyListIn",
        "TargetHttpsProxyListOut": "_compute_1207_TargetHttpsProxyListOut",
        "PacketIntervalsIn": "_compute_1208_PacketIntervalsIn",
        "PacketIntervalsOut": "_compute_1209_PacketIntervalsOut",
        "InstanceGroupManagersSetTargetPoolsRequestIn": "_compute_1210_InstanceGroupManagersSetTargetPoolsRequestIn",
        "InstanceGroupManagersSetTargetPoolsRequestOut": "_compute_1211_InstanceGroupManagersSetTargetPoolsRequestOut",
        "SubnetworksScopedListIn": "_compute_1212_SubnetworksScopedListIn",
        "SubnetworksScopedListOut": "_compute_1213_SubnetworksScopedListOut",
        "ServiceAttachmentConnectedEndpointIn": "_compute_1214_ServiceAttachmentConnectedEndpointIn",
        "ServiceAttachmentConnectedEndpointOut": "_compute_1215_ServiceAttachmentConnectedEndpointOut",
        "PathMatcherIn": "_compute_1216_PathMatcherIn",
        "PathMatcherOut": "_compute_1217_PathMatcherOut",
        "UrlMapTestIn": "_compute_1218_UrlMapTestIn",
        "UrlMapTestOut": "_compute_1219_UrlMapTestOut",
        "NetworkAttachmentIn": "_compute_1220_NetworkAttachmentIn",
        "NetworkAttachmentOut": "_compute_1221_NetworkAttachmentOut",
        "NetworkEndpointGroupsDetachEndpointsRequestIn": "_compute_1222_NetworkEndpointGroupsDetachEndpointsRequestIn",
        "NetworkEndpointGroupsDetachEndpointsRequestOut": "_compute_1223_NetworkEndpointGroupsDetachEndpointsRequestOut",
        "RouterInterfaceIn": "_compute_1224_RouterInterfaceIn",
        "RouterInterfaceOut": "_compute_1225_RouterInterfaceOut",
        "ForwardingRuleServiceDirectoryRegistrationIn": "_compute_1226_ForwardingRuleServiceDirectoryRegistrationIn",
        "ForwardingRuleServiceDirectoryRegistrationOut": "_compute_1227_ForwardingRuleServiceDirectoryRegistrationOut",
        "PublicDelegatedPrefixesScopedListIn": "_compute_1228_PublicDelegatedPrefixesScopedListIn",
        "PublicDelegatedPrefixesScopedListOut": "_compute_1229_PublicDelegatedPrefixesScopedListOut",
        "InstanceIn": "_compute_1230_InstanceIn",
        "InstanceOut": "_compute_1231_InstanceOut",
        "BackendBucketCdnPolicyCacheKeyPolicyIn": "_compute_1232_BackendBucketCdnPolicyCacheKeyPolicyIn",
        "BackendBucketCdnPolicyCacheKeyPolicyOut": "_compute_1233_BackendBucketCdnPolicyCacheKeyPolicyOut",
        "CommitmentAggregatedListIn": "_compute_1234_CommitmentAggregatedListIn",
        "CommitmentAggregatedListOut": "_compute_1235_CommitmentAggregatedListOut",
        "SslCertificateSelfManagedSslCertificateIn": "_compute_1236_SslCertificateSelfManagedSslCertificateIn",
        "SslCertificateSelfManagedSslCertificateOut": "_compute_1237_SslCertificateSelfManagedSslCertificateOut",
        "NetworkEndpointGroupCloudRunIn": "_compute_1238_NetworkEndpointGroupCloudRunIn",
        "NetworkEndpointGroupCloudRunOut": "_compute_1239_NetworkEndpointGroupCloudRunOut",
        "TestPermissionsRequestIn": "_compute_1240_TestPermissionsRequestIn",
        "TestPermissionsRequestOut": "_compute_1241_TestPermissionsRequestOut",
        "InstanceGroupManagerAutoHealingPolicyIn": "_compute_1242_InstanceGroupManagerAutoHealingPolicyIn",
        "InstanceGroupManagerAutoHealingPolicyOut": "_compute_1243_InstanceGroupManagerAutoHealingPolicyOut",
        "SecurityPolicyListIn": "_compute_1244_SecurityPolicyListIn",
        "SecurityPolicyListOut": "_compute_1245_SecurityPolicyListOut",
        "SecurityPoliciesListPreconfiguredExpressionSetsResponseIn": "_compute_1246_SecurityPoliciesListPreconfiguredExpressionSetsResponseIn",
        "SecurityPoliciesListPreconfiguredExpressionSetsResponseOut": "_compute_1247_SecurityPoliciesListPreconfiguredExpressionSetsResponseOut",
        "CacheInvalidationRuleIn": "_compute_1248_CacheInvalidationRuleIn",
        "CacheInvalidationRuleOut": "_compute_1249_CacheInvalidationRuleOut",
        "UrlMapValidationResultIn": "_compute_1250_UrlMapValidationResultIn",
        "UrlMapValidationResultOut": "_compute_1251_UrlMapValidationResultOut",
        "TestFailureIn": "_compute_1252_TestFailureIn",
        "TestFailureOut": "_compute_1253_TestFailureOut",
        "ExternalVpnGatewayListIn": "_compute_1254_ExternalVpnGatewayListIn",
        "ExternalVpnGatewayListOut": "_compute_1255_ExternalVpnGatewayListOut",
        "VpnGatewayListIn": "_compute_1256_VpnGatewayListIn",
        "VpnGatewayListOut": "_compute_1257_VpnGatewayListOut",
        "InstanceListIn": "_compute_1258_InstanceListIn",
        "InstanceListOut": "_compute_1259_InstanceListOut",
        "RegionTargetHttpsProxiesSetSslCertificatesRequestIn": "_compute_1260_RegionTargetHttpsProxiesSetSslCertificatesRequestIn",
        "RegionTargetHttpsProxiesSetSslCertificatesRequestOut": "_compute_1261_RegionTargetHttpsProxiesSetSslCertificatesRequestOut",
        "InstanceTemplateListIn": "_compute_1262_InstanceTemplateListIn",
        "InstanceTemplateListOut": "_compute_1263_InstanceTemplateListOut",
        "ConfidentialInstanceConfigIn": "_compute_1264_ConfidentialInstanceConfigIn",
        "ConfidentialInstanceConfigOut": "_compute_1265_ConfidentialInstanceConfigOut",
        "HealthChecksScopedListIn": "_compute_1266_HealthChecksScopedListIn",
        "HealthChecksScopedListOut": "_compute_1267_HealthChecksScopedListOut",
        "TargetTcpProxiesSetBackendServiceRequestIn": "_compute_1268_TargetTcpProxiesSetBackendServiceRequestIn",
        "TargetTcpProxiesSetBackendServiceRequestOut": "_compute_1269_TargetTcpProxiesSetBackendServiceRequestOut",
        "InterconnectDiagnosticsARPEntryIn": "_compute_1270_InterconnectDiagnosticsARPEntryIn",
        "InterconnectDiagnosticsARPEntryOut": "_compute_1271_InterconnectDiagnosticsARPEntryOut",
        "RegionDisksStartAsyncReplicationRequestIn": "_compute_1272_RegionDisksStartAsyncReplicationRequestIn",
        "RegionDisksStartAsyncReplicationRequestOut": "_compute_1273_RegionDisksStartAsyncReplicationRequestOut",
        "TargetInstancesScopedListIn": "_compute_1274_TargetInstancesScopedListIn",
        "TargetInstancesScopedListOut": "_compute_1275_TargetInstancesScopedListOut",
        "InstanceGroupManagersAbandonInstancesRequestIn": "_compute_1276_InstanceGroupManagersAbandonInstancesRequestIn",
        "InstanceGroupManagersAbandonInstancesRequestOut": "_compute_1277_InstanceGroupManagersAbandonInstancesRequestOut",
        "ResourceStatusIn": "_compute_1278_ResourceStatusIn",
        "ResourceStatusOut": "_compute_1279_ResourceStatusOut",
        "ConsistentHashLoadBalancerSettingsHttpCookieIn": "_compute_1280_ConsistentHashLoadBalancerSettingsHttpCookieIn",
        "ConsistentHashLoadBalancerSettingsHttpCookieOut": "_compute_1281_ConsistentHashLoadBalancerSettingsHttpCookieOut",
        "InstanceGroupsListInstancesRequestIn": "_compute_1282_InstanceGroupsListInstancesRequestIn",
        "InstanceGroupsListInstancesRequestOut": "_compute_1283_InstanceGroupsListInstancesRequestOut",
        "LocationPolicyLocationConstraintsIn": "_compute_1284_LocationPolicyLocationConstraintsIn",
        "LocationPolicyLocationConstraintsOut": "_compute_1285_LocationPolicyLocationConstraintsOut",
        "CorsPolicyIn": "_compute_1286_CorsPolicyIn",
        "CorsPolicyOut": "_compute_1287_CorsPolicyOut",
        "ResourceGroupReferenceIn": "_compute_1288_ResourceGroupReferenceIn",
        "ResourceGroupReferenceOut": "_compute_1289_ResourceGroupReferenceOut",
        "SchedulingIn": "_compute_1290_SchedulingIn",
        "SchedulingOut": "_compute_1291_SchedulingOut",
        "TestPermissionsResponseIn": "_compute_1292_TestPermissionsResponseIn",
        "TestPermissionsResponseOut": "_compute_1293_TestPermissionsResponseOut",
        "TargetTcpProxyAggregatedListIn": "_compute_1294_TargetTcpProxyAggregatedListIn",
        "TargetTcpProxyAggregatedListOut": "_compute_1295_TargetTcpProxyAggregatedListOut",
        "SavedDiskIn": "_compute_1296_SavedDiskIn",
        "SavedDiskOut": "_compute_1297_SavedDiskOut",
        "HttpHealthCheckListIn": "_compute_1298_HttpHealthCheckListIn",
        "HttpHealthCheckListOut": "_compute_1299_HttpHealthCheckListOut",
        "NetworkEdgeSecurityServiceIn": "_compute_1300_NetworkEdgeSecurityServiceIn",
        "NetworkEdgeSecurityServiceOut": "_compute_1301_NetworkEdgeSecurityServiceOut",
        "RouterStatusBgpPeerStatusIn": "_compute_1302_RouterStatusBgpPeerStatusIn",
        "RouterStatusBgpPeerStatusOut": "_compute_1303_RouterStatusBgpPeerStatusOut",
    }

    types = {}
    types["ErrorResponse"] = t.struct(
        {"code": t.integer(), "message": t.string(), "status": t.string()}
    ).named(renames["ErrorResponse"])
    types["DiskAsyncReplicationIn"] = t.struct(
        {
            "diskId": t.string().optional(),
            "consistencyGroupPolicyId": t.string().optional(),
            "consistencyGroupPolicy": t.string().optional(),
            "disk": t.string().optional(),
        }
    ).named(renames["DiskAsyncReplicationIn"])
    types["DiskAsyncReplicationOut"] = t.struct(
        {
            "diskId": t.string().optional(),
            "consistencyGroupPolicyId": t.string().optional(),
            "consistencyGroupPolicy": t.string().optional(),
            "disk": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DiskAsyncReplicationOut"])
    types["DisksAddResourcePoliciesRequestIn"] = t.struct(
        {"resourcePolicies": t.array(t.string()).optional()}
    ).named(renames["DisksAddResourcePoliciesRequestIn"])
    types["DisksAddResourcePoliciesRequestOut"] = t.struct(
        {
            "resourcePolicies": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DisksAddResourcePoliciesRequestOut"])
    types["LogConfigCloudAuditOptionsIn"] = t.struct(
        {
            "logName": t.string().optional(),
            "authorizationLoggingOptions": t.proxy(
                renames["AuthorizationLoggingOptionsIn"]
            ).optional(),
        }
    ).named(renames["LogConfigCloudAuditOptionsIn"])
    types["LogConfigCloudAuditOptionsOut"] = t.struct(
        {
            "logName": t.string().optional(),
            "authorizationLoggingOptions": t.proxy(
                renames["AuthorizationLoggingOptionsOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LogConfigCloudAuditOptionsOut"])
    types["GlobalOrganizationSetPolicyRequestIn"] = t.struct(
        {
            "policy": t.proxy(renames["PolicyIn"]).optional(),
            "bindings": t.array(t.proxy(renames["BindingIn"])).optional(),
            "etag": t.string().optional(),
        }
    ).named(renames["GlobalOrganizationSetPolicyRequestIn"])
    types["GlobalOrganizationSetPolicyRequestOut"] = t.struct(
        {
            "policy": t.proxy(renames["PolicyOut"]).optional(),
            "bindings": t.array(t.proxy(renames["BindingOut"])).optional(),
            "etag": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["GlobalOrganizationSetPolicyRequestOut"])
    types["PublicAdvertisedPrefixPublicDelegatedPrefixIn"] = t.struct(
        {
            "region": t.string().optional(),
            "project": t.string().optional(),
            "name": t.string().optional(),
            "ipRange": t.string().optional(),
            "status": t.string().optional(),
        }
    ).named(renames["PublicAdvertisedPrefixPublicDelegatedPrefixIn"])
    types["PublicAdvertisedPrefixPublicDelegatedPrefixOut"] = t.struct(
        {
            "region": t.string().optional(),
            "project": t.string().optional(),
            "name": t.string().optional(),
            "ipRange": t.string().optional(),
            "status": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PublicAdvertisedPrefixPublicDelegatedPrefixOut"])
    types["ServiceAttachmentIn"] = t.struct(
        {
            "description": t.string().optional(),
            "producerForwardingRule": t.string().optional(),
            "consumerRejectLists": t.array(t.string()).optional(),
            "domainNames": t.array(t.string()).optional(),
            "fingerprint": t.string().optional(),
            "connectionPreference": t.string().optional(),
            "natSubnets": t.array(t.string()).optional(),
            "connectedEndpoints": t.array(
                t.proxy(renames["ServiceAttachmentConnectedEndpointIn"])
            ).optional(),
            "reconcileConnections": t.boolean().optional(),
            "id": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "enableProxyProtocol": t.boolean().optional(),
            "consumerAcceptLists": t.array(
                t.proxy(renames["ServiceAttachmentConsumerProjectLimitIn"])
            ).optional(),
            "name": t.string().optional(),
            "kind": t.string().optional(),
            "region": t.string().optional(),
            "targetService": t.string().optional(),
            "selfLink": t.string().optional(),
            "pscServiceAttachmentId": t.proxy(renames["Uint128In"]).optional(),
        }
    ).named(renames["ServiceAttachmentIn"])
    types["ServiceAttachmentOut"] = t.struct(
        {
            "description": t.string().optional(),
            "producerForwardingRule": t.string().optional(),
            "consumerRejectLists": t.array(t.string()).optional(),
            "domainNames": t.array(t.string()).optional(),
            "fingerprint": t.string().optional(),
            "connectionPreference": t.string().optional(),
            "natSubnets": t.array(t.string()).optional(),
            "connectedEndpoints": t.array(
                t.proxy(renames["ServiceAttachmentConnectedEndpointOut"])
            ).optional(),
            "reconcileConnections": t.boolean().optional(),
            "id": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "enableProxyProtocol": t.boolean().optional(),
            "consumerAcceptLists": t.array(
                t.proxy(renames["ServiceAttachmentConsumerProjectLimitOut"])
            ).optional(),
            "name": t.string().optional(),
            "kind": t.string().optional(),
            "region": t.string().optional(),
            "targetService": t.string().optional(),
            "selfLink": t.string().optional(),
            "pscServiceAttachmentId": t.proxy(renames["Uint128Out"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ServiceAttachmentOut"])
    types["BackendServiceCdnPolicyBypassCacheOnRequestHeaderIn"] = t.struct(
        {"headerName": t.string().optional()}
    ).named(renames["BackendServiceCdnPolicyBypassCacheOnRequestHeaderIn"])
    types["BackendServiceCdnPolicyBypassCacheOnRequestHeaderOut"] = t.struct(
        {
            "headerName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceCdnPolicyBypassCacheOnRequestHeaderOut"])
    types["VpnGatewaysGetStatusResponseIn"] = t.struct(
        {"result": t.proxy(renames["VpnGatewayStatusIn"])}
    ).named(renames["VpnGatewaysGetStatusResponseIn"])
    types["VpnGatewaysGetStatusResponseOut"] = t.struct(
        {
            "result": t.proxy(renames["VpnGatewayStatusOut"]),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnGatewaysGetStatusResponseOut"])
    types["PacketMirroringMirroredResourceInfoIn"] = t.struct(
        {
            "instances": t.array(
                t.proxy(renames["PacketMirroringMirroredResourceInfoInstanceInfoIn"])
            ).optional(),
            "tags": t.array(t.string()).optional(),
            "subnetworks": t.array(
                t.proxy(renames["PacketMirroringMirroredResourceInfoSubnetInfoIn"])
            ).optional(),
        }
    ).named(renames["PacketMirroringMirroredResourceInfoIn"])
    types["PacketMirroringMirroredResourceInfoOut"] = t.struct(
        {
            "instances": t.array(
                t.proxy(renames["PacketMirroringMirroredResourceInfoInstanceInfoOut"])
            ).optional(),
            "tags": t.array(t.string()).optional(),
            "subnetworks": t.array(
                t.proxy(renames["PacketMirroringMirroredResourceInfoSubnetInfoOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PacketMirroringMirroredResourceInfoOut"])
    types["DiskAggregatedListIn"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["DiskAggregatedListIn"])
    types["DiskAggregatedListOut"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DiskAggregatedListOut"])
    types["FirewallLogConfigIn"] = t.struct(
        {"metadata": t.string().optional(), "enable": t.boolean().optional()}
    ).named(renames["FirewallLogConfigIn"])
    types["FirewallLogConfigOut"] = t.struct(
        {
            "metadata": t.string().optional(),
            "enable": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["FirewallLogConfigOut"])
    types["DiskTypeListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["DiskTypeIn"])).optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["DiskTypeListIn"])
    types["DiskTypeListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["DiskTypeOut"])).optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DiskTypeListOut"])
    types["BfdPacketIn"] = t.struct(
        {
            "length": t.integer().optional(),
            "minRxIntervalMs": t.integer().optional(),
            "poll": t.boolean().optional(),
            "minEchoRxIntervalMs": t.integer().optional(),
            "controlPlaneIndependent": t.boolean().optional(),
            "myDiscriminator": t.integer().optional(),
            "multiplier": t.integer().optional(),
            "demand": t.boolean().optional(),
            "state": t.string().optional(),
            "authenticationPresent": t.boolean().optional(),
            "minTxIntervalMs": t.integer().optional(),
            "yourDiscriminator": t.integer().optional(),
            "multipoint": t.boolean().optional(),
            "version": t.integer().optional(),
            "diagnostic": t.string().optional(),
            "final": t.boolean().optional(),
        }
    ).named(renames["BfdPacketIn"])
    types["BfdPacketOut"] = t.struct(
        {
            "length": t.integer().optional(),
            "minRxIntervalMs": t.integer().optional(),
            "poll": t.boolean().optional(),
            "minEchoRxIntervalMs": t.integer().optional(),
            "controlPlaneIndependent": t.boolean().optional(),
            "myDiscriminator": t.integer().optional(),
            "multiplier": t.integer().optional(),
            "demand": t.boolean().optional(),
            "state": t.string().optional(),
            "authenticationPresent": t.boolean().optional(),
            "minTxIntervalMs": t.integer().optional(),
            "yourDiscriminator": t.integer().optional(),
            "multipoint": t.boolean().optional(),
            "version": t.integer().optional(),
            "diagnostic": t.string().optional(),
            "final": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BfdPacketOut"])
    types["ResourcePolicySnapshotSchedulePolicySnapshotPropertiesIn"] = t.struct(
        {
            "chainName": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "guestFlush": t.boolean().optional(),
            "storageLocations": t.array(t.string()).optional(),
        }
    ).named(renames["ResourcePolicySnapshotSchedulePolicySnapshotPropertiesIn"])
    types["ResourcePolicySnapshotSchedulePolicySnapshotPropertiesOut"] = t.struct(
        {
            "chainName": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "guestFlush": t.boolean().optional(),
            "storageLocations": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicySnapshotSchedulePolicySnapshotPropertiesOut"])
    types["DiskParamsIn"] = t.struct(
        {"resourceManagerTags": t.struct({"_": t.string().optional()}).optional()}
    ).named(renames["DiskParamsIn"])
    types["DiskParamsOut"] = t.struct(
        {
            "resourceManagerTags": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DiskParamsOut"])
    types["RegionDiskTypeListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["DiskTypeIn"])).optional(),
        }
    ).named(renames["RegionDiskTypeListIn"])
    types["RegionDiskTypeListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["DiskTypeOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionDiskTypeListOut"])
    types["NodeGroupMaintenanceWindowIn"] = t.struct(
        {
            "startTime": t.string().optional(),
            "maintenanceDuration": t.proxy(renames["DurationIn"]).optional(),
        }
    ).named(renames["NodeGroupMaintenanceWindowIn"])
    types["NodeGroupMaintenanceWindowOut"] = t.struct(
        {
            "startTime": t.string().optional(),
            "maintenanceDuration": t.proxy(renames["DurationOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeGroupMaintenanceWindowOut"])
    types["DisksStartAsyncReplicationRequestIn"] = t.struct(
        {"asyncSecondaryDisk": t.string().optional()}
    ).named(renames["DisksStartAsyncReplicationRequestIn"])
    types["DisksStartAsyncReplicationRequestOut"] = t.struct(
        {
            "asyncSecondaryDisk": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DisksStartAsyncReplicationRequestOut"])
    types["TargetHttpProxyListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["TargetHttpProxyIn"])).optional(),
        }
    ).named(renames["TargetHttpProxyListIn"])
    types["TargetHttpProxyListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["TargetHttpProxyOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetHttpProxyListOut"])
    types["TargetHttpsProxiesSetCertificateMapRequestIn"] = t.struct(
        {"certificateMap": t.string().optional()}
    ).named(renames["TargetHttpsProxiesSetCertificateMapRequestIn"])
    types["TargetHttpsProxiesSetCertificateMapRequestOut"] = t.struct(
        {
            "certificateMap": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetHttpsProxiesSetCertificateMapRequestOut"])
    types["LocationPolicyIn"] = t.struct(
        {
            "targetShape": t.string().optional(),
            "locations": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["LocationPolicyIn"])
    types["LocationPolicyOut"] = t.struct(
        {
            "targetShape": t.string().optional(),
            "locations": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LocationPolicyOut"])
    types["InstanceWithNamedPortsIn"] = t.struct(
        {
            "namedPorts": t.array(t.proxy(renames["NamedPortIn"])).optional(),
            "status": t.string().optional(),
            "instance": t.string().optional(),
        }
    ).named(renames["InstanceWithNamedPortsIn"])
    types["InstanceWithNamedPortsOut"] = t.struct(
        {
            "namedPorts": t.array(t.proxy(renames["NamedPortOut"])).optional(),
            "status": t.string().optional(),
            "instance": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceWithNamedPortsOut"])
    types["InterconnectAttachmentConfigurationConstraintsBgpPeerASNRangeIn"] = t.struct(
        {"min": t.integer(), "max": t.integer()}
    ).named(renames["InterconnectAttachmentConfigurationConstraintsBgpPeerASNRangeIn"])
    types[
        "InterconnectAttachmentConfigurationConstraintsBgpPeerASNRangeOut"
    ] = t.struct(
        {
            "min": t.integer(),
            "max": t.integer(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(
        renames["InterconnectAttachmentConfigurationConstraintsBgpPeerASNRangeOut"]
    )
    types["InstancesGetEffectiveFirewallsResponseIn"] = t.struct(
        {
            "firewalls": t.array(t.proxy(renames["FirewallIn"])).optional(),
            "firewallPolicys": t.array(
                t.proxy(
                    renames[
                        "InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn"
                    ]
                )
            ).optional(),
        }
    ).named(renames["InstancesGetEffectiveFirewallsResponseIn"])
    types["InstancesGetEffectiveFirewallsResponseOut"] = t.struct(
        {
            "firewalls": t.array(t.proxy(renames["FirewallOut"])).optional(),
            "firewallPolicys": t.array(
                t.proxy(
                    renames[
                        "InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut"
                    ]
                )
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstancesGetEffectiveFirewallsResponseOut"])
    types["SignedUrlKeyIn"] = t.struct(
        {"keyValue": t.string().optional(), "keyName": t.string().optional()}
    ).named(renames["SignedUrlKeyIn"])
    types["SignedUrlKeyOut"] = t.struct(
        {
            "keyValue": t.string().optional(),
            "keyName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SignedUrlKeyOut"])
    types["NodeGroupsDeleteNodesRequestIn"] = t.struct(
        {"nodes": t.array(t.string()).optional()}
    ).named(renames["NodeGroupsDeleteNodesRequestIn"])
    types["NodeGroupsDeleteNodesRequestOut"] = t.struct(
        {
            "nodes": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeGroupsDeleteNodesRequestOut"])
    types["RouterListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["RouterIn"])).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["RouterListIn"])
    types["RouterListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["RouterOut"])).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterListOut"])
    types["TargetVpnGatewayAggregatedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["TargetVpnGatewayAggregatedListIn"])
    types["TargetVpnGatewayAggregatedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetVpnGatewayAggregatedListOut"])
    types["InstanceGroupManagersListPerInstanceConfigsRespIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["PerInstanceConfigIn"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["InstanceGroupManagersListPerInstanceConfigsRespIn"])
    types["InstanceGroupManagersListPerInstanceConfigsRespOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["PerInstanceConfigOut"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersListPerInstanceConfigsRespOut"])
    types["DiskResourceStatusAsyncReplicationStatusIn"] = t.struct(
        {"state": t.string()}
    ).named(renames["DiskResourceStatusAsyncReplicationStatusIn"])
    types["DiskResourceStatusAsyncReplicationStatusOut"] = t.struct(
        {"state": t.string(), "error": t.proxy(renames["ErrorResponse"]).optional()}
    ).named(renames["DiskResourceStatusAsyncReplicationStatusOut"])
    types["HttpRouteRuleMatchIn"] = t.struct(
        {
            "metadataFilters": t.array(t.proxy(renames["MetadataFilterIn"])).optional(),
            "prefixMatch": t.string().optional(),
            "queryParameterMatches": t.array(
                t.proxy(renames["HttpQueryParameterMatchIn"])
            ).optional(),
            "ignoreCase": t.boolean().optional(),
            "regexMatch": t.string().optional(),
            "fullPathMatch": t.string().optional(),
            "headerMatches": t.array(t.proxy(renames["HttpHeaderMatchIn"])).optional(),
            "pathTemplateMatch": t.string().optional(),
        }
    ).named(renames["HttpRouteRuleMatchIn"])
    types["HttpRouteRuleMatchOut"] = t.struct(
        {
            "metadataFilters": t.array(
                t.proxy(renames["MetadataFilterOut"])
            ).optional(),
            "prefixMatch": t.string().optional(),
            "queryParameterMatches": t.array(
                t.proxy(renames["HttpQueryParameterMatchOut"])
            ).optional(),
            "ignoreCase": t.boolean().optional(),
            "regexMatch": t.string().optional(),
            "fullPathMatch": t.string().optional(),
            "headerMatches": t.array(t.proxy(renames["HttpHeaderMatchOut"])).optional(),
            "pathTemplateMatch": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpRouteRuleMatchOut"])
    types["InstancesSetLabelsRequestIn"] = t.struct(
        {
            "labels": t.struct({"_": t.string().optional()}),
            "labelFingerprint": t.string().optional(),
        }
    ).named(renames["InstancesSetLabelsRequestIn"])
    types["InstancesSetLabelsRequestOut"] = t.struct(
        {
            "labels": t.struct({"_": t.string().optional()}),
            "labelFingerprint": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstancesSetLabelsRequestOut"])
    types["InstanceAggregatedListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["InstanceAggregatedListIn"])
    types["InstanceAggregatedListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceAggregatedListOut"])
    types["TargetSslProxyIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "certificateMap": t.string().optional(),
            "sslCertificates": t.array(t.string()).optional(),
            "sslPolicy": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "service": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "id": t.string().optional(),
            "description": t.string().optional(),
            "name": t.string().optional(),
        }
    ).named(renames["TargetSslProxyIn"])
    types["TargetSslProxyOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "certificateMap": t.string().optional(),
            "sslCertificates": t.array(t.string()).optional(),
            "sslPolicy": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "service": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "id": t.string().optional(),
            "description": t.string().optional(),
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetSslProxyOut"])
    types["BfdStatusIn"] = t.struct(
        {
            "negotiatedLocalControlTxIntervalMs": t.integer().optional(),
            "rxPacket": t.proxy(renames["BfdPacketIn"]).optional(),
            "localState": t.string().optional(),
            "controlPacketIntervals": t.array(
                t.proxy(renames["PacketIntervalsIn"])
            ).optional(),
            "localDiagnostic": t.string().optional(),
            "txPacket": t.proxy(renames["BfdPacketIn"]).optional(),
            "bfdSessionInitializationMode": t.string().optional(),
            "uptimeMs": t.string().optional(),
            "configUpdateTimestampMicros": t.string().optional(),
            "controlPacketCounts": t.proxy(
                renames["BfdStatusPacketCountsIn"]
            ).optional(),
        }
    ).named(renames["BfdStatusIn"])
    types["BfdStatusOut"] = t.struct(
        {
            "negotiatedLocalControlTxIntervalMs": t.integer().optional(),
            "rxPacket": t.proxy(renames["BfdPacketOut"]).optional(),
            "localState": t.string().optional(),
            "controlPacketIntervals": t.array(
                t.proxy(renames["PacketIntervalsOut"])
            ).optional(),
            "localDiagnostic": t.string().optional(),
            "txPacket": t.proxy(renames["BfdPacketOut"]).optional(),
            "bfdSessionInitializationMode": t.string().optional(),
            "uptimeMs": t.string().optional(),
            "configUpdateTimestampMicros": t.string().optional(),
            "controlPacketCounts": t.proxy(
                renames["BfdStatusPacketCountsOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BfdStatusOut"])
    types["SerialPortOutputIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "next": t.string().optional(),
            "contents": t.string().optional(),
            "start": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["SerialPortOutputIn"])
    types["SerialPortOutputOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "next": t.string().optional(),
            "contents": t.string().optional(),
            "start": t.string().optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SerialPortOutputOut"])
    types["PacketMirroringNetworkInfoIn"] = t.struct(
        {"canonicalUrl": t.string().optional(), "url": t.string().optional()}
    ).named(renames["PacketMirroringNetworkInfoIn"])
    types["PacketMirroringNetworkInfoOut"] = t.struct(
        {
            "canonicalUrl": t.string().optional(),
            "url": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PacketMirroringNetworkInfoOut"])
    types["OperationAggregatedListIn"] = t.struct(
        {
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
        }
    ).named(renames["OperationAggregatedListIn"])
    types["OperationAggregatedListOut"] = t.struct(
        {
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["OperationAggregatedListOut"])
    types["WafExpressionSetExpressionIn"] = t.struct(
        {"sensitivity": t.integer().optional(), "id": t.string().optional()}
    ).named(renames["WafExpressionSetExpressionIn"])
    types["WafExpressionSetExpressionOut"] = t.struct(
        {
            "sensitivity": t.integer().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["WafExpressionSetExpressionOut"])
    types["TargetVpnGatewayIn"] = t.struct(
        {
            "status": t.string().optional(),
            "id": t.string().optional(),
            "description": t.string().optional(),
            "name": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "forwardingRules": t.array(t.string()).optional(),
            "labelFingerprint": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "region": t.string().optional(),
            "network": t.string().optional(),
            "tunnels": t.array(t.string()).optional(),
        }
    ).named(renames["TargetVpnGatewayIn"])
    types["TargetVpnGatewayOut"] = t.struct(
        {
            "status": t.string().optional(),
            "id": t.string().optional(),
            "description": t.string().optional(),
            "name": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "forwardingRules": t.array(t.string()).optional(),
            "labelFingerprint": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "region": t.string().optional(),
            "network": t.string().optional(),
            "tunnels": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetVpnGatewayOut"])
    types["ManagedInstanceLastAttemptIn"] = t.struct(
        {
            "errors": t.struct(
                {
                    "errors": t.array(
                        t.struct(
                            {
                                "location": t.string().optional(),
                                "message": t.string().optional(),
                                "code": t.string().optional(),
                                "errorDetails": t.array(
                                    t.struct(
                                        {
                                            "localizedMessage": t.proxy(
                                                renames["LocalizedMessageIn"]
                                            ),
                                            "help": t.proxy(renames["HelpIn"]),
                                            "errorInfo": t.proxy(
                                                renames["ErrorInfoIn"]
                                            ),
                                            "quotaInfo": t.proxy(
                                                renames["QuotaExceededInfoIn"]
                                            ),
                                        }
                                    )
                                ).optional(),
                            }
                        )
                    ).optional()
                }
            ).optional()
        }
    ).named(renames["ManagedInstanceLastAttemptIn"])
    types["ManagedInstanceLastAttemptOut"] = t.struct(
        {
            "errors": t.struct(
                {
                    "errors": t.array(
                        t.struct(
                            {
                                "location": t.string().optional(),
                                "message": t.string().optional(),
                                "code": t.string().optional(),
                                "errorDetails": t.array(
                                    t.struct(
                                        {
                                            "localizedMessage": t.proxy(
                                                renames["LocalizedMessageOut"]
                                            ),
                                            "help": t.proxy(renames["HelpOut"]),
                                            "errorInfo": t.proxy(
                                                renames["ErrorInfoOut"]
                                            ),
                                            "quotaInfo": t.proxy(
                                                renames["QuotaExceededInfoOut"]
                                            ),
                                        }
                                    )
                                ).optional(),
                            }
                        )
                    ).optional()
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ManagedInstanceLastAttemptOut"])
    types["HostRuleIn"] = t.struct(
        {
            "pathMatcher": t.string().optional(),
            "hosts": t.array(t.string()).optional(),
            "description": t.string().optional(),
        }
    ).named(renames["HostRuleIn"])
    types["HostRuleOut"] = t.struct(
        {
            "pathMatcher": t.string().optional(),
            "hosts": t.array(t.string()).optional(),
            "description": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HostRuleOut"])
    types["TargetPoolListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["TargetPoolIn"])).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
        }
    ).named(renames["TargetPoolListIn"])
    types["TargetPoolListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["TargetPoolOut"])).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetPoolListOut"])
    types["BfdStatusPacketCountsIn"] = t.struct(
        {
            "numRx": t.integer().optional(),
            "numTx": t.integer().optional(),
            "numRxSuccessful": t.integer().optional(),
            "numRxRejected": t.integer().optional(),
        }
    ).named(renames["BfdStatusPacketCountsIn"])
    types["BfdStatusPacketCountsOut"] = t.struct(
        {
            "numRx": t.integer().optional(),
            "numTx": t.integer().optional(),
            "numRxSuccessful": t.integer().optional(),
            "numRxRejected": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BfdStatusPacketCountsOut"])
    types["BackendServiceLocalityLoadBalancingPolicyConfigPolicyIn"] = t.struct(
        {"name": t.string().optional()}
    ).named(renames["BackendServiceLocalityLoadBalancingPolicyConfigPolicyIn"])
    types["BackendServiceLocalityLoadBalancingPolicyConfigPolicyOut"] = t.struct(
        {
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceLocalityLoadBalancingPolicyConfigPolicyOut"])
    types["DiskTypeIn"] = t.struct(
        {
            "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
            "region": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "selfLink": t.string().optional(),
            "validDiskSize": t.string().optional(),
            "defaultDiskSizeGb": t.string().optional(),
            "name": t.string().optional(),
            "zone": t.string().optional(),
            "description": t.string().optional(),
        }
    ).named(renames["DiskTypeIn"])
    types["DiskTypeOut"] = t.struct(
        {
            "deprecated": t.proxy(renames["DeprecationStatusOut"]).optional(),
            "region": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "selfLink": t.string().optional(),
            "validDiskSize": t.string().optional(),
            "defaultDiskSizeGb": t.string().optional(),
            "name": t.string().optional(),
            "zone": t.string().optional(),
            "description": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DiskTypeOut"])
    types["AllocationResourceStatusIn"] = t.struct(
        {
            "specificSkuAllocation": t.proxy(
                renames["AllocationResourceStatusSpecificSKUAllocationIn"]
            ).optional()
        }
    ).named(renames["AllocationResourceStatusIn"])
    types["AllocationResourceStatusOut"] = t.struct(
        {
            "specificSkuAllocation": t.proxy(
                renames["AllocationResourceStatusSpecificSKUAllocationOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AllocationResourceStatusOut"])
    types["SslCertificateManagedSslCertificateIn"] = t.struct(
        {
            "domains": t.array(t.string()).optional(),
            "status": t.string().optional(),
            "domainStatus": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["SslCertificateManagedSslCertificateIn"])
    types["SslCertificateManagedSslCertificateOut"] = t.struct(
        {
            "domains": t.array(t.string()).optional(),
            "status": t.string().optional(),
            "domainStatus": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SslCertificateManagedSslCertificateOut"])
    types["PolicyIn"] = t.struct(
        {
            "auditConfigs": t.array(t.proxy(renames["AuditConfigIn"])).optional(),
            "version": t.integer().optional(),
            "bindings": t.array(t.proxy(renames["BindingIn"])).optional(),
            "rules": t.array(t.proxy(renames["RuleIn"])).optional(),
            "etag": t.string().optional(),
        }
    ).named(renames["PolicyIn"])
    types["PolicyOut"] = t.struct(
        {
            "auditConfigs": t.array(t.proxy(renames["AuditConfigOut"])).optional(),
            "version": t.integer().optional(),
            "bindings": t.array(t.proxy(renames["BindingOut"])).optional(),
            "rules": t.array(t.proxy(renames["RuleOut"])).optional(),
            "etag": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PolicyOut"])
    types["InterconnectAttachmentAggregatedListIn"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["InterconnectAttachmentAggregatedListIn"])
    types["InterconnectAttachmentAggregatedListOut"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectAttachmentAggregatedListOut"])
    types["InstancesSetMachineTypeRequestIn"] = t.struct(
        {"machineType": t.string().optional()}
    ).named(renames["InstancesSetMachineTypeRequestIn"])
    types["InstancesSetMachineTypeRequestOut"] = t.struct(
        {
            "machineType": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstancesSetMachineTypeRequestOut"])
    types["InstanceGroupManagersDeleteInstancesRequestIn"] = t.struct(
        {
            "skipInstancesOnValidationError": t.boolean().optional(),
            "instances": t.array(t.string()).optional(),
        }
    ).named(renames["InstanceGroupManagersDeleteInstancesRequestIn"])
    types["InstanceGroupManagersDeleteInstancesRequestOut"] = t.struct(
        {
            "skipInstancesOnValidationError": t.boolean().optional(),
            "instances": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersDeleteInstancesRequestOut"])
    types["BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicyIn"] = t.struct(
        {"data": t.string().optional(), "name": t.string().optional()}
    ).named(renames["BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicyIn"])
    types["BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicyOut"] = t.struct(
        {
            "data": t.string().optional(),
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicyOut"])
    types["LicenseResourceCommitmentIn"] = t.struct(
        {
            "license": t.string().optional(),
            "amount": t.string().optional(),
            "coresPerLicense": t.string().optional(),
        }
    ).named(renames["LicenseResourceCommitmentIn"])
    types["LicenseResourceCommitmentOut"] = t.struct(
        {
            "license": t.string().optional(),
            "amount": t.string().optional(),
            "coresPerLicense": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LicenseResourceCommitmentOut"])
    types["InterconnectRemoteLocationListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.array(
                t.proxy(renames["InterconnectRemoteLocationIn"])
            ).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["InterconnectRemoteLocationListIn"])
    types["InterconnectRemoteLocationListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.array(
                t.proxy(renames["InterconnectRemoteLocationOut"])
            ).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectRemoteLocationListOut"])
    types["RegionDisksResizeRequestIn"] = t.struct(
        {"sizeGb": t.string().optional()}
    ).named(renames["RegionDisksResizeRequestIn"])
    types["RegionDisksResizeRequestOut"] = t.struct(
        {
            "sizeGb": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionDisksResizeRequestOut"])
    types["PacketMirroringsScopedListIn"] = t.struct(
        {
            "packetMirrorings": t.array(
                t.proxy(renames["PacketMirroringIn"])
            ).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
        }
    ).named(renames["PacketMirroringsScopedListIn"])
    types["PacketMirroringsScopedListOut"] = t.struct(
        {
            "packetMirrorings": t.array(
                t.proxy(renames["PacketMirroringOut"])
            ).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PacketMirroringsScopedListOut"])
    types["TargetPoolInstanceHealthIn"] = t.struct(
        {
            "healthStatus": t.array(t.proxy(renames["HealthStatusIn"])),
            "kind": t.string().optional(),
        }
    ).named(renames["TargetPoolInstanceHealthIn"])
    types["TargetPoolInstanceHealthOut"] = t.struct(
        {
            "healthStatus": t.array(t.proxy(renames["HealthStatusOut"])),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetPoolInstanceHealthOut"])
    types["RouterNatLogConfigIn"] = t.struct(
        {"filter": t.string().optional(), "enable": t.boolean().optional()}
    ).named(renames["RouterNatLogConfigIn"])
    types["RouterNatLogConfigOut"] = t.struct(
        {
            "filter": t.string().optional(),
            "enable": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterNatLogConfigOut"])
    types["InstanceConsumptionDataIn"] = t.struct(
        {
            "instance": t.string().optional(),
            "consumptionInfo": t.proxy(renames["InstanceConsumptionInfoIn"]).optional(),
        }
    ).named(renames["InstanceConsumptionDataIn"])
    types["InstanceConsumptionDataOut"] = t.struct(
        {
            "instance": t.string().optional(),
            "consumptionInfo": t.proxy(
                renames["InstanceConsumptionInfoOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceConsumptionDataOut"])
    types["NamedPortIn"] = t.struct(
        {"name": t.string().optional(), "port": t.integer().optional()}
    ).named(renames["NamedPortIn"])
    types["NamedPortOut"] = t.struct(
        {
            "name": t.string().optional(),
            "port": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NamedPortOut"])
    types["Uint128In"] = t.struct({"high": t.string(), "low": t.string()}).named(
        renames["Uint128In"]
    )
    types["Uint128Out"] = t.struct(
        {
            "high": t.string(),
            "low": t.string(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["Uint128Out"])
    types["HealthCheckServiceIn"] = t.struct(
        {
            "fingerprint": t.string().optional(),
            "healthChecks": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "healthStatusAggregationPolicy": t.string().optional(),
            "notificationEndpoints": t.array(t.string()).optional(),
            "networkEndpointGroups": t.array(t.string()).optional(),
            "region": t.string().optional(),
        }
    ).named(renames["HealthCheckServiceIn"])
    types["HealthCheckServiceOut"] = t.struct(
        {
            "fingerprint": t.string().optional(),
            "healthChecks": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "healthStatusAggregationPolicy": t.string().optional(),
            "notificationEndpoints": t.array(t.string()).optional(),
            "networkEndpointGroups": t.array(t.string()).optional(),
            "region": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HealthCheckServiceOut"])
    types["DurationIn"] = t.struct(
        {"seconds": t.string().optional(), "nanos": t.integer().optional()}
    ).named(renames["DurationIn"])
    types["DurationOut"] = t.struct(
        {
            "seconds": t.string().optional(),
            "nanos": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DurationOut"])
    types["ShareSettingsProjectConfigIn"] = t.struct(
        {"projectId": t.string().optional()}
    ).named(renames["ShareSettingsProjectConfigIn"])
    types["ShareSettingsProjectConfigOut"] = t.struct(
        {
            "projectId": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ShareSettingsProjectConfigOut"])
    types["DisplayDeviceIn"] = t.struct(
        {"enableDisplay": t.boolean().optional()}
    ).named(renames["DisplayDeviceIn"])
    types["DisplayDeviceOut"] = t.struct(
        {
            "enableDisplay": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DisplayDeviceOut"])
    types["NetworkPeeringIn"] = t.struct(
        {
            "exportCustomRoutes": t.boolean().optional(),
            "importSubnetRoutesWithPublicIp": t.boolean().optional(),
            "stateDetails": t.string().optional(),
            "stackType": t.string().optional(),
            "exportSubnetRoutesWithPublicIp": t.boolean().optional(),
            "network": t.string().optional(),
            "peerMtu": t.integer().optional(),
            "state": t.string().optional(),
            "exchangeSubnetRoutes": t.boolean().optional(),
            "importCustomRoutes": t.boolean().optional(),
            "autoCreateRoutes": t.boolean().optional(),
            "name": t.string().optional(),
        }
    ).named(renames["NetworkPeeringIn"])
    types["NetworkPeeringOut"] = t.struct(
        {
            "exportCustomRoutes": t.boolean().optional(),
            "importSubnetRoutesWithPublicIp": t.boolean().optional(),
            "stateDetails": t.string().optional(),
            "stackType": t.string().optional(),
            "exportSubnetRoutesWithPublicIp": t.boolean().optional(),
            "network": t.string().optional(),
            "peerMtu": t.integer().optional(),
            "state": t.string().optional(),
            "exchangeSubnetRoutes": t.boolean().optional(),
            "importCustomRoutes": t.boolean().optional(),
            "autoCreateRoutes": t.boolean().optional(),
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkPeeringOut"])
    types["DisksResizeRequestIn"] = t.struct({"sizeGb": t.string().optional()}).named(
        renames["DisksResizeRequestIn"]
    )
    types["DisksResizeRequestOut"] = t.struct(
        {
            "sizeGb": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DisksResizeRequestOut"])
    types["GlobalSetPolicyRequestIn"] = t.struct(
        {
            "policy": t.proxy(renames["PolicyIn"]).optional(),
            "etag": t.string().optional(),
            "bindings": t.array(t.proxy(renames["BindingIn"])).optional(),
        }
    ).named(renames["GlobalSetPolicyRequestIn"])
    types["GlobalSetPolicyRequestOut"] = t.struct(
        {
            "policy": t.proxy(renames["PolicyOut"]).optional(),
            "etag": t.string().optional(),
            "bindings": t.array(t.proxy(renames["BindingOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["GlobalSetPolicyRequestOut"])
    types["NodeGroupListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["NodeGroupIn"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["NodeGroupListIn"])
    types["NodeGroupListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["NodeGroupOut"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeGroupListOut"])
    types["InterconnectAttachmentListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["InterconnectAttachmentIn"])).optional(),
        }
    ).named(renames["InterconnectAttachmentListIn"])
    types["InterconnectAttachmentListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["InterconnectAttachmentOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectAttachmentListOut"])
    types["TargetHttpsProxiesSetSslCertificatesRequestIn"] = t.struct(
        {"sslCertificates": t.array(t.string()).optional()}
    ).named(renames["TargetHttpsProxiesSetSslCertificatesRequestIn"])
    types["TargetHttpsProxiesSetSslCertificatesRequestOut"] = t.struct(
        {
            "sslCertificates": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetHttpsProxiesSetSslCertificatesRequestOut"])
    types["InstanceGroupsListInstancesIn"] = t.struct(
        {
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceWithNamedPortsIn"])).optional(),
        }
    ).named(renames["InstanceGroupsListInstancesIn"])
    types["InstanceGroupsListInstancesOut"] = t.struct(
        {
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceWithNamedPortsOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupsListInstancesOut"])
    types["InstanceParamsIn"] = t.struct(
        {"resourceManagerTags": t.struct({"_": t.string().optional()}).optional()}
    ).named(renames["InstanceParamsIn"])
    types["InstanceParamsOut"] = t.struct(
        {
            "resourceManagerTags": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceParamsOut"])
    types["AccessConfigIn"] = t.struct(
        {
            "natIP": t.string().optional(),
            "networkTier": t.string().optional(),
            "externalIpv6": t.string().optional(),
            "name": t.string().optional(),
            "externalIpv6PrefixLength": t.integer().optional(),
            "kind": t.string().optional(),
            "setPublicPtr": t.boolean().optional(),
            "publicPtrDomainName": t.string().optional(),
            "type": t.string().optional(),
        }
    ).named(renames["AccessConfigIn"])
    types["AccessConfigOut"] = t.struct(
        {
            "natIP": t.string().optional(),
            "networkTier": t.string().optional(),
            "externalIpv6": t.string().optional(),
            "name": t.string().optional(),
            "externalIpv6PrefixLength": t.integer().optional(),
            "kind": t.string().optional(),
            "setPublicPtr": t.boolean().optional(),
            "publicPtrDomainName": t.string().optional(),
            "type": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AccessConfigOut"])
    types["NodeGroupsAddNodesRequestIn"] = t.struct(
        {"additionalNodeCount": t.integer().optional()}
    ).named(renames["NodeGroupsAddNodesRequestIn"])
    types["NodeGroupsAddNodesRequestOut"] = t.struct(
        {
            "additionalNodeCount": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeGroupsAddNodesRequestOut"])
    types["PathRuleIn"] = t.struct(
        {
            "urlRedirect": t.proxy(renames["HttpRedirectActionIn"]).optional(),
            "service": t.string().optional(),
            "paths": t.array(t.string()).optional(),
            "routeAction": t.proxy(renames["HttpRouteActionIn"]).optional(),
        }
    ).named(renames["PathRuleIn"])
    types["PathRuleOut"] = t.struct(
        {
            "urlRedirect": t.proxy(renames["HttpRedirectActionOut"]).optional(),
            "service": t.string().optional(),
            "paths": t.array(t.string()).optional(),
            "routeAction": t.proxy(renames["HttpRouteActionOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PathRuleOut"])
    types["MetadataIn"] = t.struct(
        {
            "items": t.array(
                t.struct({"value": t.string().optional(), "key": t.string().optional()})
            ).optional(),
            "kind": t.string().optional(),
            "fingerprint": t.string().optional(),
        }
    ).named(renames["MetadataIn"])
    types["MetadataOut"] = t.struct(
        {
            "items": t.array(
                t.struct({"value": t.string().optional(), "key": t.string().optional()})
            ).optional(),
            "kind": t.string().optional(),
            "fingerprint": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["MetadataOut"])
    types["InstanceGroupManagerStatusStatefulPerInstanceConfigsIn"] = t.struct(
        {"allEffective": t.boolean().optional()}
    ).named(renames["InstanceGroupManagerStatusStatefulPerInstanceConfigsIn"])
    types["InstanceGroupManagerStatusStatefulPerInstanceConfigsOut"] = t.struct(
        {
            "allEffective": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagerStatusStatefulPerInstanceConfigsOut"])
    types["SecurityPolicyAdaptiveProtectionConfigIn"] = t.struct(
        {
            "layer7DdosDefenseConfig": t.proxy(
                renames[
                    "SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigIn"
                ]
            ).optional()
        }
    ).named(renames["SecurityPolicyAdaptiveProtectionConfigIn"])
    types["SecurityPolicyAdaptiveProtectionConfigOut"] = t.struct(
        {
            "layer7DdosDefenseConfig": t.proxy(
                renames[
                    "SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigOut"
                ]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyAdaptiveProtectionConfigOut"])
    types["WafExpressionSetIn"] = t.struct(
        {
            "id": t.string().optional(),
            "expressions": t.array(
                t.proxy(renames["WafExpressionSetExpressionIn"])
            ).optional(),
            "aliases": t.array(t.string()).optional(),
        }
    ).named(renames["WafExpressionSetIn"])
    types["WafExpressionSetOut"] = t.struct(
        {
            "id": t.string().optional(),
            "expressions": t.array(
                t.proxy(renames["WafExpressionSetExpressionOut"])
            ).optional(),
            "aliases": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["WafExpressionSetOut"])
    types["BackendBucketCdnPolicyIn"] = t.struct(
        {
            "maxTtl": t.integer().optional(),
            "clientTtl": t.integer().optional(),
            "bypassCacheOnRequestHeaders": t.array(
                t.proxy(renames["BackendBucketCdnPolicyBypassCacheOnRequestHeaderIn"])
            ).optional(),
            "serveWhileStale": t.integer().optional(),
            "signedUrlCacheMaxAgeSec": t.string().optional(),
            "negativeCaching": t.boolean().optional(),
            "cacheMode": t.string().optional(),
            "cacheKeyPolicy": t.proxy(
                renames["BackendBucketCdnPolicyCacheKeyPolicyIn"]
            ).optional(),
            "requestCoalescing": t.boolean().optional(),
            "signedUrlKeyNames": t.array(t.string()).optional(),
            "defaultTtl": t.integer().optional(),
            "negativeCachingPolicy": t.array(
                t.proxy(renames["BackendBucketCdnPolicyNegativeCachingPolicyIn"])
            ).optional(),
        }
    ).named(renames["BackendBucketCdnPolicyIn"])
    types["BackendBucketCdnPolicyOut"] = t.struct(
        {
            "maxTtl": t.integer().optional(),
            "clientTtl": t.integer().optional(),
            "bypassCacheOnRequestHeaders": t.array(
                t.proxy(renames["BackendBucketCdnPolicyBypassCacheOnRequestHeaderOut"])
            ).optional(),
            "serveWhileStale": t.integer().optional(),
            "signedUrlCacheMaxAgeSec": t.string().optional(),
            "negativeCaching": t.boolean().optional(),
            "cacheMode": t.string().optional(),
            "cacheKeyPolicy": t.proxy(
                renames["BackendBucketCdnPolicyCacheKeyPolicyOut"]
            ).optional(),
            "requestCoalescing": t.boolean().optional(),
            "signedUrlKeyNames": t.array(t.string()).optional(),
            "defaultTtl": t.integer().optional(),
            "negativeCachingPolicy": t.array(
                t.proxy(renames["BackendBucketCdnPolicyNegativeCachingPolicyOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendBucketCdnPolicyOut"])
    types["RouterBgpPeerBfdIn"] = t.struct(
        {
            "multiplier": t.integer().optional(),
            "sessionInitializationMode": t.string().optional(),
            "minReceiveInterval": t.integer().optional(),
            "minTransmitInterval": t.integer().optional(),
        }
    ).named(renames["RouterBgpPeerBfdIn"])
    types["RouterBgpPeerBfdOut"] = t.struct(
        {
            "multiplier": t.integer().optional(),
            "sessionInitializationMode": t.string().optional(),
            "minReceiveInterval": t.integer().optional(),
            "minTransmitInterval": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterBgpPeerBfdOut"])
    types["LocalizedMessageIn"] = t.struct(
        {"locale": t.string().optional(), "message": t.string().optional()}
    ).named(renames["LocalizedMessageIn"])
    types["LocalizedMessageOut"] = t.struct(
        {
            "locale": t.string().optional(),
            "message": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LocalizedMessageOut"])
    types["InterconnectAttachmentConfigurationConstraintsIn"] = t.struct(
        {
            "bgpPeerAsnRanges": t.array(
                t.proxy(
                    renames[
                        "InterconnectAttachmentConfigurationConstraintsBgpPeerASNRangeIn"
                    ]
                )
            ).optional(),
            "bgpMd5": t.string().optional(),
        }
    ).named(renames["InterconnectAttachmentConfigurationConstraintsIn"])
    types["InterconnectAttachmentConfigurationConstraintsOut"] = t.struct(
        {
            "bgpPeerAsnRanges": t.array(
                t.proxy(
                    renames[
                        "InterconnectAttachmentConfigurationConstraintsBgpPeerASNRangeOut"
                    ]
                )
            ).optional(),
            "bgpMd5": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectAttachmentConfigurationConstraintsOut"])
    types["DistributionPolicyIn"] = t.struct(
        {
            "zones": t.array(
                t.proxy(renames["DistributionPolicyZoneConfigurationIn"])
            ).optional(),
            "targetShape": t.string().optional(),
        }
    ).named(renames["DistributionPolicyIn"])
    types["DistributionPolicyOut"] = t.struct(
        {
            "zones": t.array(
                t.proxy(renames["DistributionPolicyZoneConfigurationOut"])
            ).optional(),
            "targetShape": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DistributionPolicyOut"])
    types["VpnGatewayAggregatedListIn"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["VpnGatewayAggregatedListIn"])
    types["VpnGatewayAggregatedListOut"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnGatewayAggregatedListOut"])
    types["SnapshotIn"] = t.struct(
        {
            "storageLocations": t.array(t.string()).optional(),
            "autoCreated": t.boolean().optional(),
            "kind": t.string().optional(),
            "locationHint": t.string().optional(),
            "licenseCodes": t.array(t.string()).optional(),
            "sourceSnapshotSchedulePolicyId": t.string().optional(),
            "satisfiesPzs": t.boolean().optional(),
            "labelFingerprint": t.string().optional(),
            "storageBytes": t.string().optional(),
            "description": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "creationSizeBytes": t.string().optional(),
            "sourceDiskId": t.string().optional(),
            "sourceDisk": t.string().optional(),
            "name": t.string().optional(),
            "diskSizeGb": t.string().optional(),
            "sourceDiskEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyIn"]
            ).optional(),
            "licenses": t.array(t.string()).optional(),
            "status": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "chainName": t.string().optional(),
            "downloadBytes": t.string().optional(),
            "snapshotEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyIn"]
            ).optional(),
            "architecture": t.string().optional(),
            "storageBytesStatus": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "snapshotType": t.string().optional(),
            "sourceSnapshotSchedulePolicy": t.string().optional(),
        }
    ).named(renames["SnapshotIn"])
    types["SnapshotOut"] = t.struct(
        {
            "storageLocations": t.array(t.string()).optional(),
            "autoCreated": t.boolean().optional(),
            "kind": t.string().optional(),
            "locationHint": t.string().optional(),
            "licenseCodes": t.array(t.string()).optional(),
            "sourceSnapshotSchedulePolicyId": t.string().optional(),
            "satisfiesPzs": t.boolean().optional(),
            "labelFingerprint": t.string().optional(),
            "storageBytes": t.string().optional(),
            "description": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "creationSizeBytes": t.string().optional(),
            "sourceDiskId": t.string().optional(),
            "sourceDisk": t.string().optional(),
            "name": t.string().optional(),
            "diskSizeGb": t.string().optional(),
            "sourceDiskEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "licenses": t.array(t.string()).optional(),
            "status": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "chainName": t.string().optional(),
            "downloadBytes": t.string().optional(),
            "snapshotEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "architecture": t.string().optional(),
            "storageBytesStatus": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "snapshotType": t.string().optional(),
            "sourceSnapshotSchedulePolicy": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SnapshotOut"])
    types["AcceleratorConfigIn"] = t.struct(
        {
            "acceleratorType": t.string().optional(),
            "acceleratorCount": t.integer().optional(),
        }
    ).named(renames["AcceleratorConfigIn"])
    types["AcceleratorConfigOut"] = t.struct(
        {
            "acceleratorType": t.string().optional(),
            "acceleratorCount": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AcceleratorConfigOut"])
    types["InstanceManagedByIgmErrorInstanceActionDetailsIn"] = t.struct(
        {
            "version": t.proxy(renames["ManagedInstanceVersionIn"]).optional(),
            "action": t.string().optional(),
            "instance": t.string().optional(),
        }
    ).named(renames["InstanceManagedByIgmErrorInstanceActionDetailsIn"])
    types["InstanceManagedByIgmErrorInstanceActionDetailsOut"] = t.struct(
        {
            "version": t.proxy(renames["ManagedInstanceVersionOut"]).optional(),
            "action": t.string().optional(),
            "instance": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceManagedByIgmErrorInstanceActionDetailsOut"])
    types["TCPHealthCheckIn"] = t.struct(
        {
            "response": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "portSpecification": t.string().optional(),
            "request": t.string().optional(),
            "port": t.integer().optional(),
            "portName": t.string().optional(),
        }
    ).named(renames["TCPHealthCheckIn"])
    types["TCPHealthCheckOut"] = t.struct(
        {
            "response": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "portSpecification": t.string().optional(),
            "request": t.string().optional(),
            "port": t.integer().optional(),
            "portName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TCPHealthCheckOut"])
    types["TargetPoolsScopedListIn"] = t.struct(
        {
            "targetPools": t.array(t.proxy(renames["TargetPoolIn"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["TargetPoolsScopedListIn"])
    types["TargetPoolsScopedListOut"] = t.struct(
        {
            "targetPools": t.array(t.proxy(renames["TargetPoolOut"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetPoolsScopedListOut"])
    types["MachineImageIn"] = t.struct(
        {
            "sourceDiskEncryptionKeys": t.array(
                t.proxy(renames["SourceDiskEncryptionKeyIn"])
            ).optional(),
            "savedDisks": t.array(t.proxy(renames["SavedDiskIn"])).optional(),
            "description": t.string().optional(),
            "totalStorageBytes": t.string().optional(),
            "machineImageEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyIn"]
            ).optional(),
            "guestFlush": t.boolean().optional(),
            "id": t.string().optional(),
            "sourceInstanceProperties": t.proxy(
                renames["SourceInstancePropertiesIn"]
            ).optional(),
            "satisfiesPzs": t.boolean().optional(),
            "storageLocations": t.array(t.string()).optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "selfLink": t.string().optional(),
            "status": t.string().optional(),
            "instanceProperties": t.proxy(renames["InstancePropertiesIn"]).optional(),
            "kind": t.string().optional(),
            "sourceInstance": t.string().optional(),
        }
    ).named(renames["MachineImageIn"])
    types["MachineImageOut"] = t.struct(
        {
            "sourceDiskEncryptionKeys": t.array(
                t.proxy(renames["SourceDiskEncryptionKeyOut"])
            ).optional(),
            "savedDisks": t.array(t.proxy(renames["SavedDiskOut"])).optional(),
            "description": t.string().optional(),
            "totalStorageBytes": t.string().optional(),
            "machineImageEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "guestFlush": t.boolean().optional(),
            "id": t.string().optional(),
            "sourceInstanceProperties": t.proxy(
                renames["SourceInstancePropertiesOut"]
            ).optional(),
            "satisfiesPzs": t.boolean().optional(),
            "storageLocations": t.array(t.string()).optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "selfLink": t.string().optional(),
            "status": t.string().optional(),
            "instanceProperties": t.proxy(renames["InstancePropertiesOut"]).optional(),
            "kind": t.string().optional(),
            "sourceInstance": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["MachineImageOut"])
    types["InterconnectsGetDiagnosticsResponseIn"] = t.struct(
        {"result": t.proxy(renames["InterconnectDiagnosticsIn"])}
    ).named(renames["InterconnectsGetDiagnosticsResponseIn"])
    types["InterconnectsGetDiagnosticsResponseOut"] = t.struct(
        {
            "result": t.proxy(renames["InterconnectDiagnosticsOut"]),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectsGetDiagnosticsResponseOut"])
    types["BackendIn"] = t.struct(
        {
            "capacityScaler": t.number().optional(),
            "description": t.string().optional(),
            "failover": t.boolean().optional(),
            "maxConnections": t.integer().optional(),
            "maxConnectionsPerInstance": t.integer().optional(),
            "maxRatePerEndpoint": t.number().optional(),
            "maxUtilization": t.number().optional(),
            "maxRatePerInstance": t.number().optional(),
            "balancingMode": t.string().optional(),
            "maxConnectionsPerEndpoint": t.integer().optional(),
            "group": t.string().optional(),
            "maxRate": t.integer().optional(),
        }
    ).named(renames["BackendIn"])
    types["BackendOut"] = t.struct(
        {
            "capacityScaler": t.number().optional(),
            "description": t.string().optional(),
            "failover": t.boolean().optional(),
            "maxConnections": t.integer().optional(),
            "maxConnectionsPerInstance": t.integer().optional(),
            "maxRatePerEndpoint": t.number().optional(),
            "maxUtilization": t.number().optional(),
            "maxRatePerInstance": t.number().optional(),
            "balancingMode": t.string().optional(),
            "maxConnectionsPerEndpoint": t.integer().optional(),
            "group": t.string().optional(),
            "maxRate": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendOut"])
    types["PacketMirroringAggregatedListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
        }
    ).named(renames["PacketMirroringAggregatedListIn"])
    types["PacketMirroringAggregatedListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PacketMirroringAggregatedListOut"])
    types["InstancesSetMinCpuPlatformRequestIn"] = t.struct(
        {"minCpuPlatform": t.string().optional()}
    ).named(renames["InstancesSetMinCpuPlatformRequestIn"])
    types["InstancesSetMinCpuPlatformRequestOut"] = t.struct(
        {
            "minCpuPlatform": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstancesSetMinCpuPlatformRequestOut"])
    types["ImageFamilyViewIn"] = t.struct(
        {"image": t.proxy(renames["ImageIn"]).optional()}
    ).named(renames["ImageFamilyViewIn"])
    types["ImageFamilyViewOut"] = t.struct(
        {
            "image": t.proxy(renames["ImageOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ImageFamilyViewOut"])
    types["AuditLogConfigIn"] = t.struct(
        {
            "logType": t.string().optional(),
            "ignoreChildExemptions": t.boolean().optional(),
            "exemptedMembers": t.array(t.string()).optional(),
        }
    ).named(renames["AuditLogConfigIn"])
    types["AuditLogConfigOut"] = t.struct(
        {
            "logType": t.string().optional(),
            "ignoreChildExemptions": t.boolean().optional(),
            "exemptedMembers": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AuditLogConfigOut"])
    types["TargetInstanceIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "natPolicy": t.string().optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "network": t.string().optional(),
            "instance": t.string().optional(),
            "zone": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["TargetInstanceIn"])
    types["TargetInstanceOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "natPolicy": t.string().optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "network": t.string().optional(),
            "instance": t.string().optional(),
            "zone": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetInstanceOut"])
    types["RegionIn"] = t.struct(
        {
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "zones": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "name": t.string().optional(),
            "quotas": t.array(t.proxy(renames["QuotaIn"])).optional(),
            "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
            "supportsPzs": t.boolean().optional(),
            "status": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["RegionIn"])
    types["RegionOut"] = t.struct(
        {
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "zones": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "name": t.string().optional(),
            "quotas": t.array(t.proxy(renames["QuotaOut"])).optional(),
            "deprecated": t.proxy(renames["DeprecationStatusOut"]).optional(),
            "supportsPzs": t.boolean().optional(),
            "status": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionOut"])
    types["InstanceGroupManagersApplyUpdatesRequestIn"] = t.struct(
        {
            "instances": t.array(t.string()).optional(),
            "minimalAction": t.string().optional(),
            "allInstances": t.boolean().optional(),
            "mostDisruptiveAllowedAction": t.string().optional(),
        }
    ).named(renames["InstanceGroupManagersApplyUpdatesRequestIn"])
    types["InstanceGroupManagersApplyUpdatesRequestOut"] = t.struct(
        {
            "instances": t.array(t.string()).optional(),
            "minimalAction": t.string().optional(),
            "allInstances": t.boolean().optional(),
            "mostDisruptiveAllowedAction": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersApplyUpdatesRequestOut"])
    types["PublicDelegatedPrefixIn"] = t.struct(
        {
            "region": t.string().optional(),
            "fingerprint": t.string().optional(),
            "selfLink": t.string().optional(),
            "status": t.string().optional(),
            "name": t.string().optional(),
            "description": t.string().optional(),
            "id": t.string().optional(),
            "parentPrefix": t.string().optional(),
            "publicDelegatedSubPrefixs": t.array(
                t.proxy(renames["PublicDelegatedPrefixPublicDelegatedSubPrefixIn"])
            ).optional(),
            "ipCidrRange": t.string().optional(),
            "kind": t.string().optional(),
            "isLiveMigration": t.boolean().optional(),
            "creationTimestamp": t.string().optional(),
        }
    ).named(renames["PublicDelegatedPrefixIn"])
    types["PublicDelegatedPrefixOut"] = t.struct(
        {
            "region": t.string().optional(),
            "fingerprint": t.string().optional(),
            "selfLink": t.string().optional(),
            "status": t.string().optional(),
            "name": t.string().optional(),
            "description": t.string().optional(),
            "id": t.string().optional(),
            "parentPrefix": t.string().optional(),
            "publicDelegatedSubPrefixs": t.array(
                t.proxy(renames["PublicDelegatedPrefixPublicDelegatedSubPrefixOut"])
            ).optional(),
            "ipCidrRange": t.string().optional(),
            "kind": t.string().optional(),
            "isLiveMigration": t.boolean().optional(),
            "creationTimestamp": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PublicDelegatedPrefixOut"])
    types["ResourcePolicyHourlyCycleIn"] = t.struct(
        {
            "startTime": t.string().optional(),
            "duration": t.string().optional(),
            "hoursInCycle": t.integer().optional(),
        }
    ).named(renames["ResourcePolicyHourlyCycleIn"])
    types["ResourcePolicyHourlyCycleOut"] = t.struct(
        {
            "startTime": t.string().optional(),
            "duration": t.string().optional(),
            "hoursInCycle": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicyHourlyCycleOut"])
    types["SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfigIn"] = t.struct(
        {
            "enforceOnKeyName": t.string().optional(),
            "enforceOnKeyType": t.string().optional(),
        }
    ).named(renames["SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfigIn"])
    types["SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfigOut"] = t.struct(
        {
            "enforceOnKeyName": t.string().optional(),
            "enforceOnKeyType": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfigOut"])
    types["InstanceGroupsRemoveInstancesRequestIn"] = t.struct(
        {"instances": t.array(t.proxy(renames["InstanceReferenceIn"])).optional()}
    ).named(renames["InstanceGroupsRemoveInstancesRequestIn"])
    types["InstanceGroupsRemoveInstancesRequestOut"] = t.struct(
        {
            "instances": t.array(t.proxy(renames["InstanceReferenceOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupsRemoveInstancesRequestOut"])
    types["InstanceGroupManagersUpdatePerInstanceConfigsReqIn"] = t.struct(
        {
            "perInstanceConfigs": t.array(
                t.proxy(renames["PerInstanceConfigIn"])
            ).optional()
        }
    ).named(renames["InstanceGroupManagersUpdatePerInstanceConfigsReqIn"])
    types["InstanceGroupManagersUpdatePerInstanceConfigsReqOut"] = t.struct(
        {
            "perInstanceConfigs": t.array(
                t.proxy(renames["PerInstanceConfigOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersUpdatePerInstanceConfigsReqOut"])
    types["InterconnectCircuitInfoIn"] = t.struct(
        {
            "googleDemarcId": t.string().optional(),
            "customerDemarcId": t.string().optional(),
            "googleCircuitId": t.string().optional(),
        }
    ).named(renames["InterconnectCircuitInfoIn"])
    types["InterconnectCircuitInfoOut"] = t.struct(
        {
            "googleDemarcId": t.string().optional(),
            "customerDemarcId": t.string().optional(),
            "googleCircuitId": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectCircuitInfoOut"])
    types["InstanceTemplateIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "properties": t.proxy(renames["InstancePropertiesIn"]).optional(),
            "id": t.string().optional(),
            "region": t.string().optional(),
            "sourceInstance": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "name": t.string().optional(),
            "description": t.string().optional(),
            "selfLink": t.string().optional(),
            "sourceInstanceParams": t.proxy(
                renames["SourceInstanceParamsIn"]
            ).optional(),
        }
    ).named(renames["InstanceTemplateIn"])
    types["InstanceTemplateOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "properties": t.proxy(renames["InstancePropertiesOut"]).optional(),
            "id": t.string().optional(),
            "region": t.string().optional(),
            "sourceInstance": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "name": t.string().optional(),
            "description": t.string().optional(),
            "selfLink": t.string().optional(),
            "sourceInstanceParams": t.proxy(
                renames["SourceInstanceParamsOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceTemplateOut"])
    types["RegionInstanceGroupManagersListErrorsResponseIn"] = t.struct(
        {
            "items": t.array(
                t.proxy(renames["InstanceManagedByIgmErrorIn"])
            ).optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["RegionInstanceGroupManagersListErrorsResponseIn"])
    types["RegionInstanceGroupManagersListErrorsResponseOut"] = t.struct(
        {
            "items": t.array(
                t.proxy(renames["InstanceManagedByIgmErrorOut"])
            ).optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagersListErrorsResponseOut"])
    types["RouterIn"] = t.struct(
        {
            "nats": t.array(t.proxy(renames["RouterNatIn"])).optional(),
            "kind": t.string().optional(),
            "md5AuthenticationKeys": t.array(
                t.proxy(renames["RouterMd5AuthenticationKeyIn"])
            ).optional(),
            "region": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "encryptedInterconnectRouter": t.boolean().optional(),
            "bgpPeers": t.array(t.proxy(renames["RouterBgpPeerIn"])).optional(),
            "bgp": t.proxy(renames["RouterBgpIn"]).optional(),
            "interfaces": t.array(t.proxy(renames["RouterInterfaceIn"])).optional(),
            "network": t.string().optional(),
            "description": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["RouterIn"])
    types["RouterOut"] = t.struct(
        {
            "nats": t.array(t.proxy(renames["RouterNatOut"])).optional(),
            "kind": t.string().optional(),
            "md5AuthenticationKeys": t.array(
                t.proxy(renames["RouterMd5AuthenticationKeyOut"])
            ).optional(),
            "region": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "encryptedInterconnectRouter": t.boolean().optional(),
            "bgpPeers": t.array(t.proxy(renames["RouterBgpPeerOut"])).optional(),
            "bgp": t.proxy(renames["RouterBgpOut"]).optional(),
            "interfaces": t.array(t.proxy(renames["RouterInterfaceOut"])).optional(),
            "network": t.string().optional(),
            "description": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterOut"])
    types["PublicDelegatedPrefixPublicDelegatedSubPrefixIn"] = t.struct(
        {
            "delegateeProject": t.string().optional(),
            "description": t.string().optional(),
            "name": t.string().optional(),
            "status": t.string().optional(),
            "isAddress": t.boolean().optional(),
            "ipCidrRange": t.string().optional(),
            "region": t.string().optional(),
        }
    ).named(renames["PublicDelegatedPrefixPublicDelegatedSubPrefixIn"])
    types["PublicDelegatedPrefixPublicDelegatedSubPrefixOut"] = t.struct(
        {
            "delegateeProject": t.string().optional(),
            "description": t.string().optional(),
            "name": t.string().optional(),
            "status": t.string().optional(),
            "isAddress": t.boolean().optional(),
            "ipCidrRange": t.string().optional(),
            "region": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PublicDelegatedPrefixPublicDelegatedSubPrefixOut"])
    types["SslPoliciesListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["SslPolicyIn"])).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["SslPoliciesListIn"])
    types["SslPoliciesListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["SslPolicyOut"])).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SslPoliciesListOut"])
    types["PreservedStateIn"] = t.struct(
        {
            "disks": t.struct({"_": t.string().optional()}).optional(),
            "metadata": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["PreservedStateIn"])
    types["PreservedStateOut"] = t.struct(
        {
            "disks": t.struct({"_": t.string().optional()}).optional(),
            "metadata": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PreservedStateOut"])
    types["UsableSubnetworksAggregatedListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["UsableSubnetworkIn"])).optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
        }
    ).named(renames["UsableSubnetworksAggregatedListIn"])
    types["UsableSubnetworksAggregatedListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["UsableSubnetworkOut"])).optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UsableSubnetworksAggregatedListOut"])
    types["ReservationAggregatedListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
        }
    ).named(renames["ReservationAggregatedListIn"])
    types["ReservationAggregatedListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ReservationAggregatedListOut"])
    types["RegionInstanceGroupsListInstancesIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceWithNamedPortsIn"])).optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["RegionInstanceGroupsListInstancesIn"])
    types["RegionInstanceGroupsListInstancesOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceWithNamedPortsOut"])).optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupsListInstancesOut"])
    types["NetworkAttachmentsScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "networkAttachments": t.array(
                t.proxy(renames["NetworkAttachmentIn"])
            ).optional(),
        }
    ).named(renames["NetworkAttachmentsScopedListIn"])
    types["NetworkAttachmentsScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "networkAttachments": t.array(
                t.proxy(renames["NetworkAttachmentOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkAttachmentsScopedListOut"])
    types["RouterStatusResponseIn"] = t.struct(
        {"kind": t.string().optional(), "result": t.proxy(renames["RouterStatusIn"])}
    ).named(renames["RouterStatusResponseIn"])
    types["RouterStatusResponseOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "result": t.proxy(renames["RouterStatusOut"]),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterStatusResponseOut"])
    types["TargetTcpProxyListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["TargetTcpProxyIn"])).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["TargetTcpProxyListIn"])
    types["TargetTcpProxyListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["TargetTcpProxyOut"])).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetTcpProxyListOut"])
    types["SecurityPolicyRuleHttpHeaderActionIn"] = t.struct(
        {
            "requestHeadersToAdds": t.array(
                t.proxy(renames["SecurityPolicyRuleHttpHeaderActionHttpHeaderOptionIn"])
            ).optional()
        }
    ).named(renames["SecurityPolicyRuleHttpHeaderActionIn"])
    types["SecurityPolicyRuleHttpHeaderActionOut"] = t.struct(
        {
            "requestHeadersToAdds": t.array(
                t.proxy(
                    renames["SecurityPolicyRuleHttpHeaderActionHttpHeaderOptionOut"]
                )
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyRuleHttpHeaderActionOut"])
    types["SecurityPolicyRuleRedirectOptionsIn"] = t.struct(
        {"type": t.string().optional(), "target": t.string().optional()}
    ).named(renames["SecurityPolicyRuleRedirectOptionsIn"])
    types["SecurityPolicyRuleRedirectOptionsOut"] = t.struct(
        {
            "type": t.string().optional(),
            "target": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyRuleRedirectOptionsOut"])
    types["NodeTemplateNodeTypeFlexibilityIn"] = t.struct(
        {"memory": t.string(), "localSsd": t.string(), "cpus": t.string()}
    ).named(renames["NodeTemplateNodeTypeFlexibilityIn"])
    types["NodeTemplateNodeTypeFlexibilityOut"] = t.struct(
        {
            "memory": t.string(),
            "localSsd": t.string(),
            "cpus": t.string(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeTemplateNodeTypeFlexibilityOut"])
    types["InstanceGroupManagersListErrorsResponseIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.array(
                t.proxy(renames["InstanceManagedByIgmErrorIn"])
            ).optional(),
        }
    ).named(renames["InstanceGroupManagersListErrorsResponseIn"])
    types["InstanceGroupManagersListErrorsResponseOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.array(
                t.proxy(renames["InstanceManagedByIgmErrorOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersListErrorsResponseOut"])
    types["MetadataFilterIn"] = t.struct(
        {
            "filterLabels": t.array(
                t.proxy(renames["MetadataFilterLabelMatchIn"])
            ).optional(),
            "filterMatchCriteria": t.string().optional(),
        }
    ).named(renames["MetadataFilterIn"])
    types["MetadataFilterOut"] = t.struct(
        {
            "filterLabels": t.array(
                t.proxy(renames["MetadataFilterLabelMatchOut"])
            ).optional(),
            "filterMatchCriteria": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["MetadataFilterOut"])
    types["InstanceReferenceIn"] = t.struct({"instance": t.string().optional()}).named(
        renames["InstanceReferenceIn"]
    )
    types["InstanceReferenceOut"] = t.struct(
        {
            "instance": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceReferenceOut"])
    types["DistributionPolicyZoneConfigurationIn"] = t.struct(
        {"zone": t.string().optional()}
    ).named(renames["DistributionPolicyZoneConfigurationIn"])
    types["DistributionPolicyZoneConfigurationOut"] = t.struct(
        {
            "zone": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DistributionPolicyZoneConfigurationOut"])
    types["NodeGroupNodeIn"] = t.struct(
        {
            "nodeType": t.string().optional(),
            "status": t.string(),
            "accelerators": t.array(t.proxy(renames["AcceleratorConfigIn"])).optional(),
            "disks": t.array(t.proxy(renames["LocalDiskIn"])).optional(),
            "name": t.string().optional(),
            "serverBinding": t.proxy(renames["ServerBindingIn"]).optional(),
            "cpuOvercommitType": t.string().optional(),
            "instances": t.array(t.string()).optional(),
            "satisfiesPzs": t.boolean().optional(),
            "totalResources": t.proxy(renames["InstanceConsumptionInfoIn"]).optional(),
            "consumedResources": t.proxy(
                renames["InstanceConsumptionInfoIn"]
            ).optional(),
            "serverId": t.string().optional(),
            "instanceConsumptionData": t.array(
                t.proxy(renames["InstanceConsumptionDataIn"])
            ).optional(),
        }
    ).named(renames["NodeGroupNodeIn"])
    types["NodeGroupNodeOut"] = t.struct(
        {
            "nodeType": t.string().optional(),
            "status": t.string(),
            "accelerators": t.array(
                t.proxy(renames["AcceleratorConfigOut"])
            ).optional(),
            "disks": t.array(t.proxy(renames["LocalDiskOut"])).optional(),
            "name": t.string().optional(),
            "serverBinding": t.proxy(renames["ServerBindingOut"]).optional(),
            "cpuOvercommitType": t.string().optional(),
            "instances": t.array(t.string()).optional(),
            "satisfiesPzs": t.boolean().optional(),
            "totalResources": t.proxy(renames["InstanceConsumptionInfoOut"]).optional(),
            "consumedResources": t.proxy(
                renames["InstanceConsumptionInfoOut"]
            ).optional(),
            "serverId": t.string().optional(),
            "instanceConsumptionData": t.array(
                t.proxy(renames["InstanceConsumptionDataOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeGroupNodeOut"])
    types["HttpRedirectActionIn"] = t.struct(
        {
            "redirectResponseCode": t.string().optional(),
            "pathRedirect": t.string().optional(),
            "stripQuery": t.boolean().optional(),
            "prefixRedirect": t.string().optional(),
            "hostRedirect": t.string().optional(),
            "httpsRedirect": t.boolean().optional(),
        }
    ).named(renames["HttpRedirectActionIn"])
    types["HttpRedirectActionOut"] = t.struct(
        {
            "redirectResponseCode": t.string().optional(),
            "pathRedirect": t.string().optional(),
            "stripQuery": t.boolean().optional(),
            "prefixRedirect": t.string().optional(),
            "hostRedirect": t.string().optional(),
            "httpsRedirect": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpRedirectActionOut"])
    types["QuotaExceededInfoIn"] = t.struct(
        {
            "metricName": t.string().optional(),
            "dimensions": t.struct({"_": t.string().optional()}).optional(),
            "limit": t.number().optional(),
            "limitName": t.string().optional(),
        }
    ).named(renames["QuotaExceededInfoIn"])
    types["QuotaExceededInfoOut"] = t.struct(
        {
            "metricName": t.string().optional(),
            "dimensions": t.struct({"_": t.string().optional()}).optional(),
            "limit": t.number().optional(),
            "limitName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["QuotaExceededInfoOut"])
    types["UrlRewriteIn"] = t.struct(
        {
            "pathTemplateRewrite": t.string().optional(),
            "pathPrefixRewrite": t.string().optional(),
            "hostRewrite": t.string().optional(),
        }
    ).named(renames["UrlRewriteIn"])
    types["UrlRewriteOut"] = t.struct(
        {
            "pathTemplateRewrite": t.string().optional(),
            "pathPrefixRewrite": t.string().optional(),
            "hostRewrite": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UrlRewriteOut"])
    types["ReservationAffinityIn"] = t.struct(
        {
            "consumeReservationType": t.string().optional(),
            "key": t.string().optional(),
            "values": t.array(t.string()).optional(),
        }
    ).named(renames["ReservationAffinityIn"])
    types["ReservationAffinityOut"] = t.struct(
        {
            "consumeReservationType": t.string().optional(),
            "key": t.string().optional(),
            "values": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ReservationAffinityOut"])
    types["InterconnectRemoteLocationConstraintsIn"] = t.struct(
        {
            "portPairRemoteLocation": t.string().optional(),
            "subnetLengthRange": t.proxy(
                renames["InterconnectRemoteLocationConstraintsSubnetLengthRangeIn"]
            ).optional(),
            "portPairVlan": t.string().optional(),
        }
    ).named(renames["InterconnectRemoteLocationConstraintsIn"])
    types["InterconnectRemoteLocationConstraintsOut"] = t.struct(
        {
            "portPairRemoteLocation": t.string().optional(),
            "subnetLengthRange": t.proxy(
                renames["InterconnectRemoteLocationConstraintsSubnetLengthRangeOut"]
            ).optional(),
            "portPairVlan": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectRemoteLocationConstraintsOut"])
    types["SecurityPolicyRuleHttpHeaderActionHttpHeaderOptionIn"] = t.struct(
        {"headerName": t.string().optional(), "headerValue": t.string().optional()}
    ).named(renames["SecurityPolicyRuleHttpHeaderActionHttpHeaderOptionIn"])
    types["SecurityPolicyRuleHttpHeaderActionHttpHeaderOptionOut"] = t.struct(
        {
            "headerName": t.string().optional(),
            "headerValue": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyRuleHttpHeaderActionHttpHeaderOptionOut"])
    types["UrlMapsAggregatedListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["UrlMapsAggregatedListIn"])
    types["UrlMapsAggregatedListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UrlMapsAggregatedListOut"])
    types["SslPoliciesListAvailableFeaturesResponseIn"] = t.struct(
        {"features": t.array(t.string())}
    ).named(renames["SslPoliciesListAvailableFeaturesResponseIn"])
    types["SslPoliciesListAvailableFeaturesResponseOut"] = t.struct(
        {
            "features": t.array(t.string()),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SslPoliciesListAvailableFeaturesResponseOut"])
    types["TargetSslProxyListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["TargetSslProxyIn"])).optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["TargetSslProxyListIn"])
    types["TargetSslProxyListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["TargetSslProxyOut"])).optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetSslProxyListOut"])
    types["NetworkRoutingConfigIn"] = t.struct(
        {"routingMode": t.string().optional()}
    ).named(renames["NetworkRoutingConfigIn"])
    types["NetworkRoutingConfigOut"] = t.struct(
        {
            "routingMode": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkRoutingConfigOut"])
    types["InstancesStartWithEncryptionKeyRequestIn"] = t.struct(
        {
            "disks": t.array(
                t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
            ).optional()
        }
    ).named(renames["InstancesStartWithEncryptionKeyRequestIn"])
    types["InstancesStartWithEncryptionKeyRequestOut"] = t.struct(
        {
            "disks": t.array(
                t.proxy(renames["CustomerEncryptionKeyProtectedDiskOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstancesStartWithEncryptionKeyRequestOut"])
    types[
        "RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn"
    ] = t.struct(
        {
            "type": t.string().optional(),
            "name": t.string().optional(),
            "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
            "displayName": t.string().optional(),
        }
    ).named(
        renames[
            "RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn"
        ]
    )
    types[
        "RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut"
    ] = t.struct(
        {
            "type": t.string().optional(),
            "name": t.string().optional(),
            "rules": t.array(t.proxy(renames["FirewallPolicyRuleOut"])).optional(),
            "displayName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(
        renames[
            "RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut"
        ]
    )
    types["FirewallPoliciesListAssociationsResponseIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "associations": t.array(
                t.proxy(renames["FirewallPolicyAssociationIn"])
            ).optional(),
        }
    ).named(renames["FirewallPoliciesListAssociationsResponseIn"])
    types["FirewallPoliciesListAssociationsResponseOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "associations": t.array(
                t.proxy(renames["FirewallPolicyAssociationOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["FirewallPoliciesListAssociationsResponseOut"])
    types["PublicDelegatedPrefixListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["PublicDelegatedPrefixIn"])).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["PublicDelegatedPrefixListIn"])
    types["PublicDelegatedPrefixListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["PublicDelegatedPrefixOut"])).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PublicDelegatedPrefixListOut"])
    types["BulkInsertDiskResourceIn"] = t.struct(
        {"sourceConsistencyGroupPolicy": t.string().optional()}
    ).named(renames["BulkInsertDiskResourceIn"])
    types["BulkInsertDiskResourceOut"] = t.struct(
        {
            "sourceConsistencyGroupPolicy": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BulkInsertDiskResourceOut"])
    types["SecurityPolicyRecaptchaOptionsConfigIn"] = t.struct(
        {"redirectSiteKey": t.string().optional()}
    ).named(renames["SecurityPolicyRecaptchaOptionsConfigIn"])
    types["SecurityPolicyRecaptchaOptionsConfigOut"] = t.struct(
        {
            "redirectSiteKey": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyRecaptchaOptionsConfigOut"])
    types["ResourcePoliciesScopedListIn"] = t.struct(
        {
            "resourcePolicies": t.array(
                t.proxy(renames["ResourcePolicyIn"])
            ).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["ResourcePoliciesScopedListIn"])
    types["ResourcePoliciesScopedListOut"] = t.struct(
        {
            "resourcePolicies": t.array(
                t.proxy(renames["ResourcePolicyOut"])
            ).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePoliciesScopedListOut"])
    types["InstancesAddResourcePoliciesRequestIn"] = t.struct(
        {"resourcePolicies": t.array(t.string()).optional()}
    ).named(renames["InstancesAddResourcePoliciesRequestIn"])
    types["InstancesAddResourcePoliciesRequestOut"] = t.struct(
        {
            "resourcePolicies": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstancesAddResourcePoliciesRequestOut"])
    types["InterconnectDiagnosticsLinkLACPStatusIn"] = t.struct(
        {
            "neighborSystemId": t.string().optional(),
            "state": t.string().optional(),
            "googleSystemId": t.string().optional(),
        }
    ).named(renames["InterconnectDiagnosticsLinkLACPStatusIn"])
    types["InterconnectDiagnosticsLinkLACPStatusOut"] = t.struct(
        {
            "neighborSystemId": t.string().optional(),
            "state": t.string().optional(),
            "googleSystemId": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectDiagnosticsLinkLACPStatusOut"])
    types["SecurityPolicyRuleRateLimitOptionsIn"] = t.struct(
        {
            "banDurationSec": t.integer().optional(),
            "enforceOnKey": t.string().optional(),
            "banThreshold": t.proxy(
                renames["SecurityPolicyRuleRateLimitOptionsThresholdIn"]
            ).optional(),
            "conformAction": t.string().optional(),
            "rateLimitThreshold": t.proxy(
                renames["SecurityPolicyRuleRateLimitOptionsThresholdIn"]
            ).optional(),
            "exceedRedirectOptions": t.proxy(
                renames["SecurityPolicyRuleRedirectOptionsIn"]
            ).optional(),
            "enforceOnKeyName": t.string().optional(),
            "enforceOnKeyConfigs": t.array(
                t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfigIn"]
                )
            ).optional(),
            "exceedAction": t.string().optional(),
        }
    ).named(renames["SecurityPolicyRuleRateLimitOptionsIn"])
    types["SecurityPolicyRuleRateLimitOptionsOut"] = t.struct(
        {
            "banDurationSec": t.integer().optional(),
            "enforceOnKey": t.string().optional(),
            "banThreshold": t.proxy(
                renames["SecurityPolicyRuleRateLimitOptionsThresholdOut"]
            ).optional(),
            "conformAction": t.string().optional(),
            "rateLimitThreshold": t.proxy(
                renames["SecurityPolicyRuleRateLimitOptionsThresholdOut"]
            ).optional(),
            "exceedRedirectOptions": t.proxy(
                renames["SecurityPolicyRuleRedirectOptionsOut"]
            ).optional(),
            "enforceOnKeyName": t.string().optional(),
            "enforceOnKeyConfigs": t.array(
                t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfigOut"]
                )
            ).optional(),
            "exceedAction": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyRuleRateLimitOptionsOut"])
    types["SecurityPolicyRulePreconfiguredWafConfigIn"] = t.struct(
        {
            "exclusions": t.array(
                t.proxy(renames["SecurityPolicyRulePreconfiguredWafConfigExclusionIn"])
            ).optional()
        }
    ).named(renames["SecurityPolicyRulePreconfiguredWafConfigIn"])
    types["SecurityPolicyRulePreconfiguredWafConfigOut"] = t.struct(
        {
            "exclusions": t.array(
                t.proxy(renames["SecurityPolicyRulePreconfiguredWafConfigExclusionOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyRulePreconfiguredWafConfigOut"])
    types["NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn"] = t.struct(
        {
            "name": t.string().optional(),
            "shortName": t.string().optional(),
            "type": t.string().optional(),
            "displayName": t.string().optional(),
            "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
        }
    ).named(renames["NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn"])
    types["NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut"] = t.struct(
        {
            "name": t.string().optional(),
            "shortName": t.string().optional(),
            "type": t.string().optional(),
            "displayName": t.string().optional(),
            "rules": t.array(t.proxy(renames["FirewallPolicyRuleOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut"])
    types["VpnGatewayStatusTunnelIn"] = t.struct(
        {
            "peerGatewayInterface": t.integer().optional(),
            "tunnelUrl": t.string().optional(),
            "localGatewayInterface": t.integer().optional(),
        }
    ).named(renames["VpnGatewayStatusTunnelIn"])
    types["VpnGatewayStatusTunnelOut"] = t.struct(
        {
            "peerGatewayInterface": t.integer().optional(),
            "tunnelUrl": t.string().optional(),
            "localGatewayInterface": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnGatewayStatusTunnelOut"])
    types["VpnTunnelAggregatedListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["VpnTunnelAggregatedListIn"])
    types["VpnTunnelAggregatedListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnTunnelAggregatedListOut"])
    types["RegionInstanceGroupManagerUpdateInstanceConfigReqIn"] = t.struct(
        {
            "perInstanceConfigs": t.array(
                t.proxy(renames["PerInstanceConfigIn"])
            ).optional()
        }
    ).named(renames["RegionInstanceGroupManagerUpdateInstanceConfigReqIn"])
    types["RegionInstanceGroupManagerUpdateInstanceConfigReqOut"] = t.struct(
        {
            "perInstanceConfigs": t.array(
                t.proxy(renames["PerInstanceConfigOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagerUpdateInstanceConfigReqOut"])
    types["InterconnectListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["InterconnectIn"])).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["InterconnectListIn"])
    types["InterconnectListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["InterconnectOut"])).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectListOut"])
    types["QuotaIn"] = t.struct(
        {
            "limit": t.number().optional(),
            "usage": t.number().optional(),
            "owner": t.string().optional(),
            "metric": t.string().optional(),
        }
    ).named(renames["QuotaIn"])
    types["QuotaOut"] = t.struct(
        {
            "limit": t.number().optional(),
            "usage": t.number().optional(),
            "owner": t.string().optional(),
            "metric": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["QuotaOut"])
    types["StatefulPolicyPreservedStateDiskDeviceIn"] = t.struct(
        {"autoDelete": t.string().optional()}
    ).named(renames["StatefulPolicyPreservedStateDiskDeviceIn"])
    types["StatefulPolicyPreservedStateDiskDeviceOut"] = t.struct(
        {
            "autoDelete": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["StatefulPolicyPreservedStateDiskDeviceOut"])
    types["GRPCHealthCheckIn"] = t.struct(
        {
            "grpcServiceName": t.string().optional(),
            "portName": t.string().optional(),
            "port": t.integer().optional(),
            "portSpecification": t.string().optional(),
        }
    ).named(renames["GRPCHealthCheckIn"])
    types["GRPCHealthCheckOut"] = t.struct(
        {
            "grpcServiceName": t.string().optional(),
            "portName": t.string().optional(),
            "port": t.integer().optional(),
            "portSpecification": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["GRPCHealthCheckOut"])
    types["RegionInstanceGroupManagerPatchInstanceConfigReqIn"] = t.struct(
        {
            "perInstanceConfigs": t.array(
                t.proxy(renames["PerInstanceConfigIn"])
            ).optional()
        }
    ).named(renames["RegionInstanceGroupManagerPatchInstanceConfigReqIn"])
    types["RegionInstanceGroupManagerPatchInstanceConfigReqOut"] = t.struct(
        {
            "perInstanceConfigs": t.array(
                t.proxy(renames["PerInstanceConfigOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagerPatchInstanceConfigReqOut"])
    types["BulkInsertInstanceResourceIn"] = t.struct(
        {
            "perInstanceProperties": t.struct({"_": t.string().optional()}).optional(),
            "namePattern": t.string().optional(),
            "count": t.string().optional(),
            "instanceProperties": t.proxy(renames["InstancePropertiesIn"]).optional(),
            "locationPolicy": t.proxy(renames["LocationPolicyIn"]).optional(),
            "sourceInstanceTemplate": t.string().optional(),
            "minCount": t.string().optional(),
        }
    ).named(renames["BulkInsertInstanceResourceIn"])
    types["BulkInsertInstanceResourceOut"] = t.struct(
        {
            "perInstanceProperties": t.struct({"_": t.string().optional()}).optional(),
            "namePattern": t.string().optional(),
            "count": t.string().optional(),
            "instanceProperties": t.proxy(renames["InstancePropertiesOut"]).optional(),
            "locationPolicy": t.proxy(renames["LocationPolicyOut"]).optional(),
            "sourceInstanceTemplate": t.string().optional(),
            "minCount": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BulkInsertInstanceResourceOut"])
    types["DisksRemoveResourcePoliciesRequestIn"] = t.struct(
        {"resourcePolicies": t.array(t.string()).optional()}
    ).named(renames["DisksRemoveResourcePoliciesRequestIn"])
    types["DisksRemoveResourcePoliciesRequestOut"] = t.struct(
        {
            "resourcePolicies": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DisksRemoveResourcePoliciesRequestOut"])
    types["BackendServiceIn"] = t.struct(
        {
            "port": t.integer().optional(),
            "edgeSecurityPolicy": t.string().optional(),
            "portName": t.string().optional(),
            "outlierDetection": t.proxy(renames["OutlierDetectionIn"]).optional(),
            "customResponseHeaders": t.array(t.string()).optional(),
            "region": t.string().optional(),
            "name": t.string().optional(),
            "connectionTrackingPolicy": t.proxy(
                renames["BackendServiceConnectionTrackingPolicyIn"]
            ).optional(),
            "securitySettings": t.proxy(renames["SecuritySettingsIn"]).optional(),
            "subsetting": t.proxy(renames["SubsettingIn"]),
            "affinityCookieTtlSec": t.integer().optional(),
            "iap": t.proxy(renames["BackendServiceIAPIn"]).optional(),
            "kind": t.string().optional(),
            "localityLbPolicy": t.string().optional(),
            "customRequestHeaders": t.array(t.string()).optional(),
            "network": t.string().optional(),
            "id": t.string().optional(),
            "failoverPolicy": t.proxy(
                renames["BackendServiceFailoverPolicyIn"]
            ).optional(),
            "logConfig": t.proxy(renames["BackendServiceLogConfigIn"]).optional(),
            "selfLink": t.string().optional(),
            "protocol": t.string().optional(),
            "securityPolicy": t.string().optional(),
            "healthChecks": t.array(t.string()).optional(),
            "metadatas": t.struct({"_": t.string().optional()}).optional(),
            "circuitBreakers": t.proxy(renames["CircuitBreakersIn"]),
            "compressionMode": t.string().optional(),
            "backends": t.array(t.proxy(renames["BackendIn"])).optional(),
            "loadBalancingScheme": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "maxStreamDuration": t.proxy(renames["DurationIn"]).optional(),
            "cdnPolicy": t.proxy(renames["BackendServiceCdnPolicyIn"]).optional(),
            "sessionAffinity": t.string().optional(),
            "serviceBindings": t.array(t.string()).optional(),
            "localityLbPolicies": t.array(
                t.proxy(renames["BackendServiceLocalityLoadBalancingPolicyConfigIn"])
            ).optional(),
            "connectionDraining": t.proxy(renames["ConnectionDrainingIn"]),
            "fingerprint": t.string().optional(),
            "timeoutSec": t.integer().optional(),
            "description": t.string().optional(),
            "consistentHash": t.proxy(
                renames["ConsistentHashLoadBalancerSettingsIn"]
            ).optional(),
            "enableCDN": t.boolean().optional(),
        }
    ).named(renames["BackendServiceIn"])
    types["BackendServiceOut"] = t.struct(
        {
            "port": t.integer().optional(),
            "edgeSecurityPolicy": t.string().optional(),
            "portName": t.string().optional(),
            "outlierDetection": t.proxy(renames["OutlierDetectionOut"]).optional(),
            "customResponseHeaders": t.array(t.string()).optional(),
            "region": t.string().optional(),
            "name": t.string().optional(),
            "connectionTrackingPolicy": t.proxy(
                renames["BackendServiceConnectionTrackingPolicyOut"]
            ).optional(),
            "securitySettings": t.proxy(renames["SecuritySettingsOut"]).optional(),
            "subsetting": t.proxy(renames["SubsettingOut"]),
            "affinityCookieTtlSec": t.integer().optional(),
            "iap": t.proxy(renames["BackendServiceIAPOut"]).optional(),
            "kind": t.string().optional(),
            "localityLbPolicy": t.string().optional(),
            "customRequestHeaders": t.array(t.string()).optional(),
            "network": t.string().optional(),
            "id": t.string().optional(),
            "failoverPolicy": t.proxy(
                renames["BackendServiceFailoverPolicyOut"]
            ).optional(),
            "logConfig": t.proxy(renames["BackendServiceLogConfigOut"]).optional(),
            "selfLink": t.string().optional(),
            "protocol": t.string().optional(),
            "securityPolicy": t.string().optional(),
            "healthChecks": t.array(t.string()).optional(),
            "metadatas": t.struct({"_": t.string().optional()}).optional(),
            "circuitBreakers": t.proxy(renames["CircuitBreakersOut"]),
            "compressionMode": t.string().optional(),
            "backends": t.array(t.proxy(renames["BackendOut"])).optional(),
            "loadBalancingScheme": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "maxStreamDuration": t.proxy(renames["DurationOut"]).optional(),
            "cdnPolicy": t.proxy(renames["BackendServiceCdnPolicyOut"]).optional(),
            "sessionAffinity": t.string().optional(),
            "serviceBindings": t.array(t.string()).optional(),
            "localityLbPolicies": t.array(
                t.proxy(renames["BackendServiceLocalityLoadBalancingPolicyConfigOut"])
            ).optional(),
            "connectionDraining": t.proxy(renames["ConnectionDrainingOut"]),
            "fingerprint": t.string().optional(),
            "timeoutSec": t.integer().optional(),
            "description": t.string().optional(),
            "consistentHash": t.proxy(
                renames["ConsistentHashLoadBalancerSettingsOut"]
            ).optional(),
            "enableCDN": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceOut"])
    types["StatefulPolicyIn"] = t.struct(
        {"preservedState": t.proxy(renames["StatefulPolicyPreservedStateIn"])}
    ).named(renames["StatefulPolicyIn"])
    types["StatefulPolicyOut"] = t.struct(
        {
            "preservedState": t.proxy(renames["StatefulPolicyPreservedStateOut"]),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["StatefulPolicyOut"])
    types["TargetInstanceAggregatedListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
        }
    ).named(renames["TargetInstanceAggregatedListIn"])
    types["TargetInstanceAggregatedListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetInstanceAggregatedListOut"])
    types["NodeTemplateAggregatedListIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["NodeTemplateAggregatedListIn"])
    types["NodeTemplateAggregatedListOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeTemplateAggregatedListOut"])
    types["AcceleratorTypeAggregatedListIn"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["AcceleratorTypeAggregatedListIn"])
    types["AcceleratorTypeAggregatedListOut"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AcceleratorTypeAggregatedListOut"])
    types["NetworkEndpointGroupIn"] = t.struct(
        {
            "zone": t.string().optional(),
            "description": t.string().optional(),
            "annotations": t.struct({"_": t.string().optional()}).optional(),
            "network": t.string().optional(),
            "kind": t.string().optional(),
            "appEngine": t.proxy(renames["NetworkEndpointGroupAppEngineIn"]).optional(),
            "name": t.string().optional(),
            "defaultPort": t.integer().optional(),
            "selfLink": t.string().optional(),
            "networkEndpointType": t.string().optional(),
            "size": t.integer().optional(),
            "creationTimestamp": t.string().optional(),
            "cloudRun": t.proxy(renames["NetworkEndpointGroupCloudRunIn"]).optional(),
            "subnetwork": t.string().optional(),
            "pscData": t.proxy(renames["NetworkEndpointGroupPscDataIn"]),
            "pscTargetService": t.string().optional(),
            "region": t.string().optional(),
            "cloudFunction": t.proxy(
                renames["NetworkEndpointGroupCloudFunctionIn"]
            ).optional(),
            "id": t.string().optional(),
        }
    ).named(renames["NetworkEndpointGroupIn"])
    types["NetworkEndpointGroupOut"] = t.struct(
        {
            "zone": t.string().optional(),
            "description": t.string().optional(),
            "annotations": t.struct({"_": t.string().optional()}).optional(),
            "network": t.string().optional(),
            "kind": t.string().optional(),
            "appEngine": t.proxy(
                renames["NetworkEndpointGroupAppEngineOut"]
            ).optional(),
            "name": t.string().optional(),
            "defaultPort": t.integer().optional(),
            "selfLink": t.string().optional(),
            "networkEndpointType": t.string().optional(),
            "size": t.integer().optional(),
            "creationTimestamp": t.string().optional(),
            "cloudRun": t.proxy(renames["NetworkEndpointGroupCloudRunOut"]).optional(),
            "subnetwork": t.string().optional(),
            "pscData": t.proxy(renames["NetworkEndpointGroupPscDataOut"]),
            "pscTargetService": t.string().optional(),
            "region": t.string().optional(),
            "cloudFunction": t.proxy(
                renames["NetworkEndpointGroupCloudFunctionOut"]
            ).optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointGroupOut"])
    types["TargetSslProxiesSetCertificateMapRequestIn"] = t.struct(
        {"certificateMap": t.string().optional()}
    ).named(renames["TargetSslProxiesSetCertificateMapRequestIn"])
    types["TargetSslProxiesSetCertificateMapRequestOut"] = t.struct(
        {
            "certificateMap": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetSslProxiesSetCertificateMapRequestOut"])
    types["HttpsHealthCheckListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["HttpsHealthCheckIn"])).optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["HttpsHealthCheckListIn"])
    types["HttpsHealthCheckListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["HttpsHealthCheckOut"])).optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpsHealthCheckListOut"])
    types["ShieldedInstanceIdentityEntryIn"] = t.struct(
        {"ekCert": t.string().optional(), "ekPub": t.string().optional()}
    ).named(renames["ShieldedInstanceIdentityEntryIn"])
    types["ShieldedInstanceIdentityEntryOut"] = t.struct(
        {
            "ekCert": t.string().optional(),
            "ekPub": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ShieldedInstanceIdentityEntryOut"])
    types["SubnetworkListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["SubnetworkIn"])).optional(),
        }
    ).named(renames["SubnetworkListIn"])
    types["SubnetworkListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["SubnetworkOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SubnetworkListOut"])
    types["SecurityPolicyIn"] = t.struct(
        {
            "adaptiveProtectionConfig": t.proxy(
                renames["SecurityPolicyAdaptiveProtectionConfigIn"]
            ),
            "recaptchaOptionsConfig": t.proxy(
                renames["SecurityPolicyRecaptchaOptionsConfigIn"]
            ),
            "id": t.string().optional(),
            "type": t.string().optional(),
            "description": t.string().optional(),
            "advancedOptionsConfig": t.proxy(
                renames["SecurityPolicyAdvancedOptionsConfigIn"]
            ),
            "labelFingerprint": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "fingerprint": t.string().optional(),
            "name": t.string().optional(),
            "region": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "ddosProtectionConfig": t.proxy(
                renames["SecurityPolicyDdosProtectionConfigIn"]
            ),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "rules": t.array(t.proxy(renames["SecurityPolicyRuleIn"])).optional(),
        }
    ).named(renames["SecurityPolicyIn"])
    types["SecurityPolicyOut"] = t.struct(
        {
            "adaptiveProtectionConfig": t.proxy(
                renames["SecurityPolicyAdaptiveProtectionConfigOut"]
            ),
            "recaptchaOptionsConfig": t.proxy(
                renames["SecurityPolicyRecaptchaOptionsConfigOut"]
            ),
            "id": t.string().optional(),
            "type": t.string().optional(),
            "description": t.string().optional(),
            "advancedOptionsConfig": t.proxy(
                renames["SecurityPolicyAdvancedOptionsConfigOut"]
            ),
            "labelFingerprint": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "fingerprint": t.string().optional(),
            "name": t.string().optional(),
            "region": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "ddosProtectionConfig": t.proxy(
                renames["SecurityPolicyDdosProtectionConfigOut"]
            ),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "rules": t.array(t.proxy(renames["SecurityPolicyRuleOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyOut"])
    types["FixedOrPercentIn"] = t.struct(
        {
            "percent": t.integer().optional(),
            "fixed": t.integer().optional(),
            "calculated": t.integer().optional(),
        }
    ).named(renames["FixedOrPercentIn"])
    types["FixedOrPercentOut"] = t.struct(
        {
            "percent": t.integer().optional(),
            "fixed": t.integer().optional(),
            "calculated": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["FixedOrPercentOut"])
    types["InstanceGroupsSetNamedPortsRequestIn"] = t.struct(
        {
            "fingerprint": t.string().optional(),
            "namedPorts": t.array(t.proxy(renames["NamedPortIn"])).optional(),
        }
    ).named(renames["InstanceGroupsSetNamedPortsRequestIn"])
    types["InstanceGroupsSetNamedPortsRequestOut"] = t.struct(
        {
            "fingerprint": t.string().optional(),
            "namedPorts": t.array(t.proxy(renames["NamedPortOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupsSetNamedPortsRequestOut"])
    types["AcceleratorTypesScopedListIn"] = t.struct(
        {
            "acceleratorTypes": t.array(
                t.proxy(renames["AcceleratorTypeIn"])
            ).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["AcceleratorTypesScopedListIn"])
    types["AcceleratorTypesScopedListOut"] = t.struct(
        {
            "acceleratorTypes": t.array(
                t.proxy(renames["AcceleratorTypeOut"])
            ).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AcceleratorTypesScopedListOut"])
    types["NodeGroupsSimulateMaintenanceEventRequestIn"] = t.struct(
        {"nodes": t.array(t.string()).optional()}
    ).named(renames["NodeGroupsSimulateMaintenanceEventRequestIn"])
    types["NodeGroupsSimulateMaintenanceEventRequestOut"] = t.struct(
        {
            "nodes": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeGroupsSimulateMaintenanceEventRequestOut"])
    types["NetworkEndpointGroupPscDataIn"] = t.struct(
        {
            "pscConnectionId": t.string().optional(),
            "pscConnectionStatus": t.string().optional(),
            "consumerPscAddress": t.string().optional(),
        }
    ).named(renames["NetworkEndpointGroupPscDataIn"])
    types["NetworkEndpointGroupPscDataOut"] = t.struct(
        {
            "pscConnectionId": t.string().optional(),
            "pscConnectionStatus": t.string().optional(),
            "consumerPscAddress": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointGroupPscDataOut"])
    types["ProjectsSetDefaultNetworkTierRequestIn"] = t.struct(
        {"networkTier": t.string().optional()}
    ).named(renames["ProjectsSetDefaultNetworkTierRequestIn"])
    types["ProjectsSetDefaultNetworkTierRequestOut"] = t.struct(
        {
            "networkTier": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ProjectsSetDefaultNetworkTierRequestOut"])
    types["RouterBgpPeerCustomLearnedIpRangeIn"] = t.struct(
        {"range": t.string().optional()}
    ).named(renames["RouterBgpPeerCustomLearnedIpRangeIn"])
    types["RouterBgpPeerCustomLearnedIpRangeOut"] = t.struct(
        {
            "range": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterBgpPeerCustomLearnedIpRangeOut"])
    types["DiskTypeAggregatedListIn"] = t.struct(
        {
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["DiskTypeAggregatedListIn"])
    types["DiskTypeAggregatedListOut"] = t.struct(
        {
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DiskTypeAggregatedListOut"])
    types["InstanceGroupManagersSetInstanceTemplateRequestIn"] = t.struct(
        {"instanceTemplate": t.string().optional()}
    ).named(renames["InstanceGroupManagersSetInstanceTemplateRequestIn"])
    types["InstanceGroupManagersSetInstanceTemplateRequestOut"] = t.struct(
        {
            "instanceTemplate": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersSetInstanceTemplateRequestOut"])
    types["DiskTypesScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "diskTypes": t.array(t.proxy(renames["DiskTypeIn"])).optional(),
        }
    ).named(renames["DiskTypesScopedListIn"])
    types["DiskTypesScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "diskTypes": t.array(t.proxy(renames["DiskTypeOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DiskTypesScopedListOut"])
    types["InterconnectLocationRegionInfoIn"] = t.struct(
        {
            "expectedRttMs": t.string().optional(),
            "region": t.string().optional(),
            "locationPresence": t.string().optional(),
        }
    ).named(renames["InterconnectLocationRegionInfoIn"])
    types["InterconnectLocationRegionInfoOut"] = t.struct(
        {
            "expectedRttMs": t.string().optional(),
            "region": t.string().optional(),
            "locationPresence": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectLocationRegionInfoOut"])
    types["ProjectsGetXpnResourcesIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "resources": t.array(t.proxy(renames["XpnResourceIdIn"])).optional(),
        }
    ).named(renames["ProjectsGetXpnResourcesIn"])
    types["ProjectsGetXpnResourcesOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "resources": t.array(t.proxy(renames["XpnResourceIdOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ProjectsGetXpnResourcesOut"])
    types["ScreenshotIn"] = t.struct(
        {"kind": t.string().optional(), "contents": t.string().optional()}
    ).named(renames["ScreenshotIn"])
    types["ScreenshotOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "contents": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ScreenshotOut"])
    types["HttpHealthCheckIn"] = t.struct(
        {
            "unhealthyThreshold": t.integer().optional(),
            "name": t.string().optional(),
            "id": t.string().optional(),
            "timeoutSec": t.integer().optional(),
            "host": t.string().optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "requestPath": t.string().optional(),
            "checkIntervalSec": t.integer().optional(),
            "selfLink": t.string().optional(),
            "healthyThreshold": t.integer().optional(),
            "port": t.integer().optional(),
        }
    ).named(renames["HttpHealthCheckIn"])
    types["HttpHealthCheckOut"] = t.struct(
        {
            "unhealthyThreshold": t.integer().optional(),
            "name": t.string().optional(),
            "id": t.string().optional(),
            "timeoutSec": t.integer().optional(),
            "host": t.string().optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "requestPath": t.string().optional(),
            "checkIntervalSec": t.integer().optional(),
            "selfLink": t.string().optional(),
            "healthyThreshold": t.integer().optional(),
            "port": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpHealthCheckOut"])
    types["RoutersPreviewResponseIn"] = t.struct(
        {"resource": t.proxy(renames["RouterIn"]).optional()}
    ).named(renames["RoutersPreviewResponseIn"])
    types["RoutersPreviewResponseOut"] = t.struct(
        {
            "resource": t.proxy(renames["RouterOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RoutersPreviewResponseOut"])
    types["ServiceAccountIn"] = t.struct(
        {"scopes": t.array(t.string()).optional(), "email": t.string().optional()}
    ).named(renames["ServiceAccountIn"])
    types["ServiceAccountOut"] = t.struct(
        {
            "scopes": t.array(t.string()).optional(),
            "email": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ServiceAccountOut"])
    types["RouterAggregatedListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "unreachables": t.array(t.string()).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["RouterAggregatedListIn"])
    types["RouterAggregatedListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "unreachables": t.array(t.string()).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterAggregatedListOut"])
    types["PacketMirroringForwardingRuleInfoIn"] = t.struct(
        {"canonicalUrl": t.string().optional(), "url": t.string().optional()}
    ).named(renames["PacketMirroringForwardingRuleInfoIn"])
    types["PacketMirroringForwardingRuleInfoOut"] = t.struct(
        {
            "canonicalUrl": t.string().optional(),
            "url": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PacketMirroringForwardingRuleInfoOut"])
    types["HealthCheckIn"] = t.struct(
        {
            "creationTimestamp": t.string().optional(),
            "type": t.string().optional(),
            "healthyThreshold": t.integer().optional(),
            "tcpHealthCheck": t.proxy(renames["TCPHealthCheckIn"]),
            "logConfig": t.proxy(renames["HealthCheckLogConfigIn"]).optional(),
            "sslHealthCheck": t.proxy(renames["SSLHealthCheckIn"]),
            "unhealthyThreshold": t.integer().optional(),
            "selfLink": t.string().optional(),
            "name": t.string().optional(),
            "timeoutSec": t.integer().optional(),
            "httpHealthCheck": t.proxy(renames["HTTPHealthCheckIn"]),
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "region": t.string().optional(),
            "checkIntervalSec": t.integer().optional(),
            "id": t.string().optional(),
            "http2HealthCheck": t.proxy(renames["HTTP2HealthCheckIn"]),
            "grpcHealthCheck": t.proxy(renames["GRPCHealthCheckIn"]),
            "httpsHealthCheck": t.proxy(renames["HTTPSHealthCheckIn"]),
        }
    ).named(renames["HealthCheckIn"])
    types["HealthCheckOut"] = t.struct(
        {
            "creationTimestamp": t.string().optional(),
            "type": t.string().optional(),
            "healthyThreshold": t.integer().optional(),
            "tcpHealthCheck": t.proxy(renames["TCPHealthCheckOut"]),
            "logConfig": t.proxy(renames["HealthCheckLogConfigOut"]).optional(),
            "sslHealthCheck": t.proxy(renames["SSLHealthCheckOut"]),
            "unhealthyThreshold": t.integer().optional(),
            "selfLink": t.string().optional(),
            "name": t.string().optional(),
            "timeoutSec": t.integer().optional(),
            "httpHealthCheck": t.proxy(renames["HTTPHealthCheckOut"]),
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "region": t.string().optional(),
            "checkIntervalSec": t.integer().optional(),
            "id": t.string().optional(),
            "http2HealthCheck": t.proxy(renames["HTTP2HealthCheckOut"]),
            "grpcHealthCheck": t.proxy(renames["GRPCHealthCheckOut"]),
            "httpsHealthCheck": t.proxy(renames["HTTPSHealthCheckOut"]),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HealthCheckOut"])
    types["SecurityPoliciesAggregatedListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "etag": t.string(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["SecurityPoliciesAggregatedListIn"])
    types["SecurityPoliciesAggregatedListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "etag": t.string(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPoliciesAggregatedListOut"])
    types["ForwardingRuleIn"] = t.struct(
        {
            "baseForwardingRule": t.string().optional(),
            "serviceName": t.string().optional(),
            "IPProtocol": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "description": t.string().optional(),
            "noAutomateDnsZone": t.boolean().optional(),
            "target": t.string().optional(),
            "id": t.string().optional(),
            "allPorts": t.boolean().optional(),
            "portRange": t.string().optional(),
            "fingerprint": t.string().optional(),
            "region": t.string().optional(),
            "ports": t.array(t.string()).optional(),
            "networkTier": t.string().optional(),
            "ipVersion": t.string().optional(),
            "serviceLabel": t.string().optional(),
            "allowPscGlobalAccess": t.boolean().optional(),
            "loadBalancingScheme": t.string().optional(),
            "IPAddress": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "pscConnectionStatus": t.string(),
            "serviceDirectoryRegistrations": t.array(
                t.proxy(renames["ForwardingRuleServiceDirectoryRegistrationIn"])
            ).optional(),
            "creationTimestamp": t.string().optional(),
            "isMirroringCollector": t.boolean().optional(),
            "labelFingerprint": t.string().optional(),
            "subnetwork": t.string().optional(),
            "pscConnectionId": t.string().optional(),
            "backendService": t.string().optional(),
            "sourceIpRanges": t.array(t.string()).optional(),
            "allowGlobalAccess": t.boolean().optional(),
            "network": t.string().optional(),
            "name": t.string().optional(),
            "metadataFilters": t.array(t.proxy(renames["MetadataFilterIn"])).optional(),
        }
    ).named(renames["ForwardingRuleIn"])
    types["ForwardingRuleOut"] = t.struct(
        {
            "baseForwardingRule": t.string().optional(),
            "serviceName": t.string().optional(),
            "IPProtocol": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "description": t.string().optional(),
            "noAutomateDnsZone": t.boolean().optional(),
            "target": t.string().optional(),
            "id": t.string().optional(),
            "allPorts": t.boolean().optional(),
            "portRange": t.string().optional(),
            "fingerprint": t.string().optional(),
            "region": t.string().optional(),
            "ports": t.array(t.string()).optional(),
            "networkTier": t.string().optional(),
            "ipVersion": t.string().optional(),
            "serviceLabel": t.string().optional(),
            "allowPscGlobalAccess": t.boolean().optional(),
            "loadBalancingScheme": t.string().optional(),
            "IPAddress": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "pscConnectionStatus": t.string(),
            "serviceDirectoryRegistrations": t.array(
                t.proxy(renames["ForwardingRuleServiceDirectoryRegistrationOut"])
            ).optional(),
            "creationTimestamp": t.string().optional(),
            "isMirroringCollector": t.boolean().optional(),
            "labelFingerprint": t.string().optional(),
            "subnetwork": t.string().optional(),
            "pscConnectionId": t.string().optional(),
            "backendService": t.string().optional(),
            "sourceIpRanges": t.array(t.string()).optional(),
            "allowGlobalAccess": t.boolean().optional(),
            "network": t.string().optional(),
            "name": t.string().optional(),
            "metadataFilters": t.array(
                t.proxy(renames["MetadataFilterOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ForwardingRuleOut"])
    types["ImageIn"] = t.struct(
        {
            "sourceType": t.string().optional(),
            "sourceSnapshotEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyIn"]
            ).optional(),
            "sourceDiskEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyIn"]
            ).optional(),
            "sourceDiskId": t.string().optional(),
            "id": t.string().optional(),
            "shieldedInstanceInitialState": t.proxy(
                renames["InitialStateConfigIn"]
            ).optional(),
            "kind": t.string().optional(),
            "labelFingerprint": t.string().optional(),
            "description": t.string().optional(),
            "family": t.string().optional(),
            "status": t.string().optional(),
            "rawDisk": t.struct(
                {
                    "sha1Checksum": t.string().optional(),
                    "containerType": t.string().optional(),
                    "source": t.string().optional(),
                }
            ).optional(),
            "name": t.string().optional(),
            "storageLocations": t.array(t.string()).optional(),
            "sourceSnapshot": t.string().optional(),
            "licenseCodes": t.array(t.string()).optional(),
            "sourceImageId": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "diskSizeGb": t.string().optional(),
            "selfLink": t.string().optional(),
            "sourceImage": t.string().optional(),
            "guestOsFeatures": t.array(t.proxy(renames["GuestOsFeatureIn"])).optional(),
            "licenses": t.array(t.string()).optional(),
            "architecture": t.string().optional(),
            "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
            "sourceDisk": t.string().optional(),
            "sourceSnapshotId": t.string().optional(),
            "imageEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyIn"]
            ).optional(),
            "archiveSizeBytes": t.string().optional(),
            "satisfiesPzs": t.boolean().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "sourceImageEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyIn"]
            ).optional(),
        }
    ).named(renames["ImageIn"])
    types["ImageOut"] = t.struct(
        {
            "sourceType": t.string().optional(),
            "sourceSnapshotEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "sourceDiskEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "sourceDiskId": t.string().optional(),
            "id": t.string().optional(),
            "shieldedInstanceInitialState": t.proxy(
                renames["InitialStateConfigOut"]
            ).optional(),
            "kind": t.string().optional(),
            "labelFingerprint": t.string().optional(),
            "description": t.string().optional(),
            "family": t.string().optional(),
            "status": t.string().optional(),
            "rawDisk": t.struct(
                {
                    "sha1Checksum": t.string().optional(),
                    "containerType": t.string().optional(),
                    "source": t.string().optional(),
                }
            ).optional(),
            "name": t.string().optional(),
            "storageLocations": t.array(t.string()).optional(),
            "sourceSnapshot": t.string().optional(),
            "licenseCodes": t.array(t.string()).optional(),
            "sourceImageId": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "diskSizeGb": t.string().optional(),
            "selfLink": t.string().optional(),
            "sourceImage": t.string().optional(),
            "guestOsFeatures": t.array(
                t.proxy(renames["GuestOsFeatureOut"])
            ).optional(),
            "licenses": t.array(t.string()).optional(),
            "architecture": t.string().optional(),
            "deprecated": t.proxy(renames["DeprecationStatusOut"]).optional(),
            "sourceDisk": t.string().optional(),
            "sourceSnapshotId": t.string().optional(),
            "imageEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "archiveSizeBytes": t.string().optional(),
            "satisfiesPzs": t.boolean().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "sourceImageEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ImageOut"])
    types["ShieldedInstanceConfigIn"] = t.struct(
        {
            "enableSecureBoot": t.boolean().optional(),
            "enableVtpm": t.boolean().optional(),
            "enableIntegrityMonitoring": t.boolean().optional(),
        }
    ).named(renames["ShieldedInstanceConfigIn"])
    types["ShieldedInstanceConfigOut"] = t.struct(
        {
            "enableSecureBoot": t.boolean().optional(),
            "enableVtpm": t.boolean().optional(),
            "enableIntegrityMonitoring": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ShieldedInstanceConfigOut"])
    types["ZoneSetLabelsRequestIn"] = t.struct(
        {
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "labelFingerprint": t.string().optional(),
        }
    ).named(renames["ZoneSetLabelsRequestIn"])
    types["ZoneSetLabelsRequestOut"] = t.struct(
        {
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "labelFingerprint": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ZoneSetLabelsRequestOut"])
    types["NetworkEndpointWithHealthStatusIn"] = t.struct(
        {
            "healths": t.array(
                t.proxy(renames["HealthStatusForNetworkEndpointIn"])
            ).optional(),
            "networkEndpoint": t.proxy(renames["NetworkEndpointIn"]).optional(),
        }
    ).named(renames["NetworkEndpointWithHealthStatusIn"])
    types["NetworkEndpointWithHealthStatusOut"] = t.struct(
        {
            "healths": t.array(
                t.proxy(renames["HealthStatusForNetworkEndpointOut"])
            ).optional(),
            "networkEndpoint": t.proxy(renames["NetworkEndpointOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointWithHealthStatusOut"])
    types["MetadataFilterLabelMatchIn"] = t.struct(
        {"value": t.string().optional(), "name": t.string().optional()}
    ).named(renames["MetadataFilterLabelMatchIn"])
    types["MetadataFilterLabelMatchOut"] = t.struct(
        {
            "value": t.string().optional(),
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["MetadataFilterLabelMatchOut"])
    types["RegionUrlMapsValidateRequestIn"] = t.struct(
        {"resource": t.proxy(renames["UrlMapIn"]).optional()}
    ).named(renames["RegionUrlMapsValidateRequestIn"])
    types["RegionUrlMapsValidateRequestOut"] = t.struct(
        {
            "resource": t.proxy(renames["UrlMapOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionUrlMapsValidateRequestOut"])
    types["RegionDisksAddResourcePoliciesRequestIn"] = t.struct(
        {"resourcePolicies": t.array(t.string()).optional()}
    ).named(renames["RegionDisksAddResourcePoliciesRequestIn"])
    types["RegionDisksAddResourcePoliciesRequestOut"] = t.struct(
        {
            "resourcePolicies": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionDisksAddResourcePoliciesRequestOut"])
    types["PublicAdvertisedPrefixListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["PublicAdvertisedPrefixIn"])).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["PublicAdvertisedPrefixListIn"])
    types["PublicAdvertisedPrefixListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["PublicAdvertisedPrefixOut"])).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PublicAdvertisedPrefixListOut"])
    types["GuestOsFeatureIn"] = t.struct({"type": t.string().optional()}).named(
        renames["GuestOsFeatureIn"]
    )
    types["GuestOsFeatureOut"] = t.struct(
        {
            "type": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["GuestOsFeatureOut"])
    types["SecuritySettingsIn"] = t.struct(
        {
            "subjectAltNames": t.array(t.string()).optional(),
            "clientTlsPolicy": t.string().optional(),
        }
    ).named(renames["SecuritySettingsIn"])
    types["SecuritySettingsOut"] = t.struct(
        {
            "subjectAltNames": t.array(t.string()).optional(),
            "clientTlsPolicy": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecuritySettingsOut"])
    types["ExchangedPeeringRouteIn"] = t.struct(
        {
            "priority": t.integer().optional(),
            "imported": t.boolean().optional(),
            "type": t.string().optional(),
            "destRange": t.string().optional(),
            "nextHopRegion": t.string().optional(),
        }
    ).named(renames["ExchangedPeeringRouteIn"])
    types["ExchangedPeeringRouteOut"] = t.struct(
        {
            "priority": t.integer().optional(),
            "imported": t.boolean().optional(),
            "type": t.string().optional(),
            "destRange": t.string().optional(),
            "nextHopRegion": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ExchangedPeeringRouteOut"])
    types["InstanceGroupManagersCreateInstancesRequestIn"] = t.struct(
        {"instances": t.array(t.proxy(renames["PerInstanceConfigIn"])).optional()}
    ).named(renames["InstanceGroupManagersCreateInstancesRequestIn"])
    types["InstanceGroupManagersCreateInstancesRequestOut"] = t.struct(
        {
            "instances": t.array(t.proxy(renames["PerInstanceConfigOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersCreateInstancesRequestOut"])
    types["SslPolicyIn"] = t.struct(
        {
            "description": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "warnings": t.array(
                t.struct(
                    {
                        "message": t.string().optional(),
                        "data": t.array(
                            t.struct(
                                {
                                    "value": t.string().optional(),
                                    "key": t.string().optional(),
                                }
                            )
                        ).optional(),
                        "code": t.string().optional(),
                    }
                )
            ).optional(),
            "profile": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "region": t.string().optional(),
            "customFeatures": t.array(t.string()).optional(),
            "name": t.string().optional(),
            "fingerprint": t.string().optional(),
            "selfLink": t.string().optional(),
            "enabledFeatures": t.array(t.string()).optional(),
            "minTlsVersion": t.string().optional(),
        }
    ).named(renames["SslPolicyIn"])
    types["SslPolicyOut"] = t.struct(
        {
            "description": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "warnings": t.array(
                t.struct(
                    {
                        "message": t.string().optional(),
                        "data": t.array(
                            t.struct(
                                {
                                    "value": t.string().optional(),
                                    "key": t.string().optional(),
                                }
                            )
                        ).optional(),
                        "code": t.string().optional(),
                    }
                )
            ).optional(),
            "profile": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "region": t.string().optional(),
            "customFeatures": t.array(t.string()).optional(),
            "name": t.string().optional(),
            "fingerprint": t.string().optional(),
            "selfLink": t.string().optional(),
            "enabledFeatures": t.array(t.string()).optional(),
            "minTlsVersion": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SslPolicyOut"])
    types["RouterBgpPeerIn"] = t.struct(
        {
            "advertisedGroups": t.array(t.string()).optional(),
            "customLearnedIpRanges": t.array(
                t.proxy(renames["RouterBgpPeerCustomLearnedIpRangeIn"])
            ).optional(),
            "peerAsn": t.integer().optional(),
            "md5AuthenticationKeyName": t.string().optional(),
            "ipAddress": t.string().optional(),
            "ipv6NexthopAddress": t.string().optional(),
            "peerIpv6NexthopAddress": t.string().optional(),
            "advertisedRoutePriority": t.integer().optional(),
            "enableIpv6": t.boolean().optional(),
            "name": t.string().optional(),
            "interfaceName": t.string().optional(),
            "advertiseMode": t.string().optional(),
            "peerIpAddress": t.string().optional(),
            "routerApplianceInstance": t.string().optional(),
            "enable": t.string().optional(),
            "customLearnedRoutePriority": t.integer().optional(),
            "advertisedIpRanges": t.array(
                t.proxy(renames["RouterAdvertisedIpRangeIn"])
            ).optional(),
            "managementType": t.string().optional(),
            "bfd": t.proxy(renames["RouterBgpPeerBfdIn"]).optional(),
        }
    ).named(renames["RouterBgpPeerIn"])
    types["RouterBgpPeerOut"] = t.struct(
        {
            "advertisedGroups": t.array(t.string()).optional(),
            "customLearnedIpRanges": t.array(
                t.proxy(renames["RouterBgpPeerCustomLearnedIpRangeOut"])
            ).optional(),
            "peerAsn": t.integer().optional(),
            "md5AuthenticationKeyName": t.string().optional(),
            "ipAddress": t.string().optional(),
            "ipv6NexthopAddress": t.string().optional(),
            "peerIpv6NexthopAddress": t.string().optional(),
            "advertisedRoutePriority": t.integer().optional(),
            "enableIpv6": t.boolean().optional(),
            "name": t.string().optional(),
            "interfaceName": t.string().optional(),
            "advertiseMode": t.string().optional(),
            "peerIpAddress": t.string().optional(),
            "routerApplianceInstance": t.string().optional(),
            "enable": t.string().optional(),
            "customLearnedRoutePriority": t.integer().optional(),
            "advertisedIpRanges": t.array(
                t.proxy(renames["RouterAdvertisedIpRangeOut"])
            ).optional(),
            "managementType": t.string().optional(),
            "bfd": t.proxy(renames["RouterBgpPeerBfdOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterBgpPeerOut"])
    types["GuestAttributesEntryIn"] = t.struct(
        {
            "namespace": t.string().optional(),
            "value": t.string().optional(),
            "key": t.string().optional(),
        }
    ).named(renames["GuestAttributesEntryIn"])
    types["GuestAttributesEntryOut"] = t.struct(
        {
            "namespace": t.string().optional(),
            "value": t.string().optional(),
            "key": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["GuestAttributesEntryOut"])
    types["CommitmentIn"] = t.struct(
        {
            "statusMessage": t.string().optional(),
            "reservations": t.array(t.proxy(renames["ReservationIn"])).optional(),
            "selfLink": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "region": t.string().optional(),
            "endTimestamp": t.string().optional(),
            "splitSourceCommitment": t.string().optional(),
            "autoRenew": t.boolean().optional(),
            "mergeSourceCommitments": t.array(t.string()).optional(),
            "startTimestamp": t.string().optional(),
            "category": t.string().optional(),
            "kind": t.string().optional(),
            "plan": t.string().optional(),
            "type": t.string().optional(),
            "name": t.string().optional(),
            "description": t.string().optional(),
            "resources": t.array(t.proxy(renames["ResourceCommitmentIn"])).optional(),
            "status": t.string().optional(),
            "licenseResource": t.proxy(
                renames["LicenseResourceCommitmentIn"]
            ).optional(),
            "id": t.string().optional(),
        }
    ).named(renames["CommitmentIn"])
    types["CommitmentOut"] = t.struct(
        {
            "statusMessage": t.string().optional(),
            "reservations": t.array(t.proxy(renames["ReservationOut"])).optional(),
            "selfLink": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "region": t.string().optional(),
            "endTimestamp": t.string().optional(),
            "splitSourceCommitment": t.string().optional(),
            "autoRenew": t.boolean().optional(),
            "mergeSourceCommitments": t.array(t.string()).optional(),
            "startTimestamp": t.string().optional(),
            "category": t.string().optional(),
            "kind": t.string().optional(),
            "plan": t.string().optional(),
            "type": t.string().optional(),
            "name": t.string().optional(),
            "description": t.string().optional(),
            "resources": t.array(t.proxy(renames["ResourceCommitmentOut"])).optional(),
            "status": t.string().optional(),
            "licenseResource": t.proxy(
                renames["LicenseResourceCommitmentOut"]
            ).optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["CommitmentOut"])
    types["ResourcePolicyInstanceSchedulePolicyIn"] = t.struct(
        {
            "timeZone": t.string().optional(),
            "vmStopSchedule": t.proxy(
                renames["ResourcePolicyInstanceSchedulePolicyScheduleIn"]
            ).optional(),
            "expirationTime": t.string().optional(),
            "startTime": t.string().optional(),
            "vmStartSchedule": t.proxy(
                renames["ResourcePolicyInstanceSchedulePolicyScheduleIn"]
            ).optional(),
        }
    ).named(renames["ResourcePolicyInstanceSchedulePolicyIn"])
    types["ResourcePolicyInstanceSchedulePolicyOut"] = t.struct(
        {
            "timeZone": t.string().optional(),
            "vmStopSchedule": t.proxy(
                renames["ResourcePolicyInstanceSchedulePolicyScheduleOut"]
            ).optional(),
            "expirationTime": t.string().optional(),
            "startTime": t.string().optional(),
            "vmStartSchedule": t.proxy(
                renames["ResourcePolicyInstanceSchedulePolicyScheduleOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicyInstanceSchedulePolicyOut"])
    types["NetworkEndpointGroupCloudFunctionIn"] = t.struct(
        {"function": t.string().optional(), "urlMask": t.string().optional()}
    ).named(renames["NetworkEndpointGroupCloudFunctionIn"])
    types["NetworkEndpointGroupCloudFunctionOut"] = t.struct(
        {
            "function": t.string().optional(),
            "urlMask": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointGroupCloudFunctionOut"])
    types["ZoneIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "availableCpuPlatforms": t.array(t.string()).optional(),
            "creationTimestamp": t.string().optional(),
            "region": t.string().optional(),
            "status": t.string().optional(),
            "description": t.string().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
            "selfLink": t.string().optional(),
            "supportsPzs": t.boolean().optional(),
        }
    ).named(renames["ZoneIn"])
    types["ZoneOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "availableCpuPlatforms": t.array(t.string()).optional(),
            "creationTimestamp": t.string().optional(),
            "region": t.string().optional(),
            "status": t.string().optional(),
            "description": t.string().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "deprecated": t.proxy(renames["DeprecationStatusOut"]).optional(),
            "selfLink": t.string().optional(),
            "supportsPzs": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ZoneOut"])
    types["NodeTemplateListIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["NodeTemplateIn"])).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["NodeTemplateListIn"])
    types["NodeTemplateListOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["NodeTemplateOut"])).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeTemplateListOut"])
    types["HTTPSHealthCheckIn"] = t.struct(
        {
            "host": t.string().optional(),
            "port": t.integer().optional(),
            "portSpecification": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "response": t.string().optional(),
            "requestPath": t.string().optional(),
            "portName": t.string().optional(),
        }
    ).named(renames["HTTPSHealthCheckIn"])
    types["HTTPSHealthCheckOut"] = t.struct(
        {
            "host": t.string().optional(),
            "port": t.integer().optional(),
            "portSpecification": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "response": t.string().optional(),
            "requestPath": t.string().optional(),
            "portName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HTTPSHealthCheckOut"])
    types["InstancesSetNameRequestIn"] = t.struct(
        {"name": t.string().optional(), "currentName": t.string().optional()}
    ).named(renames["InstancesSetNameRequestIn"])
    types["InstancesSetNameRequestOut"] = t.struct(
        {
            "name": t.string().optional(),
            "currentName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstancesSetNameRequestOut"])
    types["Int64RangeMatchIn"] = t.struct(
        {"rangeStart": t.string().optional(), "rangeEnd": t.string().optional()}
    ).named(renames["Int64RangeMatchIn"])
    types["Int64RangeMatchOut"] = t.struct(
        {
            "rangeStart": t.string().optional(),
            "rangeEnd": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["Int64RangeMatchOut"])
    types["OperationIn"] = t.struct(
        {
            "progress": t.integer().optional(),
            "endTime": t.string().optional(),
            "targetLink": t.string().optional(),
            "targetId": t.string().optional(),
            "description": t.string().optional(),
            "operationGroupId": t.string().optional(),
            "error": t.struct(
                {
                    "errors": t.array(
                        t.struct(
                            {
                                "errorDetails": t.array(
                                    t.struct(
                                        {
                                            "quotaInfo": t.proxy(
                                                renames["QuotaExceededInfoIn"]
                                            ),
                                            "help": t.proxy(renames["HelpIn"]),
                                            "errorInfo": t.proxy(
                                                renames["ErrorInfoIn"]
                                            ),
                                            "localizedMessage": t.proxy(
                                                renames["LocalizedMessageIn"]
                                            ),
                                        }
                                    )
                                ).optional(),
                                "message": t.string().optional(),
                                "location": t.string().optional(),
                                "code": t.string().optional(),
                            }
                        )
                    ).optional()
                }
            ).optional(),
            "region": t.string().optional(),
            "operationType": t.string().optional(),
            "name": t.string().optional(),
            "insertTime": t.string().optional(),
            "startTime": t.string().optional(),
            "statusMessage": t.string().optional(),
            "clientOperationId": t.string().optional(),
            "user": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "status": t.string().optional(),
            "warnings": t.array(
                t.struct(
                    {
                        "code": t.string().optional(),
                        "message": t.string().optional(),
                        "data": t.array(
                            t.struct(
                                {
                                    "key": t.string().optional(),
                                    "value": t.string().optional(),
                                }
                            )
                        ).optional(),
                    }
                )
            ).optional(),
            "zone": t.string().optional(),
            "httpErrorMessage": t.string().optional(),
            "httpErrorStatusCode": t.integer().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["OperationIn"])
    types["OperationOut"] = t.struct(
        {
            "progress": t.integer().optional(),
            "endTime": t.string().optional(),
            "targetLink": t.string().optional(),
            "targetId": t.string().optional(),
            "description": t.string().optional(),
            "operationGroupId": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
            "region": t.string().optional(),
            "operationType": t.string().optional(),
            "name": t.string().optional(),
            "insertTime": t.string().optional(),
            "startTime": t.string().optional(),
            "statusMessage": t.string().optional(),
            "clientOperationId": t.string().optional(),
            "user": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "status": t.string().optional(),
            "warnings": t.array(
                t.struct(
                    {
                        "code": t.string().optional(),
                        "message": t.string().optional(),
                        "data": t.array(
                            t.struct(
                                {
                                    "key": t.string().optional(),
                                    "value": t.string().optional(),
                                }
                            )
                        ).optional(),
                    }
                )
            ).optional(),
            "zone": t.string().optional(),
            "httpErrorMessage": t.string().optional(),
            "httpErrorStatusCode": t.integer().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["OperationOut"])
    types["NetworkEdgeSecurityServicesScopedListIn"] = t.struct(
        {
            "networkEdgeSecurityServices": t.array(
                t.proxy(renames["NetworkEdgeSecurityServiceIn"])
            ).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
        }
    ).named(renames["NetworkEdgeSecurityServicesScopedListIn"])
    types["NetworkEdgeSecurityServicesScopedListOut"] = t.struct(
        {
            "networkEdgeSecurityServices": t.array(
                t.proxy(renames["NetworkEdgeSecurityServiceOut"])
            ).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEdgeSecurityServicesScopedListOut"])
    types["TargetTcpProxiesScopedListIn"] = t.struct(
        {
            "targetTcpProxies": t.array(
                t.proxy(renames["TargetTcpProxyIn"])
            ).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["TargetTcpProxiesScopedListIn"])
    types["TargetTcpProxiesScopedListOut"] = t.struct(
        {
            "targetTcpProxies": t.array(
                t.proxy(renames["TargetTcpProxyOut"])
            ).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetTcpProxiesScopedListOut"])
    types["UsageExportLocationIn"] = t.struct(
        {"reportNamePrefix": t.string().optional(), "bucketName": t.string().optional()}
    ).named(renames["UsageExportLocationIn"])
    types["UsageExportLocationOut"] = t.struct(
        {
            "reportNamePrefix": t.string().optional(),
            "bucketName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UsageExportLocationOut"])
    types["TargetHttpProxiesScopedListIn"] = t.struct(
        {
            "targetHttpProxies": t.array(
                t.proxy(renames["TargetHttpProxyIn"])
            ).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["TargetHttpProxiesScopedListIn"])
    types["TargetHttpProxiesScopedListOut"] = t.struct(
        {
            "targetHttpProxies": t.array(
                t.proxy(renames["TargetHttpProxyOut"])
            ).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetHttpProxiesScopedListOut"])
    types["AdvancedMachineFeaturesIn"] = t.struct(
        {
            "enableUefiNetworking": t.boolean().optional(),
            "visibleCoreCount": t.integer().optional(),
            "enableNestedVirtualization": t.boolean().optional(),
            "threadsPerCore": t.integer().optional(),
        }
    ).named(renames["AdvancedMachineFeaturesIn"])
    types["AdvancedMachineFeaturesOut"] = t.struct(
        {
            "enableUefiNetworking": t.boolean().optional(),
            "visibleCoreCount": t.integer().optional(),
            "enableNestedVirtualization": t.boolean().optional(),
            "threadsPerCore": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AdvancedMachineFeaturesOut"])
    types["LicenseResourceRequirementsIn"] = t.struct(
        {
            "minMemoryMb": t.integer().optional(),
            "minGuestCpuCount": t.integer().optional(),
        }
    ).named(renames["LicenseResourceRequirementsIn"])
    types["LicenseResourceRequirementsOut"] = t.struct(
        {
            "minMemoryMb": t.integer().optional(),
            "minGuestCpuCount": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LicenseResourceRequirementsOut"])
    types["SubnetworkSecondaryRangeIn"] = t.struct(
        {"rangeName": t.string().optional(), "ipCidrRange": t.string().optional()}
    ).named(renames["SubnetworkSecondaryRangeIn"])
    types["SubnetworkSecondaryRangeOut"] = t.struct(
        {
            "rangeName": t.string().optional(),
            "ipCidrRange": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SubnetworkSecondaryRangeOut"])
    types["NetworkEndpointGroupsScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "networkEndpointGroups": t.array(
                t.proxy(renames["NetworkEndpointGroupIn"])
            ).optional(),
        }
    ).named(renames["NetworkEndpointGroupsScopedListIn"])
    types["NetworkEndpointGroupsScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "networkEndpointGroups": t.array(
                t.proxy(renames["NetworkEndpointGroupOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointGroupsScopedListOut"])
    types["ResourcePolicyInstanceSchedulePolicyScheduleIn"] = t.struct(
        {"schedule": t.string().optional()}
    ).named(renames["ResourcePolicyInstanceSchedulePolicyScheduleIn"])
    types["ResourcePolicyInstanceSchedulePolicyScheduleOut"] = t.struct(
        {
            "schedule": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicyInstanceSchedulePolicyScheduleOut"])
    types["SSLHealthCheckIn"] = t.struct(
        {
            "port": t.integer().optional(),
            "response": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "request": t.string().optional(),
            "portName": t.string().optional(),
            "portSpecification": t.string().optional(),
        }
    ).named(renames["SSLHealthCheckIn"])
    types["SSLHealthCheckOut"] = t.struct(
        {
            "port": t.integer().optional(),
            "response": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "request": t.string().optional(),
            "portName": t.string().optional(),
            "portSpecification": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SSLHealthCheckOut"])
    types["NetworkEndpointGroupAppEngineIn"] = t.struct(
        {
            "service": t.string().optional(),
            "urlMask": t.string().optional(),
            "version": t.string().optional(),
        }
    ).named(renames["NetworkEndpointGroupAppEngineIn"])
    types["NetworkEndpointGroupAppEngineOut"] = t.struct(
        {
            "service": t.string().optional(),
            "urlMask": t.string().optional(),
            "version": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointGroupAppEngineOut"])
    types["CustomerEncryptionKeyProtectedDiskIn"] = t.struct(
        {
            "diskEncryptionKey": t.proxy(renames["CustomerEncryptionKeyIn"]).optional(),
            "source": t.string().optional(),
        }
    ).named(renames["CustomerEncryptionKeyProtectedDiskIn"])
    types["CustomerEncryptionKeyProtectedDiskOut"] = t.struct(
        {
            "diskEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "source": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["CustomerEncryptionKeyProtectedDiskOut"])
    types["SecurityPolicyRuleMatcherConfigIn"] = t.struct(
        {"srcIpRanges": t.array(t.string()).optional()}
    ).named(renames["SecurityPolicyRuleMatcherConfigIn"])
    types["SecurityPolicyRuleMatcherConfigOut"] = t.struct(
        {
            "srcIpRanges": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyRuleMatcherConfigOut"])
    types["InstanceGroupManagerStatusVersionTargetIn"] = t.struct(
        {"isReached": t.boolean().optional()}
    ).named(renames["InstanceGroupManagerStatusVersionTargetIn"])
    types["InstanceGroupManagerStatusVersionTargetOut"] = t.struct(
        {
            "isReached": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagerStatusVersionTargetOut"])
    types["TargetHttpProxyAggregatedListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["TargetHttpProxyAggregatedListIn"])
    types["TargetHttpProxyAggregatedListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetHttpProxyAggregatedListOut"])
    types["TargetVpnGatewayListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["TargetVpnGatewayIn"])).optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["TargetVpnGatewayListIn"])
    types["TargetVpnGatewayListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["TargetVpnGatewayOut"])).optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetVpnGatewayListOut"])
    types["ExprIn"] = t.struct(
        {
            "location": t.string().optional(),
            "title": t.string().optional(),
            "expression": t.string().optional(),
            "description": t.string().optional(),
        }
    ).named(renames["ExprIn"])
    types["ExprOut"] = t.struct(
        {
            "location": t.string().optional(),
            "title": t.string().optional(),
            "expression": t.string().optional(),
            "description": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ExprOut"])
    types["HTTPHealthCheckIn"] = t.struct(
        {
            "portName": t.string().optional(),
            "requestPath": t.string().optional(),
            "host": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "portSpecification": t.string().optional(),
            "port": t.integer().optional(),
            "response": t.string().optional(),
        }
    ).named(renames["HTTPHealthCheckIn"])
    types["HTTPHealthCheckOut"] = t.struct(
        {
            "portName": t.string().optional(),
            "requestPath": t.string().optional(),
            "host": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "portSpecification": t.string().optional(),
            "port": t.integer().optional(),
            "response": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HTTPHealthCheckOut"])
    types["VpnGatewayStatusVpnConnectionIn"] = t.struct(
        {
            "state": t.proxy(
                renames["VpnGatewayStatusHighAvailabilityRequirementStateIn"]
            ).optional(),
            "tunnels": t.array(t.proxy(renames["VpnGatewayStatusTunnelIn"])).optional(),
            "peerExternalGateway": t.string().optional(),
            "peerGcpGateway": t.string().optional(),
        }
    ).named(renames["VpnGatewayStatusVpnConnectionIn"])
    types["VpnGatewayStatusVpnConnectionOut"] = t.struct(
        {
            "state": t.proxy(
                renames["VpnGatewayStatusHighAvailabilityRequirementStateOut"]
            ).optional(),
            "tunnels": t.array(
                t.proxy(renames["VpnGatewayStatusTunnelOut"])
            ).optional(),
            "peerExternalGateway": t.string().optional(),
            "peerGcpGateway": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnGatewayStatusVpnConnectionOut"])
    types["ProjectsEnableXpnResourceRequestIn"] = t.struct(
        {"xpnResource": t.proxy(renames["XpnResourceIdIn"]).optional()}
    ).named(renames["ProjectsEnableXpnResourceRequestIn"])
    types["ProjectsEnableXpnResourceRequestOut"] = t.struct(
        {
            "xpnResource": t.proxy(renames["XpnResourceIdOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ProjectsEnableXpnResourceRequestOut"])
    types["InstanceGroupManagerVersionIn"] = t.struct(
        {
            "instanceTemplate": t.string().optional(),
            "targetSize": t.proxy(renames["FixedOrPercentIn"]).optional(),
            "name": t.string().optional(),
        }
    ).named(renames["InstanceGroupManagerVersionIn"])
    types["InstanceGroupManagerVersionOut"] = t.struct(
        {
            "instanceTemplate": t.string().optional(),
            "targetSize": t.proxy(renames["FixedOrPercentOut"]).optional(),
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagerVersionOut"])
    types["ForwardingRuleAggregatedListIn"] = t.struct(
        {
            "items": t.struct({"_": t.string().optional()}).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["ForwardingRuleAggregatedListIn"])
    types["ForwardingRuleAggregatedListOut"] = t.struct(
        {
            "items": t.struct({"_": t.string().optional()}).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ForwardingRuleAggregatedListOut"])
    types["NodeGroupAggregatedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["NodeGroupAggregatedListIn"])
    types["NodeGroupAggregatedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeGroupAggregatedListOut"])
    types["XpnHostListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["ProjectIn"])).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["XpnHostListIn"])
    types["XpnHostListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["ProjectOut"])).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["XpnHostListOut"])
    types["NetworkPerformanceConfigIn"] = t.struct(
        {"totalEgressBandwidthTier": t.string()}
    ).named(renames["NetworkPerformanceConfigIn"])
    types["NetworkPerformanceConfigOut"] = t.struct(
        {
            "totalEgressBandwidthTier": t.string(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkPerformanceConfigOut"])
    types["TargetSslProxiesSetBackendServiceRequestIn"] = t.struct(
        {"service": t.string().optional()}
    ).named(renames["TargetSslProxiesSetBackendServiceRequestIn"])
    types["TargetSslProxiesSetBackendServiceRequestOut"] = t.struct(
        {
            "service": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetSslProxiesSetBackendServiceRequestOut"])
    types["CommitmentListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["CommitmentIn"])).optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
        }
    ).named(renames["CommitmentListIn"])
    types["CommitmentListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["CommitmentOut"])).optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["CommitmentListOut"])
    types["NetworkListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["NetworkIn"])).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["NetworkListIn"])
    types["NetworkListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["NetworkOut"])).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkListOut"])
    types["AddressesScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "addresses": t.array(t.proxy(renames["AddressIn"])).optional(),
        }
    ).named(renames["AddressesScopedListIn"])
    types["AddressesScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "addresses": t.array(t.proxy(renames["AddressOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AddressesScopedListOut"])
    types["SslPoliciesAggregatedListIn"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "etag": t.string(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["SslPoliciesAggregatedListIn"])
    types["SslPoliciesAggregatedListOut"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "etag": t.string(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SslPoliciesAggregatedListOut"])
    types["InstancesSetServiceAccountRequestIn"] = t.struct(
        {"scopes": t.array(t.string()).optional(), "email": t.string().optional()}
    ).named(renames["InstancesSetServiceAccountRequestIn"])
    types["InstancesSetServiceAccountRequestOut"] = t.struct(
        {
            "scopes": t.array(t.string()).optional(),
            "email": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstancesSetServiceAccountRequestOut"])
    types["UsableSubnetworkIn"] = t.struct(
        {
            "purpose": t.string().optional(),
            "secondaryIpRanges": t.array(
                t.proxy(renames["UsableSubnetworkSecondaryRangeIn"])
            ).optional(),
            "internalIpv6Prefix": t.string().optional(),
            "ipv6AccessType": t.string().optional(),
            "subnetwork": t.string().optional(),
            "stackType": t.string().optional(),
            "network": t.string().optional(),
            "externalIpv6Prefix": t.string().optional(),
            "ipCidrRange": t.string().optional(),
            "role": t.string().optional(),
        }
    ).named(renames["UsableSubnetworkIn"])
    types["UsableSubnetworkOut"] = t.struct(
        {
            "purpose": t.string().optional(),
            "secondaryIpRanges": t.array(
                t.proxy(renames["UsableSubnetworkSecondaryRangeOut"])
            ).optional(),
            "internalIpv6Prefix": t.string().optional(),
            "ipv6AccessType": t.string().optional(),
            "subnetwork": t.string().optional(),
            "stackType": t.string().optional(),
            "network": t.string().optional(),
            "externalIpv6Prefix": t.string().optional(),
            "ipCidrRange": t.string().optional(),
            "role": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UsableSubnetworkOut"])
    types["RegionInstanceGroupManagersSetTargetPoolsRequestIn"] = t.struct(
        {
            "fingerprint": t.string().optional(),
            "targetPools": t.array(t.string()).optional(),
        }
    ).named(renames["RegionInstanceGroupManagersSetTargetPoolsRequestIn"])
    types["RegionInstanceGroupManagersSetTargetPoolsRequestOut"] = t.struct(
        {
            "fingerprint": t.string().optional(),
            "targetPools": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagersSetTargetPoolsRequestOut"])
    types["FirewallPolicyAssociationIn"] = t.struct(
        {
            "firewallPolicyId": t.string().optional(),
            "name": t.string().optional(),
            "attachmentTarget": t.string().optional(),
            "shortName": t.string().optional(),
            "displayName": t.string().optional(),
        }
    ).named(renames["FirewallPolicyAssociationIn"])
    types["FirewallPolicyAssociationOut"] = t.struct(
        {
            "firewallPolicyId": t.string().optional(),
            "name": t.string().optional(),
            "attachmentTarget": t.string().optional(),
            "shortName": t.string().optional(),
            "displayName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["FirewallPolicyAssociationOut"])
    types["HttpRouteActionIn"] = t.struct(
        {
            "timeout": t.proxy(renames["DurationIn"]).optional(),
            "maxStreamDuration": t.proxy(renames["DurationIn"]).optional(),
            "retryPolicy": t.proxy(renames["HttpRetryPolicyIn"]).optional(),
            "faultInjectionPolicy": t.proxy(renames["HttpFaultInjectionIn"]).optional(),
            "urlRewrite": t.proxy(renames["UrlRewriteIn"]).optional(),
            "requestMirrorPolicy": t.proxy(renames["RequestMirrorPolicyIn"]).optional(),
            "weightedBackendServices": t.array(
                t.proxy(renames["WeightedBackendServiceIn"])
            ).optional(),
            "corsPolicy": t.proxy(renames["CorsPolicyIn"]).optional(),
        }
    ).named(renames["HttpRouteActionIn"])
    types["HttpRouteActionOut"] = t.struct(
        {
            "timeout": t.proxy(renames["DurationOut"]).optional(),
            "maxStreamDuration": t.proxy(renames["DurationOut"]).optional(),
            "retryPolicy": t.proxy(renames["HttpRetryPolicyOut"]).optional(),
            "faultInjectionPolicy": t.proxy(
                renames["HttpFaultInjectionOut"]
            ).optional(),
            "urlRewrite": t.proxy(renames["UrlRewriteOut"]).optional(),
            "requestMirrorPolicy": t.proxy(
                renames["RequestMirrorPolicyOut"]
            ).optional(),
            "weightedBackendServices": t.array(
                t.proxy(renames["WeightedBackendServiceOut"])
            ).optional(),
            "corsPolicy": t.proxy(renames["CorsPolicyOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpRouteActionOut"])
    types["SourceInstancePropertiesIn"] = t.struct(
        {
            "guestAccelerators": t.array(
                t.proxy(renames["AcceleratorConfigIn"])
            ).optional(),
            "scheduling": t.proxy(renames["SchedulingIn"]).optional(),
            "metadata": t.proxy(renames["MetadataIn"]).optional(),
            "minCpuPlatform": t.string().optional(),
            "description": t.string().optional(),
            "networkInterfaces": t.array(
                t.proxy(renames["NetworkInterfaceIn"])
            ).optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "tags": t.proxy(renames["TagsIn"]).optional(),
            "serviceAccounts": t.array(t.proxy(renames["ServiceAccountIn"])).optional(),
            "keyRevocationActionType": t.string().optional(),
            "deletionProtection": t.boolean().optional(),
            "canIpForward": t.boolean().optional(),
            "disks": t.array(t.proxy(renames["SavedAttachedDiskIn"])).optional(),
            "machineType": t.string().optional(),
        }
    ).named(renames["SourceInstancePropertiesIn"])
    types["SourceInstancePropertiesOut"] = t.struct(
        {
            "guestAccelerators": t.array(
                t.proxy(renames["AcceleratorConfigOut"])
            ).optional(),
            "scheduling": t.proxy(renames["SchedulingOut"]).optional(),
            "metadata": t.proxy(renames["MetadataOut"]).optional(),
            "minCpuPlatform": t.string().optional(),
            "description": t.string().optional(),
            "networkInterfaces": t.array(
                t.proxy(renames["NetworkInterfaceOut"])
            ).optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "tags": t.proxy(renames["TagsOut"]).optional(),
            "serviceAccounts": t.array(
                t.proxy(renames["ServiceAccountOut"])
            ).optional(),
            "keyRevocationActionType": t.string().optional(),
            "deletionProtection": t.boolean().optional(),
            "canIpForward": t.boolean().optional(),
            "disks": t.array(t.proxy(renames["SavedAttachedDiskOut"])).optional(),
            "machineType": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SourceInstancePropertiesOut"])
    types["InstanceGroupManagerUpdatePolicyIn"] = t.struct(
        {
            "minimalAction": t.string().optional(),
            "maxSurge": t.proxy(renames["FixedOrPercentIn"]).optional(),
            "instanceRedistributionType": t.string().optional(),
            "mostDisruptiveAllowedAction": t.string().optional(),
            "replacementMethod": t.string().optional(),
            "maxUnavailable": t.proxy(renames["FixedOrPercentIn"]).optional(),
            "type": t.string().optional(),
        }
    ).named(renames["InstanceGroupManagerUpdatePolicyIn"])
    types["InstanceGroupManagerUpdatePolicyOut"] = t.struct(
        {
            "minimalAction": t.string().optional(),
            "maxSurge": t.proxy(renames["FixedOrPercentOut"]).optional(),
            "instanceRedistributionType": t.string().optional(),
            "mostDisruptiveAllowedAction": t.string().optional(),
            "replacementMethod": t.string().optional(),
            "maxUnavailable": t.proxy(renames["FixedOrPercentOut"]).optional(),
            "type": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagerUpdatePolicyOut"])
    types["TargetPoolsRemoveHealthCheckRequestIn"] = t.struct(
        {"healthChecks": t.array(t.proxy(renames["HealthCheckReferenceIn"])).optional()}
    ).named(renames["TargetPoolsRemoveHealthCheckRequestIn"])
    types["TargetPoolsRemoveHealthCheckRequestOut"] = t.struct(
        {
            "healthChecks": t.array(
                t.proxy(renames["HealthCheckReferenceOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetPoolsRemoveHealthCheckRequestOut"])
    types["ZoneListIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["ZoneIn"])).optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["ZoneListIn"])
    types["ZoneListOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["ZoneOut"])).optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ZoneListOut"])
    types["BackendServiceCdnPolicyNegativeCachingPolicyIn"] = t.struct(
        {"code": t.integer().optional(), "ttl": t.integer().optional()}
    ).named(renames["BackendServiceCdnPolicyNegativeCachingPolicyIn"])
    types["BackendServiceCdnPolicyNegativeCachingPolicyOut"] = t.struct(
        {
            "code": t.integer().optional(),
            "ttl": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceCdnPolicyNegativeCachingPolicyOut"])
    types["SslCertificatesScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "sslCertificates": t.array(t.proxy(renames["SslCertificateIn"])).optional(),
        }
    ).named(renames["SslCertificatesScopedListIn"])
    types["SslCertificatesScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "sslCertificates": t.array(
                t.proxy(renames["SslCertificateOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SslCertificatesScopedListOut"])
    types["NodeGroupsListNodesIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["NodeGroupNodeIn"])).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["NodeGroupsListNodesIn"])
    types["NodeGroupsListNodesOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["NodeGroupNodeOut"])).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeGroupsListNodesOut"])
    types["BackendServiceLogConfigIn"] = t.struct(
        {
            "enable": t.boolean().optional(),
            "optionalMode": t.string().optional(),
            "sampleRate": t.number().optional(),
            "optionalFields": t.array(t.string()).optional(),
        }
    ).named(renames["BackendServiceLogConfigIn"])
    types["BackendServiceLogConfigOut"] = t.struct(
        {
            "enable": t.boolean().optional(),
            "optionalMode": t.string().optional(),
            "sampleRate": t.number().optional(),
            "optionalFields": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceLogConfigOut"])
    types["BackendServiceReferenceIn"] = t.struct({"backendService": t.string()}).named(
        renames["BackendServiceReferenceIn"]
    )
    types["BackendServiceReferenceOut"] = t.struct(
        {
            "backendService": t.string(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceReferenceOut"])
    types["BackendBucketIn"] = t.struct(
        {
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "name": t.string().optional(),
            "compressionMode": t.string().optional(),
            "cdnPolicy": t.proxy(renames["BackendBucketCdnPolicyIn"]).optional(),
            "creationTimestamp": t.string().optional(),
            "enableCdn": t.boolean().optional(),
            "edgeSecurityPolicy": t.string().optional(),
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "bucketName": t.string().optional(),
            "customResponseHeaders": t.array(t.string()).optional(),
        }
    ).named(renames["BackendBucketIn"])
    types["BackendBucketOut"] = t.struct(
        {
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "name": t.string().optional(),
            "compressionMode": t.string().optional(),
            "cdnPolicy": t.proxy(renames["BackendBucketCdnPolicyOut"]).optional(),
            "creationTimestamp": t.string().optional(),
            "enableCdn": t.boolean().optional(),
            "edgeSecurityPolicy": t.string().optional(),
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "bucketName": t.string().optional(),
            "customResponseHeaders": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendBucketOut"])
    types["RouterStatusNatStatusIn"] = t.struct(
        {
            "userAllocatedNatIpResources": t.array(t.string()).optional(),
            "drainAutoAllocatedNatIps": t.array(t.string()).optional(),
            "userAllocatedNatIps": t.array(t.string()).optional(),
            "numVmEndpointsWithNatMappings": t.integer().optional(),
            "ruleStatus": t.array(
                t.proxy(renames["RouterStatusNatStatusNatRuleStatusIn"])
            ).optional(),
            "name": t.string().optional(),
            "autoAllocatedNatIps": t.array(t.string()).optional(),
            "drainUserAllocatedNatIps": t.array(t.string()).optional(),
            "minExtraNatIpsNeeded": t.integer().optional(),
        }
    ).named(renames["RouterStatusNatStatusIn"])
    types["RouterStatusNatStatusOut"] = t.struct(
        {
            "userAllocatedNatIpResources": t.array(t.string()).optional(),
            "drainAutoAllocatedNatIps": t.array(t.string()).optional(),
            "userAllocatedNatIps": t.array(t.string()).optional(),
            "numVmEndpointsWithNatMappings": t.integer().optional(),
            "ruleStatus": t.array(
                t.proxy(renames["RouterStatusNatStatusNatRuleStatusOut"])
            ).optional(),
            "name": t.string().optional(),
            "autoAllocatedNatIps": t.array(t.string()).optional(),
            "drainUserAllocatedNatIps": t.array(t.string()).optional(),
            "minExtraNatIpsNeeded": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterStatusNatStatusOut"])
    types["TargetSslProxiesSetSslCertificatesRequestIn"] = t.struct(
        {"sslCertificates": t.array(t.string()).optional()}
    ).named(renames["TargetSslProxiesSetSslCertificatesRequestIn"])
    types["TargetSslProxiesSetSslCertificatesRequestOut"] = t.struct(
        {
            "sslCertificates": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetSslProxiesSetSslCertificatesRequestOut"])
    types["ProjectsListXpnHostsRequestIn"] = t.struct(
        {"organization": t.string().optional()}
    ).named(renames["ProjectsListXpnHostsRequestIn"])
    types["ProjectsListXpnHostsRequestOut"] = t.struct(
        {
            "organization": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ProjectsListXpnHostsRequestOut"])
    types["UrlMapListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["UrlMapIn"])).optional(),
        }
    ).named(renames["UrlMapListIn"])
    types["UrlMapListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["UrlMapOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UrlMapListOut"])
    types["GuestAttributesIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "variableValue": t.string().optional(),
            "variableKey": t.string().optional(),
            "queryPath": t.string().optional(),
            "queryValue": t.proxy(renames["GuestAttributesValueIn"]).optional(),
        }
    ).named(renames["GuestAttributesIn"])
    types["GuestAttributesOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "variableValue": t.string().optional(),
            "variableKey": t.string().optional(),
            "queryPath": t.string().optional(),
            "queryValue": t.proxy(renames["GuestAttributesValueOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["GuestAttributesOut"])
    types["InstancesSetMachineResourcesRequestIn"] = t.struct(
        {
            "guestAccelerators": t.array(
                t.proxy(renames["AcceleratorConfigIn"])
            ).optional()
        }
    ).named(renames["InstancesSetMachineResourcesRequestIn"])
    types["InstancesSetMachineResourcesRequestOut"] = t.struct(
        {
            "guestAccelerators": t.array(
                t.proxy(renames["AcceleratorConfigOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstancesSetMachineResourcesRequestOut"])
    types["InterconnectDiagnosticsLinkOpticalPowerIn"] = t.struct(
        {"state": t.string().optional(), "value": t.number().optional()}
    ).named(renames["InterconnectDiagnosticsLinkOpticalPowerIn"])
    types["InterconnectDiagnosticsLinkOpticalPowerOut"] = t.struct(
        {
            "state": t.string().optional(),
            "value": t.number().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectDiagnosticsLinkOpticalPowerOut"])
    types["SchedulingNodeAffinityIn"] = t.struct(
        {
            "operator": t.string().optional(),
            "values": t.array(t.string()).optional(),
            "key": t.string().optional(),
        }
    ).named(renames["SchedulingNodeAffinityIn"])
    types["SchedulingNodeAffinityOut"] = t.struct(
        {
            "operator": t.string().optional(),
            "values": t.array(t.string()).optional(),
            "key": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SchedulingNodeAffinityOut"])
    types["GlobalNetworkEndpointGroupsDetachEndpointsRequestIn"] = t.struct(
        {"networkEndpoints": t.array(t.proxy(renames["NetworkEndpointIn"])).optional()}
    ).named(renames["GlobalNetworkEndpointGroupsDetachEndpointsRequestIn"])
    types["GlobalNetworkEndpointGroupsDetachEndpointsRequestOut"] = t.struct(
        {
            "networkEndpoints": t.array(
                t.proxy(renames["NetworkEndpointOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["GlobalNetworkEndpointGroupsDetachEndpointsRequestOut"])
    types["FileContentBufferIn"] = t.struct(
        {"fileType": t.string().optional(), "content": t.string().optional()}
    ).named(renames["FileContentBufferIn"])
    types["FileContentBufferOut"] = t.struct(
        {
            "fileType": t.string().optional(),
            "content": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["FileContentBufferOut"])
    types["LogConfigCounterOptionsIn"] = t.struct(
        {
            "metric": t.string().optional(),
            "customFields": t.array(
                t.proxy(renames["LogConfigCounterOptionsCustomFieldIn"])
            ).optional(),
            "field": t.string().optional(),
        }
    ).named(renames["LogConfigCounterOptionsIn"])
    types["LogConfigCounterOptionsOut"] = t.struct(
        {
            "metric": t.string().optional(),
            "customFields": t.array(
                t.proxy(renames["LogConfigCounterOptionsCustomFieldOut"])
            ).optional(),
            "field": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LogConfigCounterOptionsOut"])
    types["InterconnectRemoteLocationPermittedConnectionsIn"] = t.struct(
        {"interconnectLocation": t.string().optional()}
    ).named(renames["InterconnectRemoteLocationPermittedConnectionsIn"])
    types["InterconnectRemoteLocationPermittedConnectionsOut"] = t.struct(
        {
            "interconnectLocation": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectRemoteLocationPermittedConnectionsOut"])
    types["ServiceAttachmentConsumerProjectLimitIn"] = t.struct(
        {
            "projectIdOrNum": t.string().optional(),
            "connectionLimit": t.integer().optional(),
            "networkUrl": t.string().optional(),
        }
    ).named(renames["ServiceAttachmentConsumerProjectLimitIn"])
    types["ServiceAttachmentConsumerProjectLimitOut"] = t.struct(
        {
            "projectIdOrNum": t.string().optional(),
            "connectionLimit": t.integer().optional(),
            "networkUrl": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ServiceAttachmentConsumerProjectLimitOut"])
    types["ResourcePolicyDiskConsistencyGroupPolicyIn"] = t.struct(
        {"_": t.string().optional()}
    ).named(renames["ResourcePolicyDiskConsistencyGroupPolicyIn"])
    types["ResourcePolicyDiskConsistencyGroupPolicyOut"] = t.struct(
        {"error": t.proxy(renames["ErrorResponse"]).optional()}
    ).named(renames["ResourcePolicyDiskConsistencyGroupPolicyOut"])
    types["VpnTunnelsScopedListIn"] = t.struct(
        {
            "vpnTunnels": t.array(t.proxy(renames["VpnTunnelIn"])).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
        }
    ).named(renames["VpnTunnelsScopedListIn"])
    types["VpnTunnelsScopedListOut"] = t.struct(
        {
            "vpnTunnels": t.array(t.proxy(renames["VpnTunnelOut"])).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnTunnelsScopedListOut"])
    types["TargetHttpsProxiesSetQuicOverrideRequestIn"] = t.struct(
        {"quicOverride": t.string().optional()}
    ).named(renames["TargetHttpsProxiesSetQuicOverrideRequestIn"])
    types["TargetHttpsProxiesSetQuicOverrideRequestOut"] = t.struct(
        {
            "quicOverride": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetHttpsProxiesSetQuicOverrideRequestOut"])
    types["ReservationIn"] = t.struct(
        {
            "specificReservation": t.proxy(
                renames["AllocationSpecificSKUReservationIn"]
            ).optional(),
            "satisfiesPzs": t.boolean().optional(),
            "description": t.string().optional(),
            "selfLink": t.string().optional(),
            "zone": t.string().optional(),
            "resourceStatus": t.proxy(renames["AllocationResourceStatusIn"]).optional(),
            "id": t.string().optional(),
            "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
            "resourcePolicies": t.struct({"_": t.string().optional()}).optional(),
            "name": t.string().optional(),
            "status": t.string().optional(),
            "kind": t.string().optional(),
            "specificReservationRequired": t.boolean().optional(),
            "commitment": t.string().optional(),
            "creationTimestamp": t.string().optional(),
        }
    ).named(renames["ReservationIn"])
    types["ReservationOut"] = t.struct(
        {
            "specificReservation": t.proxy(
                renames["AllocationSpecificSKUReservationOut"]
            ).optional(),
            "satisfiesPzs": t.boolean().optional(),
            "description": t.string().optional(),
            "selfLink": t.string().optional(),
            "zone": t.string().optional(),
            "resourceStatus": t.proxy(
                renames["AllocationResourceStatusOut"]
            ).optional(),
            "id": t.string().optional(),
            "shareSettings": t.proxy(renames["ShareSettingsOut"]).optional(),
            "resourcePolicies": t.struct({"_": t.string().optional()}).optional(),
            "name": t.string().optional(),
            "status": t.string().optional(),
            "kind": t.string().optional(),
            "specificReservationRequired": t.boolean().optional(),
            "commitment": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ReservationOut"])
    types["RouterNatIn"] = t.struct(
        {
            "minPortsPerVm": t.integer().optional(),
            "udpIdleTimeoutSec": t.integer().optional(),
            "endpointTypes": t.array(t.string()).optional(),
            "natIps": t.array(t.string()).optional(),
            "logConfig": t.proxy(renames["RouterNatLogConfigIn"]).optional(),
            "tcpTransitoryIdleTimeoutSec": t.integer().optional(),
            "enableEndpointIndependentMapping": t.boolean(),
            "enableDynamicPortAllocation": t.boolean().optional(),
            "maxPortsPerVm": t.integer().optional(),
            "sourceSubnetworkIpRangesToNat": t.string().optional(),
            "drainNatIps": t.array(t.string()).optional(),
            "subnetworks": t.array(
                t.proxy(renames["RouterNatSubnetworkToNatIn"])
            ).optional(),
            "rules": t.array(t.proxy(renames["RouterNatRuleIn"])).optional(),
            "tcpTimeWaitTimeoutSec": t.integer().optional(),
            "natIpAllocateOption": t.string().optional(),
            "icmpIdleTimeoutSec": t.integer().optional(),
            "name": t.string().optional(),
            "tcpEstablishedIdleTimeoutSec": t.integer().optional(),
        }
    ).named(renames["RouterNatIn"])
    types["RouterNatOut"] = t.struct(
        {
            "minPortsPerVm": t.integer().optional(),
            "udpIdleTimeoutSec": t.integer().optional(),
            "endpointTypes": t.array(t.string()).optional(),
            "natIps": t.array(t.string()).optional(),
            "logConfig": t.proxy(renames["RouterNatLogConfigOut"]).optional(),
            "tcpTransitoryIdleTimeoutSec": t.integer().optional(),
            "enableEndpointIndependentMapping": t.boolean(),
            "enableDynamicPortAllocation": t.boolean().optional(),
            "maxPortsPerVm": t.integer().optional(),
            "sourceSubnetworkIpRangesToNat": t.string().optional(),
            "drainNatIps": t.array(t.string()).optional(),
            "subnetworks": t.array(
                t.proxy(renames["RouterNatSubnetworkToNatOut"])
            ).optional(),
            "rules": t.array(t.proxy(renames["RouterNatRuleOut"])).optional(),
            "tcpTimeWaitTimeoutSec": t.integer().optional(),
            "natIpAllocateOption": t.string().optional(),
            "icmpIdleTimeoutSec": t.integer().optional(),
            "name": t.string().optional(),
            "tcpEstablishedIdleTimeoutSec": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterNatOut"])
    types["InterconnectDiagnosticsLinkStatusIn"] = t.struct(
        {
            "arpCaches": t.array(
                t.proxy(renames["InterconnectDiagnosticsARPEntryIn"])
            ).optional(),
            "googleDemarc": t.string().optional(),
            "lacpStatus": t.proxy(renames["InterconnectDiagnosticsLinkLACPStatusIn"]),
            "circuitId": t.string().optional(),
            "transmittingOpticalPower": t.proxy(
                renames["InterconnectDiagnosticsLinkOpticalPowerIn"]
            ).optional(),
            "receivingOpticalPower": t.proxy(
                renames["InterconnectDiagnosticsLinkOpticalPowerIn"]
            ).optional(),
            "operationalStatus": t.string().optional(),
        }
    ).named(renames["InterconnectDiagnosticsLinkStatusIn"])
    types["InterconnectDiagnosticsLinkStatusOut"] = t.struct(
        {
            "arpCaches": t.array(
                t.proxy(renames["InterconnectDiagnosticsARPEntryOut"])
            ).optional(),
            "googleDemarc": t.string().optional(),
            "lacpStatus": t.proxy(renames["InterconnectDiagnosticsLinkLACPStatusOut"]),
            "circuitId": t.string().optional(),
            "transmittingOpticalPower": t.proxy(
                renames["InterconnectDiagnosticsLinkOpticalPowerOut"]
            ).optional(),
            "receivingOpticalPower": t.proxy(
                renames["InterconnectDiagnosticsLinkOpticalPowerOut"]
            ).optional(),
            "operationalStatus": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectDiagnosticsLinkStatusOut"])
    types["NetworksUpdatePeeringRequestIn"] = t.struct(
        {"networkPeering": t.proxy(renames["NetworkPeeringIn"])}
    ).named(renames["NetworksUpdatePeeringRequestIn"])
    types["NetworksUpdatePeeringRequestOut"] = t.struct(
        {
            "networkPeering": t.proxy(renames["NetworkPeeringOut"]),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworksUpdatePeeringRequestOut"])
    types["MachineImageListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["MachineImageIn"])).optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["MachineImageListIn"])
    types["MachineImageListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["MachineImageOut"])).optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["MachineImageListOut"])
    types["InitialStateConfigIn"] = t.struct(
        {
            "dbxs": t.array(t.proxy(renames["FileContentBufferIn"])).optional(),
            "dbs": t.array(t.proxy(renames["FileContentBufferIn"])).optional(),
            "pk": t.proxy(renames["FileContentBufferIn"]).optional(),
            "keks": t.array(t.proxy(renames["FileContentBufferIn"])).optional(),
        }
    ).named(renames["InitialStateConfigIn"])
    types["InitialStateConfigOut"] = t.struct(
        {
            "dbxs": t.array(t.proxy(renames["FileContentBufferOut"])).optional(),
            "dbs": t.array(t.proxy(renames["FileContentBufferOut"])).optional(),
            "pk": t.proxy(renames["FileContentBufferOut"]).optional(),
            "keks": t.array(t.proxy(renames["FileContentBufferOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InitialStateConfigOut"])
    types["FirewallPolicyRuleMatcherLayer4ConfigIn"] = t.struct(
        {"ports": t.array(t.string()).optional(), "ipProtocol": t.string().optional()}
    ).named(renames["FirewallPolicyRuleMatcherLayer4ConfigIn"])
    types["FirewallPolicyRuleMatcherLayer4ConfigOut"] = t.struct(
        {
            "ports": t.array(t.string()).optional(),
            "ipProtocol": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["FirewallPolicyRuleMatcherLayer4ConfigOut"])
    types["HealthCheckReferenceIn"] = t.struct({"healthCheck": t.string()}).named(
        renames["HealthCheckReferenceIn"]
    )
    types["HealthCheckReferenceOut"] = t.struct(
        {
            "healthCheck": t.string(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HealthCheckReferenceOut"])
    types["UrlMapTestHeaderIn"] = t.struct(
        {"name": t.string().optional(), "value": t.string().optional()}
    ).named(renames["UrlMapTestHeaderIn"])
    types["UrlMapTestHeaderOut"] = t.struct(
        {
            "name": t.string().optional(),
            "value": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UrlMapTestHeaderOut"])
    types["LicenseCodeLicenseAliasIn"] = t.struct(
        {"description": t.string().optional(), "selfLink": t.string().optional()}
    ).named(renames["LicenseCodeLicenseAliasIn"])
    types["LicenseCodeLicenseAliasOut"] = t.struct(
        {
            "description": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LicenseCodeLicenseAliasOut"])
    types["NetworkEndpointIn"] = t.struct(
        {
            "instance": t.string().optional(),
            "annotations": t.struct({"_": t.string().optional()}).optional(),
            "port": t.integer().optional(),
            "fqdn": t.string().optional(),
            "ipAddress": t.string().optional(),
        }
    ).named(renames["NetworkEndpointIn"])
    types["NetworkEndpointOut"] = t.struct(
        {
            "instance": t.string().optional(),
            "annotations": t.struct({"_": t.string().optional()}).optional(),
            "port": t.integer().optional(),
            "fqdn": t.string().optional(),
            "ipAddress": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointOut"])
    types["InstanceGroupListIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceGroupIn"])).optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["InstanceGroupListIn"])
    types["InstanceGroupListOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceGroupOut"])).optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupListOut"])
    types["PreservedStatePreservedDiskIn"] = t.struct(
        {
            "source": t.string().optional(),
            "autoDelete": t.string().optional(),
            "mode": t.string().optional(),
        }
    ).named(renames["PreservedStatePreservedDiskIn"])
    types["PreservedStatePreservedDiskOut"] = t.struct(
        {
            "source": t.string().optional(),
            "autoDelete": t.string().optional(),
            "mode": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PreservedStatePreservedDiskOut"])
    types["SecurityPolicyAdvancedOptionsConfigIn"] = t.struct(
        {
            "jsonCustomConfig": t.proxy(
                renames["SecurityPolicyAdvancedOptionsConfigJsonCustomConfigIn"]
            ).optional(),
            "jsonParsing": t.string(),
            "logLevel": t.string(),
        }
    ).named(renames["SecurityPolicyAdvancedOptionsConfigIn"])
    types["SecurityPolicyAdvancedOptionsConfigOut"] = t.struct(
        {
            "jsonCustomConfig": t.proxy(
                renames["SecurityPolicyAdvancedOptionsConfigJsonCustomConfigOut"]
            ).optional(),
            "jsonParsing": t.string(),
            "logLevel": t.string(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyAdvancedOptionsConfigOut"])
    types["TargetReferenceIn"] = t.struct({"target": t.string()}).named(
        renames["TargetReferenceIn"]
    )
    types["TargetReferenceOut"] = t.struct(
        {"target": t.string(), "error": t.proxy(renames["ErrorResponse"]).optional()}
    ).named(renames["TargetReferenceOut"])
    types["RegionSetLabelsRequestIn"] = t.struct(
        {
            "labelFingerprint": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["RegionSetLabelsRequestIn"])
    types["RegionSetLabelsRequestOut"] = t.struct(
        {
            "labelFingerprint": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionSetLabelsRequestOut"])
    types["NodeTemplatesScopedListIn"] = t.struct(
        {
            "nodeTemplates": t.array(t.proxy(renames["NodeTemplateIn"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["NodeTemplatesScopedListIn"])
    types["NodeTemplatesScopedListOut"] = t.struct(
        {
            "nodeTemplates": t.array(t.proxy(renames["NodeTemplateOut"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeTemplatesScopedListOut"])
    types["SecurityPolicyRuleRateLimitOptionsThresholdIn"] = t.struct(
        {"intervalSec": t.integer().optional(), "count": t.integer().optional()}
    ).named(renames["SecurityPolicyRuleRateLimitOptionsThresholdIn"])
    types["SecurityPolicyRuleRateLimitOptionsThresholdOut"] = t.struct(
        {
            "intervalSec": t.integer().optional(),
            "count": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyRuleRateLimitOptionsThresholdOut"])
    types["InterconnectOutageNotificationIn"] = t.struct(
        {
            "startTime": t.string().optional(),
            "name": t.string().optional(),
            "affectedCircuits": t.array(t.string()).optional(),
            "issueType": t.string().optional(),
            "state": t.string().optional(),
            "endTime": t.string().optional(),
            "description": t.string().optional(),
            "source": t.string().optional(),
        }
    ).named(renames["InterconnectOutageNotificationIn"])
    types["InterconnectOutageNotificationOut"] = t.struct(
        {
            "startTime": t.string().optional(),
            "name": t.string().optional(),
            "affectedCircuits": t.array(t.string()).optional(),
            "issueType": t.string().optional(),
            "state": t.string().optional(),
            "endTime": t.string().optional(),
            "description": t.string().optional(),
            "source": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectOutageNotificationOut"])
    types["AddressListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["AddressIn"])).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["AddressListIn"])
    types["AddressListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["AddressOut"])).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AddressListOut"])
    types["AuditConfigIn"] = t.struct(
        {
            "service": t.string().optional(),
            "auditLogConfigs": t.array(t.proxy(renames["AuditLogConfigIn"])).optional(),
            "exemptedMembers": t.array(t.string()).optional(),
        }
    ).named(renames["AuditConfigIn"])
    types["AuditConfigOut"] = t.struct(
        {
            "service": t.string().optional(),
            "auditLogConfigs": t.array(
                t.proxy(renames["AuditLogConfigOut"])
            ).optional(),
            "exemptedMembers": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AuditConfigOut"])
    types["ResourcePolicyAggregatedListIn"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "etag": t.string(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["ResourcePolicyAggregatedListIn"])
    types["ResourcePolicyAggregatedListOut"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "etag": t.string(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicyAggregatedListOut"])
    types["HttpHeaderOptionIn"] = t.struct(
        {
            "headerValue": t.string().optional(),
            "headerName": t.string().optional(),
            "replace": t.boolean().optional(),
        }
    ).named(renames["HttpHeaderOptionIn"])
    types["HttpHeaderOptionOut"] = t.struct(
        {
            "headerValue": t.string().optional(),
            "headerName": t.string().optional(),
            "replace": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpHeaderOptionOut"])
    types["AttachedDiskIn"] = t.struct(
        {
            "architecture": t.string().optional(),
            "index": t.integer().optional(),
            "interface": t.string().optional(),
            "diskEncryptionKey": t.proxy(renames["CustomerEncryptionKeyIn"]).optional(),
            "licenses": t.array(t.string()).optional(),
            "source": t.string().optional(),
            "guestOsFeatures": t.array(t.proxy(renames["GuestOsFeatureIn"])).optional(),
            "autoDelete": t.boolean().optional(),
            "kind": t.string().optional(),
            "shieldedInstanceInitialState": t.proxy(
                renames["InitialStateConfigIn"]
            ).optional(),
            "initializeParams": t.proxy(
                renames["AttachedDiskInitializeParamsIn"]
            ).optional(),
            "deviceName": t.string().optional(),
            "savedState": t.string().optional(),
            "diskSizeGb": t.string().optional(),
            "type": t.string().optional(),
            "mode": t.string().optional(),
            "boot": t.boolean().optional(),
            "forceAttach": t.boolean().optional(),
        }
    ).named(renames["AttachedDiskIn"])
    types["AttachedDiskOut"] = t.struct(
        {
            "architecture": t.string().optional(),
            "index": t.integer().optional(),
            "interface": t.string().optional(),
            "diskEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "licenses": t.array(t.string()).optional(),
            "source": t.string().optional(),
            "guestOsFeatures": t.array(
                t.proxy(renames["GuestOsFeatureOut"])
            ).optional(),
            "autoDelete": t.boolean().optional(),
            "kind": t.string().optional(),
            "shieldedInstanceInitialState": t.proxy(
                renames["InitialStateConfigOut"]
            ).optional(),
            "initializeParams": t.proxy(
                renames["AttachedDiskInitializeParamsOut"]
            ).optional(),
            "deviceName": t.string().optional(),
            "savedState": t.string().optional(),
            "diskSizeGb": t.string().optional(),
            "type": t.string().optional(),
            "mode": t.string().optional(),
            "boot": t.boolean().optional(),
            "forceAttach": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AttachedDiskOut"])
    types["NetworkEndpointGroupAggregatedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["NetworkEndpointGroupAggregatedListIn"])
    types["NetworkEndpointGroupAggregatedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointGroupAggregatedListOut"])
    types["InstanceGroupManagersRecreateInstancesRequestIn"] = t.struct(
        {"instances": t.array(t.string()).optional()}
    ).named(renames["InstanceGroupManagersRecreateInstancesRequestIn"])
    types["InstanceGroupManagersRecreateInstancesRequestOut"] = t.struct(
        {
            "instances": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersRecreateInstancesRequestOut"])
    types["HttpFaultAbortIn"] = t.struct(
        {"httpStatus": t.integer().optional(), "percentage": t.number().optional()}
    ).named(renames["HttpFaultAbortIn"])
    types["HttpFaultAbortOut"] = t.struct(
        {
            "httpStatus": t.integer().optional(),
            "percentage": t.number().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpFaultAbortOut"])
    types["RegionInstanceGroupsListInstancesRequestIn"] = t.struct(
        {"portName": t.string().optional(), "instanceState": t.string().optional()}
    ).named(renames["RegionInstanceGroupsListInstancesRequestIn"])
    types["RegionInstanceGroupsListInstancesRequestOut"] = t.struct(
        {
            "portName": t.string().optional(),
            "instanceState": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupsListInstancesRequestOut"])
    types["VmEndpointNatMappingsListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "result": t.array(t.proxy(renames["VmEndpointNatMappingsIn"])).optional(),
        }
    ).named(renames["VmEndpointNatMappingsListIn"])
    types["VmEndpointNatMappingsListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "result": t.array(t.proxy(renames["VmEndpointNatMappingsOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VmEndpointNatMappingsListOut"])
    types["HealthCheckServicesListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["HealthCheckServiceIn"])).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["HealthCheckServicesListIn"])
    types["HealthCheckServicesListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["HealthCheckServiceOut"])).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HealthCheckServicesListOut"])
    types["RuleIn"] = t.struct(
        {
            "notIns": t.array(t.string()).optional(),
            "conditions": t.array(t.proxy(renames["ConditionIn"])).optional(),
            "logConfigs": t.array(t.proxy(renames["LogConfigIn"])).optional(),
            "ins": t.array(t.string()).optional(),
            "description": t.string().optional(),
            "permissions": t.array(t.string()).optional(),
            "action": t.string().optional(),
        }
    ).named(renames["RuleIn"])
    types["RuleOut"] = t.struct(
        {
            "notIns": t.array(t.string()).optional(),
            "conditions": t.array(t.proxy(renames["ConditionOut"])).optional(),
            "logConfigs": t.array(t.proxy(renames["LogConfigOut"])).optional(),
            "ins": t.array(t.string()).optional(),
            "description": t.string().optional(),
            "permissions": t.array(t.string()).optional(),
            "action": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RuleOut"])
    types["VpnTunnelIn"] = t.struct(
        {
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "id": t.string().optional(),
            "description": t.string().optional(),
            "peerIp": t.string().optional(),
            "kind": t.string().optional(),
            "remoteTrafficSelector": t.array(t.string()).optional(),
            "ikeVersion": t.integer().optional(),
            "peerExternalGatewayInterface": t.integer().optional(),
            "peerExternalGateway": t.string().optional(),
            "selfLink": t.string().optional(),
            "region": t.string().optional(),
            "sharedSecretHash": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "status": t.string().optional(),
            "router": t.string().optional(),
            "targetVpnGateway": t.string().optional(),
            "vpnGateway": t.string().optional(),
            "detailedStatus": t.string().optional(),
            "labelFingerprint": t.string().optional(),
            "localTrafficSelector": t.array(t.string()).optional(),
            "peerGcpGateway": t.string().optional(),
            "sharedSecret": t.string().optional(),
            "vpnGatewayInterface": t.integer().optional(),
        }
    ).named(renames["VpnTunnelIn"])
    types["VpnTunnelOut"] = t.struct(
        {
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "id": t.string().optional(),
            "description": t.string().optional(),
            "peerIp": t.string().optional(),
            "kind": t.string().optional(),
            "remoteTrafficSelector": t.array(t.string()).optional(),
            "ikeVersion": t.integer().optional(),
            "peerExternalGatewayInterface": t.integer().optional(),
            "peerExternalGateway": t.string().optional(),
            "selfLink": t.string().optional(),
            "region": t.string().optional(),
            "sharedSecretHash": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "status": t.string().optional(),
            "router": t.string().optional(),
            "targetVpnGateway": t.string().optional(),
            "vpnGateway": t.string().optional(),
            "detailedStatus": t.string().optional(),
            "labelFingerprint": t.string().optional(),
            "localTrafficSelector": t.array(t.string()).optional(),
            "peerGcpGateway": t.string().optional(),
            "sharedSecret": t.string().optional(),
            "vpnGatewayInterface": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnTunnelOut"])
    types["InstanceGroupManagersDeletePerInstanceConfigsReqIn"] = t.struct(
        {"names": t.array(t.string()).optional()}
    ).named(renames["InstanceGroupManagersDeletePerInstanceConfigsReqIn"])
    types["InstanceGroupManagersDeletePerInstanceConfigsReqOut"] = t.struct(
        {
            "names": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersDeletePerInstanceConfigsReqOut"])
    types["GlobalNetworkEndpointGroupsAttachEndpointsRequestIn"] = t.struct(
        {"networkEndpoints": t.array(t.proxy(renames["NetworkEndpointIn"])).optional()}
    ).named(renames["GlobalNetworkEndpointGroupsAttachEndpointsRequestIn"])
    types["GlobalNetworkEndpointGroupsAttachEndpointsRequestOut"] = t.struct(
        {
            "networkEndpoints": t.array(
                t.proxy(renames["NetworkEndpointOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["GlobalNetworkEndpointGroupsAttachEndpointsRequestOut"])
    types["TargetInstanceListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["TargetInstanceIn"])).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["TargetInstanceListIn"])
    types["TargetInstanceListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["TargetInstanceOut"])).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetInstanceListOut"])
    types["AutoscalerListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["AutoscalerIn"])).optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["AutoscalerListIn"])
    types["AutoscalerListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["AutoscalerOut"])).optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AutoscalerListOut"])
    types["InstanceGroupAggregatedListIn"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["InstanceGroupAggregatedListIn"])
    types["InstanceGroupAggregatedListOut"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupAggregatedListOut"])
    types["AttachedDiskInitializeParamsIn"] = t.struct(
        {
            "diskType": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "resourcePolicies": t.array(t.string()).optional(),
            "diskSizeGb": t.string().optional(),
            "sourceImageEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyIn"]
            ).optional(),
            "architecture": t.string().optional(),
            "sourceImage": t.string().optional(),
            "description": t.string().optional(),
            "provisionedIops": t.string().optional(),
            "sourceSnapshotEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyIn"]
            ).optional(),
            "licenses": t.array(t.string()).optional(),
            "diskName": t.string().optional(),
            "sourceSnapshot": t.string().optional(),
            "provisionedThroughput": t.string().optional(),
            "onUpdateAction": t.string().optional(),
            "replicaZones": t.array(t.string()),
            "resourceManagerTags": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["AttachedDiskInitializeParamsIn"])
    types["AttachedDiskInitializeParamsOut"] = t.struct(
        {
            "diskType": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "resourcePolicies": t.array(t.string()).optional(),
            "diskSizeGb": t.string().optional(),
            "sourceImageEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "architecture": t.string().optional(),
            "sourceImage": t.string().optional(),
            "description": t.string().optional(),
            "provisionedIops": t.string().optional(),
            "sourceSnapshotEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "licenses": t.array(t.string()).optional(),
            "diskName": t.string().optional(),
            "sourceSnapshot": t.string().optional(),
            "provisionedThroughput": t.string().optional(),
            "onUpdateAction": t.string().optional(),
            "replicaZones": t.array(t.string()),
            "resourceManagerTags": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AttachedDiskInitializeParamsOut"])
    types["NotificationEndpointIn"] = t.struct(
        {
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "region": t.string().optional(),
            "id": t.string().optional(),
            "grpcSettings": t.proxy(
                renames["NotificationEndpointGrpcSettingsIn"]
            ).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["NotificationEndpointIn"])
    types["NotificationEndpointOut"] = t.struct(
        {
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "region": t.string().optional(),
            "id": t.string().optional(),
            "grpcSettings": t.proxy(
                renames["NotificationEndpointGrpcSettingsOut"]
            ).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NotificationEndpointOut"])
    types["HelpIn"] = t.struct(
        {"links": t.array(t.proxy(renames["HelpLinkIn"])).optional()}
    ).named(renames["HelpIn"])
    types["HelpOut"] = t.struct(
        {
            "links": t.array(t.proxy(renames["HelpLinkOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HelpOut"])
    types["RegionDisksRemoveResourcePoliciesRequestIn"] = t.struct(
        {"resourcePolicies": t.array(t.string()).optional()}
    ).named(renames["RegionDisksRemoveResourcePoliciesRequestIn"])
    types["RegionDisksRemoveResourcePoliciesRequestOut"] = t.struct(
        {
            "resourcePolicies": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionDisksRemoveResourcePoliciesRequestOut"])
    types["TargetPoolIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "backupPool": t.string().optional(),
            "region": t.string().optional(),
            "sessionAffinity": t.string().optional(),
            "failoverRatio": t.number().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "instances": t.array(t.string()).optional(),
            "creationTimestamp": t.string().optional(),
            "selfLink": t.string().optional(),
            "healthChecks": t.array(t.string()).optional(),
        }
    ).named(renames["TargetPoolIn"])
    types["TargetPoolOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "backupPool": t.string().optional(),
            "region": t.string().optional(),
            "sessionAffinity": t.string().optional(),
            "failoverRatio": t.number().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "instances": t.array(t.string()).optional(),
            "creationTimestamp": t.string().optional(),
            "selfLink": t.string().optional(),
            "healthChecks": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetPoolOut"])
    types["RegionInstanceGroupManagersRecreateRequestIn"] = t.struct(
        {"instances": t.array(t.string()).optional()}
    ).named(renames["RegionInstanceGroupManagersRecreateRequestIn"])
    types["RegionInstanceGroupManagersRecreateRequestOut"] = t.struct(
        {
            "instances": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagersRecreateRequestOut"])
    types["HttpsHealthCheckIn"] = t.struct(
        {
            "healthyThreshold": t.integer().optional(),
            "selfLink": t.string().optional(),
            "description": t.string().optional(),
            "requestPath": t.string().optional(),
            "checkIntervalSec": t.integer().optional(),
            "host": t.string().optional(),
            "id": t.string().optional(),
            "port": t.integer().optional(),
            "creationTimestamp": t.string().optional(),
            "timeoutSec": t.integer().optional(),
            "unhealthyThreshold": t.integer().optional(),
            "name": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["HttpsHealthCheckIn"])
    types["HttpsHealthCheckOut"] = t.struct(
        {
            "healthyThreshold": t.integer().optional(),
            "selfLink": t.string().optional(),
            "description": t.string().optional(),
            "requestPath": t.string().optional(),
            "checkIntervalSec": t.integer().optional(),
            "host": t.string().optional(),
            "id": t.string().optional(),
            "port": t.integer().optional(),
            "creationTimestamp": t.string().optional(),
            "timeoutSec": t.integer().optional(),
            "unhealthyThreshold": t.integer().optional(),
            "name": t.string().optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpsHealthCheckOut"])
    types["InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn"] = t.struct(
        {
            "shortName": t.string().optional(),
            "displayName": t.string().optional(),
            "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
            "type": t.string().optional(),
            "name": t.string().optional(),
        }
    ).named(renames["InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn"])
    types[
        "InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut"
    ] = t.struct(
        {
            "shortName": t.string().optional(),
            "displayName": t.string().optional(),
            "rules": t.array(t.proxy(renames["FirewallPolicyRuleOut"])).optional(),
            "type": t.string().optional(),
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(
        renames["InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut"]
    )
    types[
        "AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskIn"
    ] = t.struct(
        {"interface": t.string().optional(), "diskSizeGb": t.string().optional()}
    ).named(
        renames[
            "AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskIn"
        ]
    )
    types[
        "AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskOut"
    ] = t.struct(
        {
            "interface": t.string().optional(),
            "diskSizeGb": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(
        renames[
            "AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskOut"
        ]
    )
    types["NetworkEndpointGroupsAttachEndpointsRequestIn"] = t.struct(
        {"networkEndpoints": t.array(t.proxy(renames["NetworkEndpointIn"])).optional()}
    ).named(renames["NetworkEndpointGroupsAttachEndpointsRequestIn"])
    types["NetworkEndpointGroupsAttachEndpointsRequestOut"] = t.struct(
        {
            "networkEndpoints": t.array(
                t.proxy(renames["NetworkEndpointOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointGroupsAttachEndpointsRequestOut"])
    types["RouterNatRuleActionIn"] = t.struct(
        {
            "sourceNatActiveIps": t.array(t.string()).optional(),
            "sourceNatDrainIps": t.array(t.string()).optional(),
        }
    ).named(renames["RouterNatRuleActionIn"])
    types["RouterNatRuleActionOut"] = t.struct(
        {
            "sourceNatActiveIps": t.array(t.string()).optional(),
            "sourceNatDrainIps": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterNatRuleActionOut"])
    types["ResourcePolicySnapshotSchedulePolicyScheduleIn"] = t.struct(
        {
            "dailySchedule": t.proxy(renames["ResourcePolicyDailyCycleIn"]),
            "weeklySchedule": t.proxy(renames["ResourcePolicyWeeklyCycleIn"]),
            "hourlySchedule": t.proxy(renames["ResourcePolicyHourlyCycleIn"]),
        }
    ).named(renames["ResourcePolicySnapshotSchedulePolicyScheduleIn"])
    types["ResourcePolicySnapshotSchedulePolicyScheduleOut"] = t.struct(
        {
            "dailySchedule": t.proxy(renames["ResourcePolicyDailyCycleOut"]),
            "weeklySchedule": t.proxy(renames["ResourcePolicyWeeklyCycleOut"]),
            "hourlySchedule": t.proxy(renames["ResourcePolicyHourlyCycleOut"]),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicySnapshotSchedulePolicyScheduleOut"])
    types["ShieldedInstanceIdentityIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "signingKey": t.proxy(
                renames["ShieldedInstanceIdentityEntryIn"]
            ).optional(),
            "encryptionKey": t.proxy(
                renames["ShieldedInstanceIdentityEntryIn"]
            ).optional(),
        }
    ).named(renames["ShieldedInstanceIdentityIn"])
    types["ShieldedInstanceIdentityOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "signingKey": t.proxy(
                renames["ShieldedInstanceIdentityEntryOut"]
            ).optional(),
            "encryptionKey": t.proxy(
                renames["ShieldedInstanceIdentityEntryOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ShieldedInstanceIdentityOut"])
    types["TargetPoolsRemoveInstanceRequestIn"] = t.struct(
        {"instances": t.array(t.proxy(renames["InstanceReferenceIn"])).optional()}
    ).named(renames["TargetPoolsRemoveInstanceRequestIn"])
    types["TargetPoolsRemoveInstanceRequestOut"] = t.struct(
        {
            "instances": t.array(t.proxy(renames["InstanceReferenceOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetPoolsRemoveInstanceRequestOut"])
    types["SecurityPolicyAdvancedOptionsConfigJsonCustomConfigIn"] = t.struct(
        {"contentTypes": t.array(t.string()).optional()}
    ).named(renames["SecurityPolicyAdvancedOptionsConfigJsonCustomConfigIn"])
    types["SecurityPolicyAdvancedOptionsConfigJsonCustomConfigOut"] = t.struct(
        {
            "contentTypes": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyAdvancedOptionsConfigJsonCustomConfigOut"])
    types["InstancesRemoveResourcePoliciesRequestIn"] = t.struct(
        {"resourcePolicies": t.array(t.string()).optional()}
    ).named(renames["InstancesRemoveResourcePoliciesRequestIn"])
    types["InstancesRemoveResourcePoliciesRequestOut"] = t.struct(
        {
            "resourcePolicies": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstancesRemoveResourcePoliciesRequestOut"])
    types["UrlMapReferenceIn"] = t.struct({"urlMap": t.string()}).named(
        renames["UrlMapReferenceIn"]
    )
    types["UrlMapReferenceOut"] = t.struct(
        {"urlMap": t.string(), "error": t.proxy(renames["ErrorResponse"]).optional()}
    ).named(renames["UrlMapReferenceOut"])
    types["SubnetworksExpandIpCidrRangeRequestIn"] = t.struct(
        {"ipCidrRange": t.string().optional()}
    ).named(renames["SubnetworksExpandIpCidrRangeRequestIn"])
    types["SubnetworksExpandIpCidrRangeRequestOut"] = t.struct(
        {
            "ipCidrRange": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SubnetworksExpandIpCidrRangeRequestOut"])
    types["InstanceGroupManagerAggregatedListIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["InstanceGroupManagerAggregatedListIn"])
    types["InstanceGroupManagerAggregatedListOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagerAggregatedListOut"])
    types["OperationListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["OperationIn"])).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["OperationListIn"])
    types["OperationListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["OperationOut"])).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["OperationListOut"])
    types["InterconnectAttachmentPartnerMetadataIn"] = t.struct(
        {
            "portalUrl": t.string().optional(),
            "partnerName": t.string().optional(),
            "interconnectName": t.string().optional(),
        }
    ).named(renames["InterconnectAttachmentPartnerMetadataIn"])
    types["InterconnectAttachmentPartnerMetadataOut"] = t.struct(
        {
            "portalUrl": t.string().optional(),
            "partnerName": t.string().optional(),
            "interconnectName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectAttachmentPartnerMetadataOut"])
    types["AutoscalingPolicyCpuUtilizationIn"] = t.struct(
        {
            "utilizationTarget": t.number().optional(),
            "predictiveMethod": t.string().optional(),
        }
    ).named(renames["AutoscalingPolicyCpuUtilizationIn"])
    types["AutoscalingPolicyCpuUtilizationOut"] = t.struct(
        {
            "utilizationTarget": t.number().optional(),
            "predictiveMethod": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AutoscalingPolicyCpuUtilizationOut"])
    types["TagsIn"] = t.struct(
        {"items": t.array(t.string()).optional(), "fingerprint": t.string().optional()}
    ).named(renames["TagsIn"])
    types["TagsOut"] = t.struct(
        {
            "items": t.array(t.string()).optional(),
            "fingerprint": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TagsOut"])
    types["CustomerEncryptionKeyIn"] = t.struct(
        {
            "kmsKeyName": t.string().optional(),
            "sha256": t.string().optional(),
            "kmsKeyServiceAccount": t.string().optional(),
            "rawKey": t.string().optional(),
            "rsaEncryptedKey": t.string().optional(),
        }
    ).named(renames["CustomerEncryptionKeyIn"])
    types["CustomerEncryptionKeyOut"] = t.struct(
        {
            "kmsKeyName": t.string().optional(),
            "sha256": t.string().optional(),
            "kmsKeyServiceAccount": t.string().optional(),
            "rawKey": t.string().optional(),
            "rsaEncryptedKey": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["CustomerEncryptionKeyOut"])
    types["RouterMd5AuthenticationKeyIn"] = t.struct(
        {"key": t.string().optional(), "name": t.string().optional()}
    ).named(renames["RouterMd5AuthenticationKeyIn"])
    types["RouterMd5AuthenticationKeyOut"] = t.struct(
        {
            "key": t.string().optional(),
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterMd5AuthenticationKeyOut"])
    types["RegionInstanceGroupManagersCreateInstancesRequestIn"] = t.struct(
        {"instances": t.array(t.proxy(renames["PerInstanceConfigIn"])).optional()}
    ).named(renames["RegionInstanceGroupManagersCreateInstancesRequestIn"])
    types["RegionInstanceGroupManagersCreateInstancesRequestOut"] = t.struct(
        {
            "instances": t.array(t.proxy(renames["PerInstanceConfigOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagersCreateInstancesRequestOut"])
    types["AutoscalersScopedListIn"] = t.struct(
        {
            "autoscalers": t.array(t.proxy(renames["AutoscalerIn"])).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
        }
    ).named(renames["AutoscalersScopedListIn"])
    types["AutoscalersScopedListOut"] = t.struct(
        {
            "autoscalers": t.array(t.proxy(renames["AutoscalerOut"])).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AutoscalersScopedListOut"])
    types["InstanceGroupManagerStatusStatefulIn"] = t.struct(
        {
            "hasStatefulConfig": t.boolean().optional(),
            "perInstanceConfigs": t.proxy(
                renames["InstanceGroupManagerStatusStatefulPerInstanceConfigsIn"]
            ).optional(),
        }
    ).named(renames["InstanceGroupManagerStatusStatefulIn"])
    types["InstanceGroupManagerStatusStatefulOut"] = t.struct(
        {
            "hasStatefulConfig": t.boolean().optional(),
            "perInstanceConfigs": t.proxy(
                renames["InstanceGroupManagerStatusStatefulPerInstanceConfigsOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagerStatusStatefulOut"])
    types["NodeTypeAggregatedListIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["NodeTypeAggregatedListIn"])
    types["NodeTypeAggregatedListOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeTypeAggregatedListOut"])
    types["NodeTypesScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nodeTypes": t.array(t.proxy(renames["NodeTypeIn"])).optional(),
        }
    ).named(renames["NodeTypesScopedListIn"])
    types["NodeTypesScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nodeTypes": t.array(t.proxy(renames["NodeTypeOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeTypesScopedListOut"])
    types["HealthCheckServiceReferenceIn"] = t.struct(
        {"healthCheckService": t.string()}
    ).named(renames["HealthCheckServiceReferenceIn"])
    types["HealthCheckServiceReferenceOut"] = t.struct(
        {
            "healthCheckService": t.string(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HealthCheckServiceReferenceOut"])
    types["HealthCheckListIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["HealthCheckIn"])).optional(),
            "id": t.string().optional(),
        }
    ).named(renames["HealthCheckListIn"])
    types["HealthCheckListOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["HealthCheckOut"])).optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HealthCheckListOut"])
    types["VmEndpointNatMappingsIn"] = t.struct(
        {
            "interfaceNatMappings": t.array(
                t.proxy(renames["VmEndpointNatMappingsInterfaceNatMappingsIn"])
            ),
            "instanceName": t.string().optional(),
        }
    ).named(renames["VmEndpointNatMappingsIn"])
    types["VmEndpointNatMappingsOut"] = t.struct(
        {
            "interfaceNatMappings": t.array(
                t.proxy(renames["VmEndpointNatMappingsInterfaceNatMappingsOut"])
            ),
            "instanceName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VmEndpointNatMappingsOut"])
    types["VpnGatewayVpnGatewayInterfaceIn"] = t.struct(
        {
            "id": t.integer().optional(),
            "ipAddress": t.string().optional(),
            "interconnectAttachment": t.string().optional(),
        }
    ).named(renames["VpnGatewayVpnGatewayInterfaceIn"])
    types["VpnGatewayVpnGatewayInterfaceOut"] = t.struct(
        {
            "id": t.integer().optional(),
            "ipAddress": t.string().optional(),
            "interconnectAttachment": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnGatewayVpnGatewayInterfaceOut"])
    types["ZoneSetPolicyRequestIn"] = t.struct(
        {
            "policy": t.proxy(renames["PolicyIn"]).optional(),
            "bindings": t.array(t.proxy(renames["BindingIn"])).optional(),
            "etag": t.string().optional(),
        }
    ).named(renames["ZoneSetPolicyRequestIn"])
    types["ZoneSetPolicyRequestOut"] = t.struct(
        {
            "policy": t.proxy(renames["PolicyOut"]).optional(),
            "bindings": t.array(t.proxy(renames["BindingOut"])).optional(),
            "etag": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ZoneSetPolicyRequestOut"])
    types["FirewallListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["FirewallIn"])).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["FirewallListIn"])
    types["FirewallListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["FirewallOut"])).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["FirewallListOut"])
    types["HttpQueryParameterMatchIn"] = t.struct(
        {
            "name": t.string().optional(),
            "regexMatch": t.string().optional(),
            "presentMatch": t.boolean().optional(),
            "exactMatch": t.string().optional(),
        }
    ).named(renames["HttpQueryParameterMatchIn"])
    types["HttpQueryParameterMatchOut"] = t.struct(
        {
            "name": t.string().optional(),
            "regexMatch": t.string().optional(),
            "presentMatch": t.boolean().optional(),
            "exactMatch": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpQueryParameterMatchOut"])
    types["SourceInstanceParamsIn"] = t.struct(
        {
            "diskConfigs": t.array(
                t.proxy(renames["DiskInstantiationConfigIn"])
            ).optional()
        }
    ).named(renames["SourceInstanceParamsIn"])
    types["SourceInstanceParamsOut"] = t.struct(
        {
            "diskConfigs": t.array(
                t.proxy(renames["DiskInstantiationConfigOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SourceInstanceParamsOut"])
    types["InterconnectIn"] = t.struct(
        {
            "operationalStatus": t.string().optional(),
            "googleIpAddress": t.string().optional(),
            "labelFingerprint": t.string().optional(),
            "interconnectAttachments": t.array(t.string()).optional(),
            "location": t.string().optional(),
            "name": t.string().optional(),
            "state": t.string().optional(),
            "selfLink": t.string().optional(),
            "interconnectType": t.string().optional(),
            "customerName": t.string().optional(),
            "peerIpAddress": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "linkType": t.string().optional(),
            "satisfiesPzs": t.boolean().optional(),
            "googleReferenceId": t.string().optional(),
            "description": t.string().optional(),
            "expectedOutages": t.array(
                t.proxy(renames["InterconnectOutageNotificationIn"])
            ).optional(),
            "adminEnabled": t.boolean().optional(),
            "provisionedLinkCount": t.integer().optional(),
            "kind": t.string().optional(),
            "requestedLinkCount": t.integer().optional(),
            "nocContactEmail": t.string().optional(),
            "id": t.string().optional(),
            "remoteLocation": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "circuitInfos": t.array(
                t.proxy(renames["InterconnectCircuitInfoIn"])
            ).optional(),
        }
    ).named(renames["InterconnectIn"])
    types["InterconnectOut"] = t.struct(
        {
            "operationalStatus": t.string().optional(),
            "googleIpAddress": t.string().optional(),
            "labelFingerprint": t.string().optional(),
            "interconnectAttachments": t.array(t.string()).optional(),
            "location": t.string().optional(),
            "name": t.string().optional(),
            "state": t.string().optional(),
            "selfLink": t.string().optional(),
            "interconnectType": t.string().optional(),
            "customerName": t.string().optional(),
            "peerIpAddress": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "linkType": t.string().optional(),
            "satisfiesPzs": t.boolean().optional(),
            "googleReferenceId": t.string().optional(),
            "description": t.string().optional(),
            "expectedOutages": t.array(
                t.proxy(renames["InterconnectOutageNotificationOut"])
            ).optional(),
            "adminEnabled": t.boolean().optional(),
            "provisionedLinkCount": t.integer().optional(),
            "kind": t.string().optional(),
            "requestedLinkCount": t.integer().optional(),
            "nocContactEmail": t.string().optional(),
            "id": t.string().optional(),
            "remoteLocation": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "circuitInfos": t.array(
                t.proxy(renames["InterconnectCircuitInfoOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectOut"])
    types["InstanceGroupManagerStatusIn"] = t.struct(
        {
            "versionTarget": t.proxy(
                renames["InstanceGroupManagerStatusVersionTargetIn"]
            ).optional(),
            "stateful": t.proxy(
                renames["InstanceGroupManagerStatusStatefulIn"]
            ).optional(),
            "isStable": t.boolean().optional(),
            "autoscaler": t.string().optional(),
        }
    ).named(renames["InstanceGroupManagerStatusIn"])
    types["InstanceGroupManagerStatusOut"] = t.struct(
        {
            "versionTarget": t.proxy(
                renames["InstanceGroupManagerStatusVersionTargetOut"]
            ).optional(),
            "stateful": t.proxy(
                renames["InstanceGroupManagerStatusStatefulOut"]
            ).optional(),
            "isStable": t.boolean().optional(),
            "autoscaler": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagerStatusOut"])
    types["RouteListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["RouteIn"])).optional(),
        }
    ).named(renames["RouteListIn"])
    types["RouteListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["RouteOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouteListOut"])
    types["ResourcePolicyListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "etag": t.string(),
            "items": t.array(t.proxy(renames["ResourcePolicyIn"])).optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["ResourcePolicyListIn"])
    types["ResourcePolicyListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "etag": t.string(),
            "items": t.array(t.proxy(renames["ResourcePolicyOut"])).optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicyListOut"])
    types["ConditionIn"] = t.struct(
        {
            "iam": t.string().optional(),
            "sys": t.string().optional(),
            "values": t.array(t.string()).optional(),
            "op": t.string().optional(),
            "svc": t.string().optional(),
        }
    ).named(renames["ConditionIn"])
    types["ConditionOut"] = t.struct(
        {
            "iam": t.string().optional(),
            "sys": t.string().optional(),
            "values": t.array(t.string()).optional(),
            "op": t.string().optional(),
            "svc": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ConditionOut"])
    types["ShieldedInstanceIntegrityPolicyIn"] = t.struct(
        {"updateAutoLearnPolicy": t.boolean().optional()}
    ).named(renames["ShieldedInstanceIntegrityPolicyIn"])
    types["ShieldedInstanceIntegrityPolicyOut"] = t.struct(
        {
            "updateAutoLearnPolicy": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ShieldedInstanceIntegrityPolicyOut"])
    types["FirewallIn"] = t.struct(
        {
            "sourceServiceAccounts": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "direction": t.string().optional(),
            "disabled": t.boolean().optional(),
            "targetServiceAccounts": t.array(t.string()).optional(),
            "denied": t.array(
                t.struct(
                    {
                        "IPProtocol": t.string().optional(),
                        "ports": t.array(t.string()).optional(),
                    }
                )
            ).optional(),
            "allowed": t.array(
                t.struct(
                    {
                        "IPProtocol": t.string().optional(),
                        "ports": t.array(t.string()).optional(),
                    }
                )
            ).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "description": t.string().optional(),
            "priority": t.integer().optional(),
            "creationTimestamp": t.string().optional(),
            "targetTags": t.array(t.string()).optional(),
            "logConfig": t.proxy(renames["FirewallLogConfigIn"]).optional(),
            "destinationRanges": t.array(t.string()).optional(),
            "name": t.string().optional(),
            "sourceRanges": t.array(t.string()).optional(),
            "network": t.string().optional(),
            "sourceTags": t.array(t.string()).optional(),
        }
    ).named(renames["FirewallIn"])
    types["FirewallOut"] = t.struct(
        {
            "sourceServiceAccounts": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "direction": t.string().optional(),
            "disabled": t.boolean().optional(),
            "targetServiceAccounts": t.array(t.string()).optional(),
            "denied": t.array(
                t.struct(
                    {
                        "IPProtocol": t.string().optional(),
                        "ports": t.array(t.string()).optional(),
                    }
                )
            ).optional(),
            "allowed": t.array(
                t.struct(
                    {
                        "IPProtocol": t.string().optional(),
                        "ports": t.array(t.string()).optional(),
                    }
                )
            ).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "description": t.string().optional(),
            "priority": t.integer().optional(),
            "creationTimestamp": t.string().optional(),
            "targetTags": t.array(t.string()).optional(),
            "logConfig": t.proxy(renames["FirewallLogConfigOut"]).optional(),
            "destinationRanges": t.array(t.string()).optional(),
            "name": t.string().optional(),
            "sourceRanges": t.array(t.string()).optional(),
            "network": t.string().optional(),
            "sourceTags": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["FirewallOut"])
    types["TargetHttpsProxiesScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "targetHttpsProxies": t.array(
                t.proxy(renames["TargetHttpsProxyIn"])
            ).optional(),
        }
    ).named(renames["TargetHttpsProxiesScopedListIn"])
    types["TargetHttpsProxiesScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "targetHttpsProxies": t.array(
                t.proxy(renames["TargetHttpsProxyOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetHttpsProxiesScopedListOut"])
    types["TargetHttpProxyIn"] = t.struct(
        {
            "fingerprint": t.string().optional(),
            "urlMap": t.string().optional(),
            "description": t.string().optional(),
            "proxyBind": t.boolean().optional(),
            "creationTimestamp": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "kind": t.string().optional(),
            "region": t.string().optional(),
        }
    ).named(renames["TargetHttpProxyIn"])
    types["TargetHttpProxyOut"] = t.struct(
        {
            "fingerprint": t.string().optional(),
            "urlMap": t.string().optional(),
            "description": t.string().optional(),
            "proxyBind": t.boolean().optional(),
            "creationTimestamp": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "kind": t.string().optional(),
            "region": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetHttpProxyOut"])
    types["SubnetworkAggregatedListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
        }
    ).named(renames["SubnetworkAggregatedListIn"])
    types["SubnetworkAggregatedListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SubnetworkAggregatedListOut"])
    types["NotificationEndpointGrpcSettingsIn"] = t.struct(
        {
            "endpoint": t.string().optional(),
            "authority": t.string().optional(),
            "retryDurationSec": t.integer().optional(),
            "payloadName": t.string().optional(),
            "resendInterval": t.proxy(renames["DurationIn"]).optional(),
        }
    ).named(renames["NotificationEndpointGrpcSettingsIn"])
    types["NotificationEndpointGrpcSettingsOut"] = t.struct(
        {
            "endpoint": t.string().optional(),
            "authority": t.string().optional(),
            "retryDurationSec": t.integer().optional(),
            "payloadName": t.string().optional(),
            "resendInterval": t.proxy(renames["DurationOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NotificationEndpointGrpcSettingsOut"])
    types["TargetTcpProxyIn"] = t.struct(
        {
            "region": t.string().optional(),
            "name": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "description": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "service": t.string().optional(),
            "id": t.string().optional(),
            "proxyBind": t.boolean().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["TargetTcpProxyIn"])
    types["TargetTcpProxyOut"] = t.struct(
        {
            "region": t.string().optional(),
            "name": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "description": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "service": t.string().optional(),
            "id": t.string().optional(),
            "proxyBind": t.boolean().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetTcpProxyOut"])
    types["FirewallPolicyIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "ruleTupleCount": t.integer().optional(),
            "associations": t.array(
                t.proxy(renames["FirewallPolicyAssociationIn"])
            ).optional(),
            "name": t.string().optional(),
            "region": t.string().optional(),
            "shortName": t.string().optional(),
            "description": t.string().optional(),
            "selfLink": t.string().optional(),
            "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
            "displayName": t.string().optional(),
            "id": t.string().optional(),
            "parent": t.string().optional(),
            "fingerprint": t.string().optional(),
            "selfLinkWithId": t.string().optional(),
        }
    ).named(renames["FirewallPolicyIn"])
    types["FirewallPolicyOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "ruleTupleCount": t.integer().optional(),
            "associations": t.array(
                t.proxy(renames["FirewallPolicyAssociationOut"])
            ).optional(),
            "name": t.string().optional(),
            "region": t.string().optional(),
            "shortName": t.string().optional(),
            "description": t.string().optional(),
            "selfLink": t.string().optional(),
            "rules": t.array(t.proxy(renames["FirewallPolicyRuleOut"])).optional(),
            "displayName": t.string().optional(),
            "id": t.string().optional(),
            "parent": t.string().optional(),
            "fingerprint": t.string().optional(),
            "selfLinkWithId": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["FirewallPolicyOut"])
    types["ResourcePolicyDailyCycleIn"] = t.struct(
        {
            "duration": t.string().optional(),
            "daysInCycle": t.integer().optional(),
            "startTime": t.string().optional(),
        }
    ).named(renames["ResourcePolicyDailyCycleIn"])
    types["ResourcePolicyDailyCycleOut"] = t.struct(
        {
            "duration": t.string().optional(),
            "daysInCycle": t.integer().optional(),
            "startTime": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicyDailyCycleOut"])
    types["NotificationEndpointListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["NotificationEndpointIn"])).optional(),
        }
    ).named(renames["NotificationEndpointListIn"])
    types["NotificationEndpointListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["NotificationEndpointOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NotificationEndpointListOut"])
    types["CacheKeyPolicyIn"] = t.struct(
        {
            "queryStringWhitelist": t.array(t.string()).optional(),
            "queryStringBlacklist": t.array(t.string()).optional(),
            "includeHttpHeaders": t.array(t.string()).optional(),
            "includeQueryString": t.boolean().optional(),
            "includeProtocol": t.boolean().optional(),
            "includeHost": t.boolean().optional(),
            "includeNamedCookies": t.array(t.string()).optional(),
        }
    ).named(renames["CacheKeyPolicyIn"])
    types["CacheKeyPolicyOut"] = t.struct(
        {
            "queryStringWhitelist": t.array(t.string()).optional(),
            "queryStringBlacklist": t.array(t.string()).optional(),
            "includeHttpHeaders": t.array(t.string()).optional(),
            "includeQueryString": t.boolean().optional(),
            "includeProtocol": t.boolean().optional(),
            "includeHost": t.boolean().optional(),
            "includeNamedCookies": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["CacheKeyPolicyOut"])
    types["CommitmentsScopedListIn"] = t.struct(
        {
            "commitments": t.array(t.proxy(renames["CommitmentIn"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["CommitmentsScopedListIn"])
    types["CommitmentsScopedListOut"] = t.struct(
        {
            "commitments": t.array(t.proxy(renames["CommitmentOut"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["CommitmentsScopedListOut"])
    types["ResourcePolicyResourceStatusInstanceSchedulePolicyStatusIn"] = t.struct(
        {
            "nextRunStartTime": t.string().optional(),
            "lastRunStartTime": t.string().optional(),
        }
    ).named(renames["ResourcePolicyResourceStatusInstanceSchedulePolicyStatusIn"])
    types["ResourcePolicyResourceStatusInstanceSchedulePolicyStatusOut"] = t.struct(
        {
            "nextRunStartTime": t.string().optional(),
            "lastRunStartTime": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicyResourceStatusInstanceSchedulePolicyStatusOut"])
    types["RegionInstanceGroupManagersListInstancesResponseIn"] = t.struct(
        {
            "managedInstances": t.array(
                t.proxy(renames["ManagedInstanceIn"])
            ).optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["RegionInstanceGroupManagersListInstancesResponseIn"])
    types["RegionInstanceGroupManagersListInstancesResponseOut"] = t.struct(
        {
            "managedInstances": t.array(
                t.proxy(renames["ManagedInstanceOut"])
            ).optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagersListInstancesResponseOut"])
    types["ErrorInfoIn"] = t.struct(
        {
            "metadatas": t.struct({"_": t.string().optional()}).optional(),
            "reason": t.string().optional(),
            "domain": t.string().optional(),
        }
    ).named(renames["ErrorInfoIn"])
    types["ErrorInfoOut"] = t.struct(
        {
            "metadatas": t.struct({"_": t.string().optional()}).optional(),
            "reason": t.string().optional(),
            "domain": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ErrorInfoOut"])
    types["XpnResourceIdIn"] = t.struct(
        {"type": t.string().optional(), "id": t.string().optional()}
    ).named(renames["XpnResourceIdIn"])
    types["XpnResourceIdOut"] = t.struct(
        {
            "type": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["XpnResourceIdOut"])
    types["InstanceListReferrersIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["ReferenceIn"])).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["InstanceListReferrersIn"])
    types["InstanceListReferrersOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["ReferenceOut"])).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceListReferrersOut"])
    types["NodeGroupIn"] = t.struct(
        {
            "autoscalingPolicy": t.proxy(
                renames["NodeGroupAutoscalingPolicyIn"]
            ).optional(),
            "status": t.string(),
            "fingerprint": t.string(),
            "zone": t.string().optional(),
            "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
            "locationHint": t.string().optional(),
            "maintenancePolicy": t.string().optional(),
            "description": t.string().optional(),
            "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
            "nodeTemplate": t.string().optional(),
            "size": t.integer().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
        }
    ).named(renames["NodeGroupIn"])
    types["NodeGroupOut"] = t.struct(
        {
            "autoscalingPolicy": t.proxy(
                renames["NodeGroupAutoscalingPolicyOut"]
            ).optional(),
            "status": t.string(),
            "fingerprint": t.string(),
            "zone": t.string().optional(),
            "shareSettings": t.proxy(renames["ShareSettingsOut"]).optional(),
            "locationHint": t.string().optional(),
            "maintenancePolicy": t.string().optional(),
            "description": t.string().optional(),
            "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowOut"]),
            "nodeTemplate": t.string().optional(),
            "size": t.integer().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeGroupOut"])
    types["RouterNatRuleIn"] = t.struct(
        {
            "match": t.string().optional(),
            "ruleNumber": t.integer().optional(),
            "description": t.string().optional(),
            "action": t.proxy(renames["RouterNatRuleActionIn"]).optional(),
        }
    ).named(renames["RouterNatRuleIn"])
    types["RouterNatRuleOut"] = t.struct(
        {
            "match": t.string().optional(),
            "ruleNumber": t.integer().optional(),
            "description": t.string().optional(),
            "action": t.proxy(renames["RouterNatRuleActionOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterNatRuleOut"])
    types["BackendServiceCdnPolicyIn"] = t.struct(
        {
            "cacheKeyPolicy": t.proxy(renames["CacheKeyPolicyIn"]).optional(),
            "serveWhileStale": t.integer().optional(),
            "signedUrlCacheMaxAgeSec": t.string().optional(),
            "maxTtl": t.integer().optional(),
            "defaultTtl": t.integer().optional(),
            "clientTtl": t.integer().optional(),
            "negativeCaching": t.boolean().optional(),
            "signedUrlKeyNames": t.array(t.string()).optional(),
            "cacheMode": t.string().optional(),
            "bypassCacheOnRequestHeaders": t.array(
                t.proxy(renames["BackendServiceCdnPolicyBypassCacheOnRequestHeaderIn"])
            ).optional(),
            "requestCoalescing": t.boolean().optional(),
            "negativeCachingPolicy": t.array(
                t.proxy(renames["BackendServiceCdnPolicyNegativeCachingPolicyIn"])
            ).optional(),
        }
    ).named(renames["BackendServiceCdnPolicyIn"])
    types["BackendServiceCdnPolicyOut"] = t.struct(
        {
            "cacheKeyPolicy": t.proxy(renames["CacheKeyPolicyOut"]).optional(),
            "serveWhileStale": t.integer().optional(),
            "signedUrlCacheMaxAgeSec": t.string().optional(),
            "maxTtl": t.integer().optional(),
            "defaultTtl": t.integer().optional(),
            "clientTtl": t.integer().optional(),
            "negativeCaching": t.boolean().optional(),
            "signedUrlKeyNames": t.array(t.string()).optional(),
            "cacheMode": t.string().optional(),
            "bypassCacheOnRequestHeaders": t.array(
                t.proxy(renames["BackendServiceCdnPolicyBypassCacheOnRequestHeaderOut"])
            ).optional(),
            "requestCoalescing": t.boolean().optional(),
            "negativeCachingPolicy": t.array(
                t.proxy(renames["BackendServiceCdnPolicyNegativeCachingPolicyOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceCdnPolicyOut"])
    types["ServerBindingIn"] = t.struct({"type": t.string()}).named(
        renames["ServerBindingIn"]
    )
    types["ServerBindingOut"] = t.struct(
        {"type": t.string(), "error": t.proxy(renames["ErrorResponse"]).optional()}
    ).named(renames["ServerBindingOut"])
    types["TargetGrpcProxyListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["TargetGrpcProxyIn"])).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["TargetGrpcProxyListIn"])
    types["TargetGrpcProxyListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["TargetGrpcProxyOut"])).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetGrpcProxyListOut"])
    types["AutoscalerAggregatedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["AutoscalerAggregatedListIn"])
    types["AutoscalerAggregatedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AutoscalerAggregatedListOut"])
    types["DiskListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["DiskIn"])).optional(),
            "id": t.string().optional(),
        }
    ).named(renames["DiskListIn"])
    types["DiskListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["DiskOut"])).optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DiskListOut"])
    types["SecurityPolicyRuleMatcherIn"] = t.struct(
        {
            "config": t.proxy(renames["SecurityPolicyRuleMatcherConfigIn"]).optional(),
            "versionedExpr": t.string().optional(),
            "expr": t.proxy(renames["ExprIn"]).optional(),
        }
    ).named(renames["SecurityPolicyRuleMatcherIn"])
    types["SecurityPolicyRuleMatcherOut"] = t.struct(
        {
            "config": t.proxy(renames["SecurityPolicyRuleMatcherConfigOut"]).optional(),
            "versionedExpr": t.string().optional(),
            "expr": t.proxy(renames["ExprOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyRuleMatcherOut"])
    types["TargetPoolsAddInstanceRequestIn"] = t.struct(
        {"instances": t.array(t.proxy(renames["InstanceReferenceIn"])).optional()}
    ).named(renames["TargetPoolsAddInstanceRequestIn"])
    types["TargetPoolsAddInstanceRequestOut"] = t.struct(
        {
            "instances": t.array(t.proxy(renames["InstanceReferenceOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetPoolsAddInstanceRequestOut"])
    types["VmEndpointNatMappingsInterfaceNatMappingsIn"] = t.struct(
        {
            "sourceVirtualIp": t.string().optional(),
            "numTotalNatPorts": t.integer().optional(),
            "ruleMappings": t.array(
                t.proxy(
                    renames[
                        "VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappingsIn"
                    ]
                )
            ).optional(),
            "natIpPortRanges": t.array(t.string()).optional(),
            "numTotalDrainNatPorts": t.integer().optional(),
            "drainNatIpPortRanges": t.array(t.string()).optional(),
            "sourceAliasIpRange": t.string().optional(),
        }
    ).named(renames["VmEndpointNatMappingsInterfaceNatMappingsIn"])
    types["VmEndpointNatMappingsInterfaceNatMappingsOut"] = t.struct(
        {
            "sourceVirtualIp": t.string().optional(),
            "numTotalNatPorts": t.integer().optional(),
            "ruleMappings": t.array(
                t.proxy(
                    renames[
                        "VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappingsOut"
                    ]
                )
            ).optional(),
            "natIpPortRanges": t.array(t.string()).optional(),
            "numTotalDrainNatPorts": t.integer().optional(),
            "drainNatIpPortRanges": t.array(t.string()).optional(),
            "sourceAliasIpRange": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VmEndpointNatMappingsInterfaceNatMappingsOut"])
    types["TargetHttpsProxyAggregatedListIn"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["TargetHttpsProxyAggregatedListIn"])
    types["TargetHttpsProxyAggregatedListOut"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetHttpsProxyAggregatedListOut"])
    types["VpnGatewaysScopedListIn"] = t.struct(
        {
            "vpnGateways": t.array(t.proxy(renames["VpnGatewayIn"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["VpnGatewaysScopedListIn"])
    types["VpnGatewaysScopedListOut"] = t.struct(
        {
            "vpnGateways": t.array(t.proxy(renames["VpnGatewayOut"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnGatewaysScopedListOut"])
    types["BackendServiceIAPIn"] = t.struct(
        {
            "oauth2ClientId": t.string().optional(),
            "oauth2ClientSecret": t.string().optional(),
            "oauth2ClientSecretSha256": t.string().optional(),
            "enabled": t.boolean().optional(),
        }
    ).named(renames["BackendServiceIAPIn"])
    types["BackendServiceIAPOut"] = t.struct(
        {
            "oauth2ClientId": t.string().optional(),
            "oauth2ClientSecret": t.string().optional(),
            "oauth2ClientSecretSha256": t.string().optional(),
            "enabled": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceIAPOut"])
    types["TargetVpnGatewaysScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "targetVpnGateways": t.array(
                t.proxy(renames["TargetVpnGatewayIn"])
            ).optional(),
        }
    ).named(renames["TargetVpnGatewaysScopedListIn"])
    types["TargetVpnGatewaysScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "targetVpnGateways": t.array(
                t.proxy(renames["TargetVpnGatewayOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetVpnGatewaysScopedListOut"])
    types["RegionInstanceGroupManagersAbandonInstancesRequestIn"] = t.struct(
        {"instances": t.array(t.string()).optional()}
    ).named(renames["RegionInstanceGroupManagersAbandonInstancesRequestIn"])
    types["RegionInstanceGroupManagersAbandonInstancesRequestOut"] = t.struct(
        {
            "instances": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagersAbandonInstancesRequestOut"])
    types["SslPoliciesScopedListIn"] = t.struct(
        {
            "sslPolicies": t.array(t.proxy(renames["SslPolicyIn"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["SslPoliciesScopedListIn"])
    types["SslPoliciesScopedListOut"] = t.struct(
        {
            "sslPolicies": t.array(t.proxy(renames["SslPolicyOut"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SslPoliciesScopedListOut"])
    types["AutoscalerIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "statusDetails": t.array(
                t.proxy(renames["AutoscalerStatusDetailsIn"])
            ).optional(),
            "target": t.string().optional(),
            "autoscalingPolicy": t.proxy(renames["AutoscalingPolicyIn"]).optional(),
            "status": t.string().optional(),
            "recommendedSize": t.integer().optional(),
            "description": t.string().optional(),
            "zone": t.string().optional(),
            "id": t.string().optional(),
            "region": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "scalingScheduleStatus": t.struct({"_": t.string().optional()}).optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["AutoscalerIn"])
    types["AutoscalerOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "statusDetails": t.array(
                t.proxy(renames["AutoscalerStatusDetailsOut"])
            ).optional(),
            "target": t.string().optional(),
            "autoscalingPolicy": t.proxy(renames["AutoscalingPolicyOut"]).optional(),
            "status": t.string().optional(),
            "recommendedSize": t.integer().optional(),
            "description": t.string().optional(),
            "zone": t.string().optional(),
            "id": t.string().optional(),
            "region": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "scalingScheduleStatus": t.struct({"_": t.string().optional()}).optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AutoscalerOut"])
    types["RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseIn"] = t.struct(
        {
            "firewalls": t.array(t.proxy(renames["FirewallIn"])).optional(),
            "firewallPolicys": t.array(
                t.proxy(
                    renames[
                        "RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn"
                    ]
                )
            ).optional(),
        }
    ).named(renames["RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseIn"])
    types["RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseOut"] = t.struct(
        {
            "firewalls": t.array(t.proxy(renames["FirewallOut"])).optional(),
            "firewallPolicys": t.array(
                t.proxy(
                    renames[
                        "RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut"
                    ]
                )
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseOut"])
    types["MachineTypesScopedListIn"] = t.struct(
        {
            "machineTypes": t.array(t.proxy(renames["MachineTypeIn"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["MachineTypesScopedListIn"])
    types["MachineTypesScopedListOut"] = t.struct(
        {
            "machineTypes": t.array(t.proxy(renames["MachineTypeOut"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["MachineTypesScopedListOut"])
    types["InstanceMoveRequestIn"] = t.struct(
        {
            "destinationZone": t.string().optional(),
            "targetInstance": t.string().optional(),
        }
    ).named(renames["InstanceMoveRequestIn"])
    types["InstanceMoveRequestOut"] = t.struct(
        {
            "destinationZone": t.string().optional(),
            "targetInstance": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceMoveRequestOut"])
    types["ExchangedPeeringRoutesListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["ExchangedPeeringRouteIn"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["ExchangedPeeringRoutesListIn"])
    types["ExchangedPeeringRoutesListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["ExchangedPeeringRouteOut"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ExchangedPeeringRoutesListOut"])
    types["RouterAdvertisedIpRangeIn"] = t.struct(
        {"description": t.string().optional(), "range": t.string().optional()}
    ).named(renames["RouterAdvertisedIpRangeIn"])
    types["RouterAdvertisedIpRangeOut"] = t.struct(
        {
            "description": t.string().optional(),
            "range": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterAdvertisedIpRangeOut"])
    types["FirewallPolicyRuleMatcherIn"] = t.struct(
        {
            "destFqdns": t.array(t.string()).optional(),
            "srcAddressGroups": t.array(t.string()).optional(),
            "destAddressGroups": t.array(t.string()).optional(),
            "srcIpRanges": t.array(t.string()).optional(),
            "srcRegionCodes": t.array(t.string()).optional(),
            "layer4Configs": t.array(
                t.proxy(renames["FirewallPolicyRuleMatcherLayer4ConfigIn"])
            ).optional(),
            "destThreatIntelligences": t.array(t.string()).optional(),
            "destIpRanges": t.array(t.string()).optional(),
            "srcThreatIntelligences": t.array(t.string()).optional(),
            "destRegionCodes": t.array(t.string()).optional(),
            "srcSecureTags": t.array(
                t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
            ).optional(),
            "srcFqdns": t.array(t.string()).optional(),
        }
    ).named(renames["FirewallPolicyRuleMatcherIn"])
    types["FirewallPolicyRuleMatcherOut"] = t.struct(
        {
            "destFqdns": t.array(t.string()).optional(),
            "srcAddressGroups": t.array(t.string()).optional(),
            "destAddressGroups": t.array(t.string()).optional(),
            "srcIpRanges": t.array(t.string()).optional(),
            "srcRegionCodes": t.array(t.string()).optional(),
            "layer4Configs": t.array(
                t.proxy(renames["FirewallPolicyRuleMatcherLayer4ConfigOut"])
            ).optional(),
            "destThreatIntelligences": t.array(t.string()).optional(),
            "destIpRanges": t.array(t.string()).optional(),
            "srcThreatIntelligences": t.array(t.string()).optional(),
            "destRegionCodes": t.array(t.string()).optional(),
            "srcSecureTags": t.array(
                t.proxy(renames["FirewallPolicyRuleSecureTagOut"])
            ).optional(),
            "srcFqdns": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["FirewallPolicyRuleMatcherOut"])
    types["LicenseCodeIn"] = t.struct(
        {
            "licenseAlias": t.array(
                t.proxy(renames["LicenseCodeLicenseAliasIn"])
            ).optional(),
            "transferable": t.boolean().optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "state": t.string().optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["LicenseCodeIn"])
    types["LicenseCodeOut"] = t.struct(
        {
            "licenseAlias": t.array(
                t.proxy(renames["LicenseCodeLicenseAliasOut"])
            ).optional(),
            "transferable": t.boolean().optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "state": t.string().optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LicenseCodeOut"])
    types["SslCertificateListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["SslCertificateIn"])).optional(),
        }
    ).named(renames["SslCertificateListIn"])
    types["SslCertificateListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["SslCertificateOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SslCertificateListOut"])
    types["ConsistentHashLoadBalancerSettingsIn"] = t.struct(
        {
            "minimumRingSize": t.string().optional(),
            "httpCookie": t.proxy(
                renames["ConsistentHashLoadBalancerSettingsHttpCookieIn"]
            ).optional(),
            "httpHeaderName": t.string().optional(),
        }
    ).named(renames["ConsistentHashLoadBalancerSettingsIn"])
    types["ConsistentHashLoadBalancerSettingsOut"] = t.struct(
        {
            "minimumRingSize": t.string().optional(),
            "httpCookie": t.proxy(
                renames["ConsistentHashLoadBalancerSettingsHttpCookieOut"]
            ).optional(),
            "httpHeaderName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ConsistentHashLoadBalancerSettingsOut"])
    types["ResourcePolicyIn"] = t.struct(
        {
            "instanceSchedulePolicy": t.proxy(
                renames["ResourcePolicyInstanceSchedulePolicyIn"]
            ).optional(),
            "resourceStatus": t.proxy(
                renames["ResourcePolicyResourceStatusIn"]
            ).optional(),
            "name": t.string().optional(),
            "groupPlacementPolicy": t.proxy(
                renames["ResourcePolicyGroupPlacementPolicyIn"]
            ).optional(),
            "kind": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "description": t.string(),
            "snapshotSchedulePolicy": t.proxy(
                renames["ResourcePolicySnapshotSchedulePolicyIn"]
            ).optional(),
            "status": t.string().optional(),
            "diskConsistencyGroupPolicy": t.proxy(
                renames["ResourcePolicyDiskConsistencyGroupPolicyIn"]
            ).optional(),
            "region": t.string(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["ResourcePolicyIn"])
    types["ResourcePolicyOut"] = t.struct(
        {
            "instanceSchedulePolicy": t.proxy(
                renames["ResourcePolicyInstanceSchedulePolicyOut"]
            ).optional(),
            "resourceStatus": t.proxy(
                renames["ResourcePolicyResourceStatusOut"]
            ).optional(),
            "name": t.string().optional(),
            "groupPlacementPolicy": t.proxy(
                renames["ResourcePolicyGroupPlacementPolicyOut"]
            ).optional(),
            "kind": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "description": t.string(),
            "snapshotSchedulePolicy": t.proxy(
                renames["ResourcePolicySnapshotSchedulePolicyOut"]
            ).optional(),
            "status": t.string().optional(),
            "diskConsistencyGroupPolicy": t.proxy(
                renames["ResourcePolicyDiskConsistencyGroupPolicyOut"]
            ).optional(),
            "region": t.string(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicyOut"])
    types["ImageListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["ImageIn"])).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["ImageListIn"])
    types["ImageListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["ImageOut"])).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ImageListOut"])
    types["InstanceGroupManagersScopedListIn"] = t.struct(
        {
            "instanceGroupManagers": t.array(
                t.proxy(renames["InstanceGroupManagerIn"])
            ).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["InstanceGroupManagersScopedListIn"])
    types["InstanceGroupManagersScopedListOut"] = t.struct(
        {
            "instanceGroupManagers": t.array(
                t.proxy(renames["InstanceGroupManagerOut"])
            ).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersScopedListOut"])
    types["RegionInstanceGroupManagersDeleteInstancesRequestIn"] = t.struct(
        {
            "skipInstancesOnValidationError": t.boolean().optional(),
            "instances": t.array(t.string()).optional(),
        }
    ).named(renames["RegionInstanceGroupManagersDeleteInstancesRequestIn"])
    types["RegionInstanceGroupManagersDeleteInstancesRequestOut"] = t.struct(
        {
            "skipInstancesOnValidationError": t.boolean().optional(),
            "instances": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagersDeleteInstancesRequestOut"])
    types["ForwardingRuleReferenceIn"] = t.struct({"forwardingRule": t.string()}).named(
        renames["ForwardingRuleReferenceIn"]
    )
    types["ForwardingRuleReferenceOut"] = t.struct(
        {
            "forwardingRule": t.string(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ForwardingRuleReferenceOut"])
    types["LicensesListResponseIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["LicenseIn"])).optional(),
            "id": t.string().optional(),
        }
    ).named(renames["LicensesListResponseIn"])
    types["LicensesListResponseOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["LicenseOut"])).optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LicensesListResponseOut"])
    types["ReferenceIn"] = t.struct(
        {
            "referenceType": t.string().optional(),
            "kind": t.string().optional(),
            "target": t.string().optional(),
            "referrer": t.string().optional(),
        }
    ).named(renames["ReferenceIn"])
    types["ReferenceOut"] = t.struct(
        {
            "referenceType": t.string().optional(),
            "kind": t.string().optional(),
            "target": t.string().optional(),
            "referrer": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ReferenceOut"])
    types["InstanceGroupManagerIn"] = t.struct(
        {
            "baseInstanceName": t.string().optional(),
            "targetSize": t.integer().optional(),
            "status": t.proxy(renames["InstanceGroupManagerStatusIn"]).optional(),
            "name": t.string().optional(),
            "autoHealingPolicies": t.array(
                t.proxy(renames["InstanceGroupManagerAutoHealingPolicyIn"])
            ).optional(),
            "description": t.string().optional(),
            "updatePolicy": t.proxy(
                renames["InstanceGroupManagerUpdatePolicyIn"]
            ).optional(),
            "id": t.string().optional(),
            "targetPools": t.array(t.string()).optional(),
            "zone": t.string().optional(),
            "fingerprint": t.string().optional(),
            "namedPorts": t.array(t.proxy(renames["NamedPortIn"])).optional(),
            "versions": t.array(
                t.proxy(renames["InstanceGroupManagerVersionIn"])
            ).optional(),
            "creationTimestamp": t.string().optional(),
            "region": t.string().optional(),
            "instanceTemplate": t.string().optional(),
            "statefulPolicy": t.proxy(renames["StatefulPolicyIn"]).optional(),
            "kind": t.string().optional(),
            "currentActions": t.proxy(
                renames["InstanceGroupManagerActionsSummaryIn"]
            ).optional(),
            "listManagedInstancesResults": t.string().optional(),
            "selfLink": t.string().optional(),
            "instanceGroup": t.string().optional(),
            "distributionPolicy": t.proxy(renames["DistributionPolicyIn"]).optional(),
        }
    ).named(renames["InstanceGroupManagerIn"])
    types["InstanceGroupManagerOut"] = t.struct(
        {
            "baseInstanceName": t.string().optional(),
            "targetSize": t.integer().optional(),
            "status": t.proxy(renames["InstanceGroupManagerStatusOut"]).optional(),
            "name": t.string().optional(),
            "autoHealingPolicies": t.array(
                t.proxy(renames["InstanceGroupManagerAutoHealingPolicyOut"])
            ).optional(),
            "description": t.string().optional(),
            "updatePolicy": t.proxy(
                renames["InstanceGroupManagerUpdatePolicyOut"]
            ).optional(),
            "id": t.string().optional(),
            "targetPools": t.array(t.string()).optional(),
            "zone": t.string().optional(),
            "fingerprint": t.string().optional(),
            "namedPorts": t.array(t.proxy(renames["NamedPortOut"])).optional(),
            "versions": t.array(
                t.proxy(renames["InstanceGroupManagerVersionOut"])
            ).optional(),
            "creationTimestamp": t.string().optional(),
            "region": t.string().optional(),
            "instanceTemplate": t.string().optional(),
            "statefulPolicy": t.proxy(renames["StatefulPolicyOut"]).optional(),
            "kind": t.string().optional(),
            "currentActions": t.proxy(
                renames["InstanceGroupManagerActionsSummaryOut"]
            ).optional(),
            "listManagedInstancesResults": t.string().optional(),
            "selfLink": t.string().optional(),
            "instanceGroup": t.string().optional(),
            "distributionPolicy": t.proxy(renames["DistributionPolicyOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagerOut"])
    types["ProjectsDisableXpnResourceRequestIn"] = t.struct(
        {"xpnResource": t.proxy(renames["XpnResourceIdIn"]).optional()}
    ).named(renames["ProjectsDisableXpnResourceRequestIn"])
    types["ProjectsDisableXpnResourceRequestOut"] = t.struct(
        {
            "xpnResource": t.proxy(renames["XpnResourceIdOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ProjectsDisableXpnResourceRequestOut"])
    types["InstanceManagedByIgmErrorIn"] = t.struct(
        {
            "instanceActionDetails": t.proxy(
                renames["InstanceManagedByIgmErrorInstanceActionDetailsIn"]
            ).optional(),
            "timestamp": t.string().optional(),
            "error": t.proxy(
                renames["InstanceManagedByIgmErrorManagedInstanceErrorIn"]
            ).optional(),
        }
    ).named(renames["InstanceManagedByIgmErrorIn"])
    types["InstanceManagedByIgmErrorOut"] = t.struct(
        {
            "instanceActionDetails": t.proxy(
                renames["InstanceManagedByIgmErrorInstanceActionDetailsOut"]
            ).optional(),
            "timestamp": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceManagedByIgmErrorOut"])
    types["ManagedInstanceVersionIn"] = t.struct(
        {"instanceTemplate": t.string().optional(), "name": t.string().optional()}
    ).named(renames["ManagedInstanceVersionIn"])
    types["ManagedInstanceVersionOut"] = t.struct(
        {
            "instanceTemplate": t.string().optional(),
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ManagedInstanceVersionOut"])
    types["PacketMirroringIn"] = t.struct(
        {
            "enable": t.string().optional(),
            "filter": t.proxy(renames["PacketMirroringFilterIn"]).optional(),
            "network": t.proxy(renames["PacketMirroringNetworkInfoIn"]).optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "selfLink": t.string().optional(),
            "mirroredResources": t.proxy(
                renames["PacketMirroringMirroredResourceInfoIn"]
            ).optional(),
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "priority": t.integer().optional(),
            "region": t.string().optional(),
            "collectorIlb": t.proxy(
                renames["PacketMirroringForwardingRuleInfoIn"]
            ).optional(),
        }
    ).named(renames["PacketMirroringIn"])
    types["PacketMirroringOut"] = t.struct(
        {
            "enable": t.string().optional(),
            "filter": t.proxy(renames["PacketMirroringFilterOut"]).optional(),
            "network": t.proxy(renames["PacketMirroringNetworkInfoOut"]).optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "selfLink": t.string().optional(),
            "mirroredResources": t.proxy(
                renames["PacketMirroringMirroredResourceInfoOut"]
            ).optional(),
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "priority": t.integer().optional(),
            "region": t.string().optional(),
            "collectorIlb": t.proxy(
                renames["PacketMirroringForwardingRuleInfoOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PacketMirroringOut"])
    types["InstanceGroupManagerListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceGroupManagerIn"])).optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["InstanceGroupManagerListIn"])
    types["InstanceGroupManagerListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceGroupManagerOut"])).optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagerListOut"])
    types["BackendBucketCdnPolicyNegativeCachingPolicyIn"] = t.struct(
        {"ttl": t.integer().optional(), "code": t.integer().optional()}
    ).named(renames["BackendBucketCdnPolicyNegativeCachingPolicyIn"])
    types["BackendBucketCdnPolicyNegativeCachingPolicyOut"] = t.struct(
        {
            "ttl": t.integer().optional(),
            "code": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendBucketCdnPolicyNegativeCachingPolicyOut"])
    types["RegionInstanceGroupListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceGroupIn"])).optional(),
        }
    ).named(renames["RegionInstanceGroupListIn"])
    types["RegionInstanceGroupListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceGroupOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupListOut"])
    types["BackendBucketListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["BackendBucketIn"])).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["BackendBucketListIn"])
    types["BackendBucketListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["BackendBucketOut"])).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendBucketListOut"])
    types["BackendServiceGroupHealthIn"] = t.struct(
        {
            "annotations": t.struct({"_": t.string().optional()}).optional(),
            "kind": t.string().optional(),
            "healthStatus": t.array(t.proxy(renames["HealthStatusIn"])).optional(),
        }
    ).named(renames["BackendServiceGroupHealthIn"])
    types["BackendServiceGroupHealthOut"] = t.struct(
        {
            "annotations": t.struct({"_": t.string().optional()}).optional(),
            "kind": t.string().optional(),
            "healthStatus": t.array(t.proxy(renames["HealthStatusOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceGroupHealthOut"])
    types["LicenseIn"] = t.struct(
        {
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "transferable": t.boolean().optional(),
            "name": t.string().optional(),
            "description": t.string().optional(),
            "selfLink": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "licenseCode": t.string().optional(),
            "chargesUseFee": t.boolean().optional(),
            "resourceRequirements": t.proxy(renames["LicenseResourceRequirementsIn"]),
        }
    ).named(renames["LicenseIn"])
    types["LicenseOut"] = t.struct(
        {
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "transferable": t.boolean().optional(),
            "name": t.string().optional(),
            "description": t.string().optional(),
            "selfLink": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "licenseCode": t.string().optional(),
            "chargesUseFee": t.boolean().optional(),
            "resourceRequirements": t.proxy(renames["LicenseResourceRequirementsOut"]),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LicenseOut"])
    types["ProjectIn"] = t.struct(
        {
            "defaultNetworkTier": t.string().optional(),
            "xpnProjectStatus": t.string().optional(),
            "vmDnsSetting": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "commonInstanceMetadata": t.proxy(renames["MetadataIn"]).optional(),
            "usageExportLocation": t.proxy(renames["UsageExportLocationIn"]).optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "quotas": t.array(t.proxy(renames["QuotaIn"])).optional(),
            "defaultServiceAccount": t.string().optional(),
            "enabledFeatures": t.array(t.string()).optional(),
            "name": t.string().optional(),
        }
    ).named(renames["ProjectIn"])
    types["ProjectOut"] = t.struct(
        {
            "defaultNetworkTier": t.string().optional(),
            "xpnProjectStatus": t.string().optional(),
            "vmDnsSetting": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "commonInstanceMetadata": t.proxy(renames["MetadataOut"]).optional(),
            "usageExportLocation": t.proxy(
                renames["UsageExportLocationOut"]
            ).optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "quotas": t.array(t.proxy(renames["QuotaOut"])).optional(),
            "defaultServiceAccount": t.string().optional(),
            "enabledFeatures": t.array(t.string()).optional(),
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ProjectOut"])
    types["GuestAttributesValueIn"] = t.struct(
        {"items": t.array(t.proxy(renames["GuestAttributesEntryIn"]))}
    ).named(renames["GuestAttributesValueIn"])
    types["GuestAttributesValueOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["GuestAttributesEntryOut"])),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["GuestAttributesValueOut"])
    types["PacketMirroringFilterIn"] = t.struct(
        {
            "IPProtocols": t.array(t.string()).optional(),
            "direction": t.string().optional(),
            "cidrRanges": t.array(t.string()).optional(),
        }
    ).named(renames["PacketMirroringFilterIn"])
    types["PacketMirroringFilterOut"] = t.struct(
        {
            "IPProtocols": t.array(t.string()).optional(),
            "direction": t.string().optional(),
            "cidrRanges": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PacketMirroringFilterOut"])
    types["ReservationsResizeRequestIn"] = t.struct(
        {"specificSkuCount": t.string().optional()}
    ).named(renames["ReservationsResizeRequestIn"])
    types["ReservationsResizeRequestOut"] = t.struct(
        {
            "specificSkuCount": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ReservationsResizeRequestOut"])
    types["ConnectionDrainingIn"] = t.struct(
        {"drainingTimeoutSec": t.integer().optional()}
    ).named(renames["ConnectionDrainingIn"])
    types["ConnectionDrainingOut"] = t.struct(
        {
            "drainingTimeoutSec": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ConnectionDrainingOut"])
    types["GlobalAddressesMoveRequestIn"] = t.struct(
        {
            "description": t.string().optional(),
            "destinationAddress": t.string().optional(),
        }
    ).named(renames["GlobalAddressesMoveRequestIn"])
    types["GlobalAddressesMoveRequestOut"] = t.struct(
        {
            "description": t.string().optional(),
            "destinationAddress": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["GlobalAddressesMoveRequestOut"])
    types["AutoscalingPolicyLoadBalancingUtilizationIn"] = t.struct(
        {"utilizationTarget": t.number().optional()}
    ).named(renames["AutoscalingPolicyLoadBalancingUtilizationIn"])
    types["AutoscalingPolicyLoadBalancingUtilizationOut"] = t.struct(
        {
            "utilizationTarget": t.number().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AutoscalingPolicyLoadBalancingUtilizationOut"])
    types["TargetTcpProxiesSetProxyHeaderRequestIn"] = t.struct(
        {"proxyHeader": t.string().optional()}
    ).named(renames["TargetTcpProxiesSetProxyHeaderRequestIn"])
    types["TargetTcpProxiesSetProxyHeaderRequestOut"] = t.struct(
        {
            "proxyHeader": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetTcpProxiesSetProxyHeaderRequestOut"])
    types["WeightedBackendServiceIn"] = t.struct(
        {
            "headerAction": t.proxy(renames["HttpHeaderActionIn"]).optional(),
            "weight": t.integer().optional(),
            "backendService": t.string().optional(),
        }
    ).named(renames["WeightedBackendServiceIn"])
    types["WeightedBackendServiceOut"] = t.struct(
        {
            "headerAction": t.proxy(renames["HttpHeaderActionOut"]).optional(),
            "weight": t.integer().optional(),
            "backendService": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["WeightedBackendServiceOut"])
    types["DiskResourceStatusIn"] = t.struct(
        {
            "asyncPrimaryDisk": t.proxy(
                renames["DiskResourceStatusAsyncReplicationStatusIn"]
            ),
            "asyncSecondaryDisks": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["DiskResourceStatusIn"])
    types["DiskResourceStatusOut"] = t.struct(
        {
            "asyncPrimaryDisk": t.proxy(
                renames["DiskResourceStatusAsyncReplicationStatusOut"]
            ),
            "asyncSecondaryDisks": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DiskResourceStatusOut"])
    types["RegionInstanceGroupsSetNamedPortsRequestIn"] = t.struct(
        {
            "namedPorts": t.array(t.proxy(renames["NamedPortIn"])).optional(),
            "fingerprint": t.string().optional(),
        }
    ).named(renames["RegionInstanceGroupsSetNamedPortsRequestIn"])
    types["RegionInstanceGroupsSetNamedPortsRequestOut"] = t.struct(
        {
            "namedPorts": t.array(t.proxy(renames["NamedPortOut"])).optional(),
            "fingerprint": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupsSetNamedPortsRequestOut"])
    types["TargetPoolsAddHealthCheckRequestIn"] = t.struct(
        {"healthChecks": t.array(t.proxy(renames["HealthCheckReferenceIn"])).optional()}
    ).named(renames["TargetPoolsAddHealthCheckRequestIn"])
    types["TargetPoolsAddHealthCheckRequestOut"] = t.struct(
        {
            "healthChecks": t.array(
                t.proxy(renames["HealthCheckReferenceOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetPoolsAddHealthCheckRequestOut"])
    types["PerInstanceConfigIn"] = t.struct(
        {
            "status": t.string().optional(),
            "name": t.string().optional(),
            "preservedState": t.proxy(renames["PreservedStateIn"]).optional(),
            "fingerprint": t.string().optional(),
        }
    ).named(renames["PerInstanceConfigIn"])
    types["PerInstanceConfigOut"] = t.struct(
        {
            "status": t.string().optional(),
            "name": t.string().optional(),
            "preservedState": t.proxy(renames["PreservedStateOut"]).optional(),
            "fingerprint": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PerInstanceConfigOut"])
    types["RouterNatSubnetworkToNatIn"] = t.struct(
        {
            "name": t.string().optional(),
            "sourceIpRangesToNat": t.array(t.string()).optional(),
            "secondaryIpRangeNames": t.array(t.string()).optional(),
        }
    ).named(renames["RouterNatSubnetworkToNatIn"])
    types["RouterNatSubnetworkToNatOut"] = t.struct(
        {
            "name": t.string().optional(),
            "sourceIpRangesToNat": t.array(t.string()).optional(),
            "secondaryIpRangeNames": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterNatSubnetworkToNatOut"])
    types["HttpFaultInjectionIn"] = t.struct(
        {
            "delay": t.proxy(renames["HttpFaultDelayIn"]).optional(),
            "abort": t.proxy(renames["HttpFaultAbortIn"]).optional(),
        }
    ).named(renames["HttpFaultInjectionIn"])
    types["HttpFaultInjectionOut"] = t.struct(
        {
            "delay": t.proxy(renames["HttpFaultDelayOut"]).optional(),
            "abort": t.proxy(renames["HttpFaultAbortOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpFaultInjectionOut"])
    types["DiskIn"] = t.struct(
        {
            "licenses": t.array(t.string()).optional(),
            "creationTimestamp": t.string().optional(),
            "diskEncryptionKey": t.proxy(renames["CustomerEncryptionKeyIn"]).optional(),
            "replicaZones": t.array(t.string()).optional(),
            "id": t.string().optional(),
            "sourceImageId": t.string().optional(),
            "physicalBlockSizeBytes": t.string().optional(),
            "sourceConsistencyGroupPolicyId": t.string().optional(),
            "sourceDisk": t.string().optional(),
            "options": t.string().optional(),
            "asyncSecondaryDisks": t.struct({"_": t.string().optional()}).optional(),
            "licenseCodes": t.array(t.string()).optional(),
            "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
            "guestOsFeatures": t.array(t.proxy(renames["GuestOsFeatureIn"])).optional(),
            "sourceSnapshotEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyIn"]
            ).optional(),
            "sourceStorageObject": t.string().optional(),
            "architecture": t.string().optional(),
            "users": t.array(t.string()).optional(),
            "region": t.string().optional(),
            "sourceSnapshotId": t.string().optional(),
            "zone": t.string().optional(),
            "params": t.proxy(renames["DiskParamsIn"]).optional(),
            "kind": t.string().optional(),
            "provisionedIops": t.string().optional(),
            "description": t.string().optional(),
            "status": t.string().optional(),
            "satisfiesPzs": t.boolean().optional(),
            "type": t.string().optional(),
            "sizeGb": t.string().optional(),
            "resourcePolicies": t.array(t.string()).optional(),
            "sourceDiskId": t.string().optional(),
            "asyncPrimaryDisk": t.proxy(renames["DiskAsyncReplicationIn"]).optional(),
            "sourceSnapshot": t.string().optional(),
            "locationHint": t.string().optional(),
            "sourceImage": t.string().optional(),
            "name": t.string().optional(),
            "lastDetachTimestamp": t.string().optional(),
            "selfLink": t.string().optional(),
            "sourceConsistencyGroupPolicy": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "sourceImageEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyIn"]
            ).optional(),
            "lastAttachTimestamp": t.string().optional(),
            "labelFingerprint": t.string().optional(),
            "provisionedThroughput": t.string().optional(),
        }
    ).named(renames["DiskIn"])
    types["DiskOut"] = t.struct(
        {
            "licenses": t.array(t.string()).optional(),
            "creationTimestamp": t.string().optional(),
            "diskEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "replicaZones": t.array(t.string()).optional(),
            "id": t.string().optional(),
            "sourceImageId": t.string().optional(),
            "physicalBlockSizeBytes": t.string().optional(),
            "sourceConsistencyGroupPolicyId": t.string().optional(),
            "sourceDisk": t.string().optional(),
            "options": t.string().optional(),
            "asyncSecondaryDisks": t.struct({"_": t.string().optional()}).optional(),
            "licenseCodes": t.array(t.string()).optional(),
            "resourceStatus": t.proxy(renames["DiskResourceStatusOut"]).optional(),
            "guestOsFeatures": t.array(
                t.proxy(renames["GuestOsFeatureOut"])
            ).optional(),
            "sourceSnapshotEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "sourceStorageObject": t.string().optional(),
            "architecture": t.string().optional(),
            "users": t.array(t.string()).optional(),
            "region": t.string().optional(),
            "sourceSnapshotId": t.string().optional(),
            "zone": t.string().optional(),
            "params": t.proxy(renames["DiskParamsOut"]).optional(),
            "kind": t.string().optional(),
            "provisionedIops": t.string().optional(),
            "description": t.string().optional(),
            "status": t.string().optional(),
            "satisfiesPzs": t.boolean().optional(),
            "type": t.string().optional(),
            "sizeGb": t.string().optional(),
            "resourcePolicies": t.array(t.string()).optional(),
            "sourceDiskId": t.string().optional(),
            "asyncPrimaryDisk": t.proxy(renames["DiskAsyncReplicationOut"]).optional(),
            "sourceSnapshot": t.string().optional(),
            "locationHint": t.string().optional(),
            "sourceImage": t.string().optional(),
            "name": t.string().optional(),
            "lastDetachTimestamp": t.string().optional(),
            "selfLink": t.string().optional(),
            "sourceConsistencyGroupPolicy": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "sourceImageEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "lastAttachTimestamp": t.string().optional(),
            "labelFingerprint": t.string().optional(),
            "provisionedThroughput": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DiskOut"])
    types["AcceleratorTypeListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["AcceleratorTypeIn"])).optional(),
        }
    ).named(renames["AcceleratorTypeListIn"])
    types["AcceleratorTypeListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["AcceleratorTypeOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AcceleratorTypeListOut"])
    types["UrlMapsScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "urlMaps": t.array(t.proxy(renames["UrlMapIn"])).optional(),
        }
    ).named(renames["UrlMapsScopedListIn"])
    types["UrlMapsScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "urlMaps": t.array(t.proxy(renames["UrlMapOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UrlMapsScopedListOut"])
    types["RouterStatusIn"] = t.struct(
        {
            "bestRoutes": t.array(t.proxy(renames["RouteIn"])).optional(),
            "bestRoutesForRouter": t.array(t.proxy(renames["RouteIn"])).optional(),
            "network": t.string().optional(),
            "natStatus": t.array(t.proxy(renames["RouterStatusNatStatusIn"])),
            "bgpPeerStatus": t.array(t.proxy(renames["RouterStatusBgpPeerStatusIn"])),
        }
    ).named(renames["RouterStatusIn"])
    types["RouterStatusOut"] = t.struct(
        {
            "bestRoutes": t.array(t.proxy(renames["RouteOut"])).optional(),
            "bestRoutesForRouter": t.array(t.proxy(renames["RouteOut"])).optional(),
            "network": t.string().optional(),
            "natStatus": t.array(t.proxy(renames["RouterStatusNatStatusOut"])),
            "bgpPeerStatus": t.array(t.proxy(renames["RouterStatusBgpPeerStatusOut"])),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterStatusOut"])
    types["PacketMirroringMirroredResourceInfoInstanceInfoIn"] = t.struct(
        {"url": t.string().optional(), "canonicalUrl": t.string().optional()}
    ).named(renames["PacketMirroringMirroredResourceInfoInstanceInfoIn"])
    types["PacketMirroringMirroredResourceInfoInstanceInfoOut"] = t.struct(
        {
            "url": t.string().optional(),
            "canonicalUrl": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PacketMirroringMirroredResourceInfoInstanceInfoOut"])
    types["SecurityPolicyReferenceIn"] = t.struct({"securityPolicy": t.string()}).named(
        renames["SecurityPolicyReferenceIn"]
    )
    types["SecurityPolicyReferenceOut"] = t.struct(
        {
            "securityPolicy": t.string(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyReferenceOut"])
    types["SecurityPolicyRuleIn"] = t.struct(
        {
            "rateLimitOptions": t.proxy(
                renames["SecurityPolicyRuleRateLimitOptionsIn"]
            ).optional(),
            "preconfiguredWafConfig": t.proxy(
                renames["SecurityPolicyRulePreconfiguredWafConfigIn"]
            ).optional(),
            "match": t.proxy(renames["SecurityPolicyRuleMatcherIn"]).optional(),
            "priority": t.integer().optional(),
            "kind": t.string().optional(),
            "redirectOptions": t.proxy(
                renames["SecurityPolicyRuleRedirectOptionsIn"]
            ).optional(),
            "preview": t.boolean().optional(),
            "action": t.string().optional(),
            "headerAction": t.proxy(
                renames["SecurityPolicyRuleHttpHeaderActionIn"]
            ).optional(),
            "description": t.string().optional(),
        }
    ).named(renames["SecurityPolicyRuleIn"])
    types["SecurityPolicyRuleOut"] = t.struct(
        {
            "rateLimitOptions": t.proxy(
                renames["SecurityPolicyRuleRateLimitOptionsOut"]
            ).optional(),
            "preconfiguredWafConfig": t.proxy(
                renames["SecurityPolicyRulePreconfiguredWafConfigOut"]
            ).optional(),
            "match": t.proxy(renames["SecurityPolicyRuleMatcherOut"]).optional(),
            "priority": t.integer().optional(),
            "kind": t.string().optional(),
            "redirectOptions": t.proxy(
                renames["SecurityPolicyRuleRedirectOptionsOut"]
            ).optional(),
            "preview": t.boolean().optional(),
            "action": t.string().optional(),
            "headerAction": t.proxy(
                renames["SecurityPolicyRuleHttpHeaderActionOut"]
            ).optional(),
            "description": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyRuleOut"])
    types["ExternalVpnGatewayIn"] = t.struct(
        {
            "interfaces": t.array(
                t.proxy(renames["ExternalVpnGatewayInterfaceIn"])
            ).optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "labelFingerprint": t.string().optional(),
            "redundancyType": t.string().optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "creationTimestamp": t.string().optional(),
        }
    ).named(renames["ExternalVpnGatewayIn"])
    types["ExternalVpnGatewayOut"] = t.struct(
        {
            "interfaces": t.array(
                t.proxy(renames["ExternalVpnGatewayInterfaceOut"])
            ).optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "labelFingerprint": t.string().optional(),
            "redundancyType": t.string().optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ExternalVpnGatewayOut"])
    types["SourceDiskEncryptionKeyIn"] = t.struct(
        {
            "sourceDisk": t.string().optional(),
            "diskEncryptionKey": t.proxy(renames["CustomerEncryptionKeyIn"]).optional(),
        }
    ).named(renames["SourceDiskEncryptionKeyIn"])
    types["SourceDiskEncryptionKeyOut"] = t.struct(
        {
            "sourceDisk": t.string().optional(),
            "diskEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SourceDiskEncryptionKeyOut"])
    types["MachineTypeIn"] = t.struct(
        {
            "memoryMb": t.integer().optional(),
            "isSharedCpu": t.boolean().optional(),
            "id": t.string().optional(),
            "scratchDisks": t.array(
                t.struct({"diskGb": t.integer().optional()})
            ).optional(),
            "maximumPersistentDisksSizeGb": t.string().optional(),
            "guestCpus": t.integer().optional(),
            "accelerators": t.array(
                t.struct(
                    {
                        "guestAcceleratorType": t.string().optional(),
                        "guestAcceleratorCount": t.integer().optional(),
                    }
                )
            ).optional(),
            "zone": t.string().optional(),
            "description": t.string().optional(),
            "imageSpaceGb": t.integer().optional(),
            "maximumPersistentDisks": t.integer().optional(),
            "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["MachineTypeIn"])
    types["MachineTypeOut"] = t.struct(
        {
            "memoryMb": t.integer().optional(),
            "isSharedCpu": t.boolean().optional(),
            "id": t.string().optional(),
            "scratchDisks": t.array(
                t.struct({"diskGb": t.integer().optional()})
            ).optional(),
            "maximumPersistentDisksSizeGb": t.string().optional(),
            "guestCpus": t.integer().optional(),
            "accelerators": t.array(
                t.struct(
                    {
                        "guestAcceleratorType": t.string().optional(),
                        "guestAcceleratorCount": t.integer().optional(),
                    }
                )
            ).optional(),
            "zone": t.string().optional(),
            "description": t.string().optional(),
            "imageSpaceGb": t.integer().optional(),
            "maximumPersistentDisks": t.integer().optional(),
            "deprecated": t.proxy(renames["DeprecationStatusOut"]).optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["MachineTypeOut"])
    types["ResourcePolicyResourceStatusIn"] = t.struct(
        {
            "instanceSchedulePolicy": t.proxy(
                renames["ResourcePolicyResourceStatusInstanceSchedulePolicyStatusIn"]
            ).optional()
        }
    ).named(renames["ResourcePolicyResourceStatusIn"])
    types["ResourcePolicyResourceStatusOut"] = t.struct(
        {
            "instanceSchedulePolicy": t.proxy(
                renames["ResourcePolicyResourceStatusInstanceSchedulePolicyStatusOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicyResourceStatusOut"])
    types["BackendServicesScopedListIn"] = t.struct(
        {
            "backendServices": t.array(t.proxy(renames["BackendServiceIn"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["BackendServicesScopedListIn"])
    types["BackendServicesScopedListOut"] = t.struct(
        {
            "backendServices": t.array(
                t.proxy(renames["BackendServiceOut"])
            ).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServicesScopedListOut"])
    types["TargetSslProxiesSetProxyHeaderRequestIn"] = t.struct(
        {"proxyHeader": t.string().optional()}
    ).named(renames["TargetSslProxiesSetProxyHeaderRequestIn"])
    types["TargetSslProxiesSetProxyHeaderRequestOut"] = t.struct(
        {
            "proxyHeader": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetSslProxiesSetProxyHeaderRequestOut"])
    types["HttpHeaderActionIn"] = t.struct(
        {
            "responseHeadersToRemove": t.array(t.string()).optional(),
            "requestHeadersToAdd": t.array(
                t.proxy(renames["HttpHeaderOptionIn"])
            ).optional(),
            "requestHeadersToRemove": t.array(t.string()).optional(),
            "responseHeadersToAdd": t.array(
                t.proxy(renames["HttpHeaderOptionIn"])
            ).optional(),
        }
    ).named(renames["HttpHeaderActionIn"])
    types["HttpHeaderActionOut"] = t.struct(
        {
            "responseHeadersToRemove": t.array(t.string()).optional(),
            "requestHeadersToAdd": t.array(
                t.proxy(renames["HttpHeaderOptionOut"])
            ).optional(),
            "requestHeadersToRemove": t.array(t.string()).optional(),
            "responseHeadersToAdd": t.array(
                t.proxy(renames["HttpHeaderOptionOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpHeaderActionOut"])
    types["SslCertificateIn"] = t.struct(
        {
            "creationTimestamp": t.string().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "description": t.string().optional(),
            "selfManaged": t.proxy(
                renames["SslCertificateSelfManagedSslCertificateIn"]
            ).optional(),
            "privateKey": t.string().optional(),
            "subjectAlternativeNames": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "expireTime": t.string().optional(),
            "managed": t.proxy(
                renames["SslCertificateManagedSslCertificateIn"]
            ).optional(),
            "region": t.string().optional(),
            "certificate": t.string().optional(),
            "type": t.string().optional(),
        }
    ).named(renames["SslCertificateIn"])
    types["SslCertificateOut"] = t.struct(
        {
            "creationTimestamp": t.string().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "description": t.string().optional(),
            "selfManaged": t.proxy(
                renames["SslCertificateSelfManagedSslCertificateOut"]
            ).optional(),
            "privateKey": t.string().optional(),
            "subjectAlternativeNames": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "expireTime": t.string().optional(),
            "managed": t.proxy(
                renames["SslCertificateManagedSslCertificateOut"]
            ).optional(),
            "region": t.string().optional(),
            "certificate": t.string().optional(),
            "type": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SslCertificateOut"])
    types["TargetGrpcProxyIn"] = t.struct(
        {
            "selfLinkWithId": t.string().optional(),
            "fingerprint": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "validateForProxyless": t.boolean().optional(),
            "name": t.string().optional(),
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "urlMap": t.string().optional(),
            "creationTimestamp": t.string().optional(),
        }
    ).named(renames["TargetGrpcProxyIn"])
    types["TargetGrpcProxyOut"] = t.struct(
        {
            "selfLinkWithId": t.string().optional(),
            "fingerprint": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "validateForProxyless": t.boolean().optional(),
            "name": t.string().optional(),
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "urlMap": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetGrpcProxyOut"])
    types["BackendBucketCdnPolicyBypassCacheOnRequestHeaderIn"] = t.struct(
        {"headerName": t.string().optional()}
    ).named(renames["BackendBucketCdnPolicyBypassCacheOnRequestHeaderIn"])
    types["BackendBucketCdnPolicyBypassCacheOnRequestHeaderOut"] = t.struct(
        {
            "headerName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendBucketCdnPolicyBypassCacheOnRequestHeaderOut"])
    types["FirewallPolicyRuleIn"] = t.struct(
        {
            "disabled": t.boolean().optional(),
            "action": t.string().optional(),
            "ruleName": t.string().optional(),
            "targetServiceAccounts": t.array(t.string()).optional(),
            "targetResources": t.array(t.string()).optional(),
            "targetSecureTags": t.array(
                t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
            ).optional(),
            "ruleTupleCount": t.integer().optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "priority": t.integer().optional(),
            "enableLogging": t.boolean().optional(),
            "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
            "direction": t.string().optional(),
        }
    ).named(renames["FirewallPolicyRuleIn"])
    types["FirewallPolicyRuleOut"] = t.struct(
        {
            "disabled": t.boolean().optional(),
            "action": t.string().optional(),
            "ruleName": t.string().optional(),
            "targetServiceAccounts": t.array(t.string()).optional(),
            "targetResources": t.array(t.string()).optional(),
            "targetSecureTags": t.array(
                t.proxy(renames["FirewallPolicyRuleSecureTagOut"])
            ).optional(),
            "ruleTupleCount": t.integer().optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "priority": t.integer().optional(),
            "enableLogging": t.boolean().optional(),
            "match": t.proxy(renames["FirewallPolicyRuleMatcherOut"]).optional(),
            "direction": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["FirewallPolicyRuleOut"])
    types["LogConfigCounterOptionsCustomFieldIn"] = t.struct(
        {"name": t.string().optional(), "value": t.string().optional()}
    ).named(renames["LogConfigCounterOptionsCustomFieldIn"])
    types["LogConfigCounterOptionsCustomFieldOut"] = t.struct(
        {
            "name": t.string().optional(),
            "value": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LogConfigCounterOptionsCustomFieldOut"])
    types["InstanceConsumptionInfoIn"] = t.struct(
        {
            "memoryMb": t.integer().optional(),
            "minNodeCpus": t.integer().optional(),
            "guestCpus": t.integer().optional(),
            "localSsdGb": t.integer().optional(),
        }
    ).named(renames["InstanceConsumptionInfoIn"])
    types["InstanceConsumptionInfoOut"] = t.struct(
        {
            "memoryMb": t.integer().optional(),
            "minNodeCpus": t.integer().optional(),
            "guestCpus": t.integer().optional(),
            "localSsdGb": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceConsumptionInfoOut"])
    types["ForwardingRuleListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["ForwardingRuleIn"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["ForwardingRuleListIn"])
    types["ForwardingRuleListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["ForwardingRuleOut"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ForwardingRuleListOut"])
    types["ServiceAttachmentAggregatedListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["ServiceAttachmentAggregatedListIn"])
    types["ServiceAttachmentAggregatedListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ServiceAttachmentAggregatedListOut"])
    types["InterconnectRemoteLocationConstraintsSubnetLengthRangeIn"] = t.struct(
        {"max": t.integer(), "min": t.integer()}
    ).named(renames["InterconnectRemoteLocationConstraintsSubnetLengthRangeIn"])
    types["InterconnectRemoteLocationConstraintsSubnetLengthRangeOut"] = t.struct(
        {
            "max": t.integer(),
            "min": t.integer(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectRemoteLocationConstraintsSubnetLengthRangeOut"])
    types["ManagedInstanceIn"] = t.struct(
        {
            "instance": t.string().optional(),
            "instanceHealth": t.array(
                t.proxy(renames["ManagedInstanceInstanceHealthIn"])
            ).optional(),
            "currentAction": t.string().optional(),
            "version": t.proxy(renames["ManagedInstanceVersionIn"]).optional(),
            "lastAttempt": t.proxy(renames["ManagedInstanceLastAttemptIn"]).optional(),
            "preservedStateFromPolicy": t.proxy(renames["PreservedStateIn"]).optional(),
            "id": t.string().optional(),
            "instanceStatus": t.string().optional(),
            "preservedStateFromConfig": t.proxy(renames["PreservedStateIn"]).optional(),
        }
    ).named(renames["ManagedInstanceIn"])
    types["ManagedInstanceOut"] = t.struct(
        {
            "instance": t.string().optional(),
            "instanceHealth": t.array(
                t.proxy(renames["ManagedInstanceInstanceHealthOut"])
            ).optional(),
            "currentAction": t.string().optional(),
            "version": t.proxy(renames["ManagedInstanceVersionOut"]).optional(),
            "lastAttempt": t.proxy(renames["ManagedInstanceLastAttemptOut"]).optional(),
            "preservedStateFromPolicy": t.proxy(
                renames["PreservedStateOut"]
            ).optional(),
            "id": t.string().optional(),
            "instanceStatus": t.string().optional(),
            "preservedStateFromConfig": t.proxy(
                renames["PreservedStateOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ManagedInstanceOut"])
    types["InterconnectAttachmentsScopedListIn"] = t.struct(
        {
            "interconnectAttachments": t.array(
                t.proxy(renames["InterconnectAttachmentIn"])
            ).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["InterconnectAttachmentsScopedListIn"])
    types["InterconnectAttachmentsScopedListOut"] = t.struct(
        {
            "interconnectAttachments": t.array(
                t.proxy(renames["InterconnectAttachmentOut"])
            ).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectAttachmentsScopedListOut"])
    types["ResourcePolicySnapshotSchedulePolicyRetentionPolicyIn"] = t.struct(
        {
            "onSourceDiskDelete": t.string().optional(),
            "maxRetentionDays": t.integer().optional(),
        }
    ).named(renames["ResourcePolicySnapshotSchedulePolicyRetentionPolicyIn"])
    types["ResourcePolicySnapshotSchedulePolicyRetentionPolicyOut"] = t.struct(
        {
            "onSourceDiskDelete": t.string().optional(),
            "maxRetentionDays": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicySnapshotSchedulePolicyRetentionPolicyOut"])
    types["OutlierDetectionIn"] = t.struct(
        {
            "consecutiveGatewayFailure": t.integer().optional(),
            "successRateMinimumHosts": t.integer().optional(),
            "interval": t.proxy(renames["DurationIn"]).optional(),
            "enforcingConsecutiveGatewayFailure": t.integer().optional(),
            "baseEjectionTime": t.proxy(renames["DurationIn"]).optional(),
            "consecutiveErrors": t.integer().optional(),
            "successRateStdevFactor": t.integer().optional(),
            "successRateRequestVolume": t.integer().optional(),
            "enforcingSuccessRate": t.integer().optional(),
            "enforcingConsecutiveErrors": t.integer().optional(),
            "maxEjectionPercent": t.integer().optional(),
        }
    ).named(renames["OutlierDetectionIn"])
    types["OutlierDetectionOut"] = t.struct(
        {
            "consecutiveGatewayFailure": t.integer().optional(),
            "successRateMinimumHosts": t.integer().optional(),
            "interval": t.proxy(renames["DurationOut"]).optional(),
            "enforcingConsecutiveGatewayFailure": t.integer().optional(),
            "baseEjectionTime": t.proxy(renames["DurationOut"]).optional(),
            "consecutiveErrors": t.integer().optional(),
            "successRateStdevFactor": t.integer().optional(),
            "successRateRequestVolume": t.integer().optional(),
            "enforcingSuccessRate": t.integer().optional(),
            "enforcingConsecutiveErrors": t.integer().optional(),
            "maxEjectionPercent": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["OutlierDetectionOut"])
    types["PublicDelegatedPrefixAggregatedListIn"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["PublicDelegatedPrefixAggregatedListIn"])
    types["PublicDelegatedPrefixAggregatedListOut"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PublicDelegatedPrefixAggregatedListOut"])
    types["NetworksRemovePeeringRequestIn"] = t.struct(
        {"name": t.string().optional()}
    ).named(renames["NetworksRemovePeeringRequestIn"])
    types["NetworksRemovePeeringRequestOut"] = t.struct(
        {
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworksRemovePeeringRequestOut"])
    types["SecurityPoliciesScopedListIn"] = t.struct(
        {
            "securityPolicies": t.array(
                t.proxy(renames["SecurityPolicyIn"])
            ).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["SecurityPoliciesScopedListIn"])
    types["SecurityPoliciesScopedListOut"] = t.struct(
        {
            "securityPolicies": t.array(
                t.proxy(renames["SecurityPolicyOut"])
            ).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPoliciesScopedListOut"])
    types["NodeTypeIn"] = t.struct(
        {
            "zone": t.string().optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
            "selfLink": t.string().optional(),
            "guestCpus": t.integer().optional(),
            "memoryMb": t.integer().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "cpuPlatform": t.string().optional(),
            "localSsdGb": t.integer().optional(),
        }
    ).named(renames["NodeTypeIn"])
    types["NodeTypeOut"] = t.struct(
        {
            "zone": t.string().optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "deprecated": t.proxy(renames["DeprecationStatusOut"]).optional(),
            "selfLink": t.string().optional(),
            "guestCpus": t.integer().optional(),
            "memoryMb": t.integer().optional(),
            "id": t.string().optional(),
            "name": t.string().optional(),
            "cpuPlatform": t.string().optional(),
            "localSsdGb": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeTypeOut"])
    types["PacketMirroringMirroredResourceInfoSubnetInfoIn"] = t.struct(
        {"canonicalUrl": t.string().optional(), "url": t.string().optional()}
    ).named(renames["PacketMirroringMirroredResourceInfoSubnetInfoIn"])
    types["PacketMirroringMirroredResourceInfoSubnetInfoOut"] = t.struct(
        {
            "canonicalUrl": t.string().optional(),
            "url": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PacketMirroringMirroredResourceInfoSubnetInfoOut"])
    types["BulkInsertInstanceResourcePerInstancePropertiesIn"] = t.struct(
        {"name": t.string().optional()}
    ).named(renames["BulkInsertInstanceResourcePerInstancePropertiesIn"])
    types["BulkInsertInstanceResourcePerInstancePropertiesOut"] = t.struct(
        {
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BulkInsertInstanceResourcePerInstancePropertiesOut"])
    types["AutoscalingPolicyCustomMetricUtilizationIn"] = t.struct(
        {
            "metric": t.string().optional(),
            "utilizationTarget": t.number().optional(),
            "filter": t.string().optional(),
            "singleInstanceAssignment": t.number().optional(),
            "utilizationTargetType": t.string().optional(),
        }
    ).named(renames["AutoscalingPolicyCustomMetricUtilizationIn"])
    types["AutoscalingPolicyCustomMetricUtilizationOut"] = t.struct(
        {
            "metric": t.string().optional(),
            "utilizationTarget": t.number().optional(),
            "filter": t.string().optional(),
            "singleInstanceAssignment": t.number().optional(),
            "utilizationTargetType": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AutoscalingPolicyCustomMetricUtilizationOut"])
    types["HttpHeaderMatchIn"] = t.struct(
        {
            "rangeMatch": t.proxy(renames["Int64RangeMatchIn"]).optional(),
            "headerName": t.string().optional(),
            "exactMatch": t.string().optional(),
            "invertMatch": t.boolean().optional(),
            "regexMatch": t.string().optional(),
            "prefixMatch": t.string().optional(),
            "presentMatch": t.boolean().optional(),
            "suffixMatch": t.string().optional(),
        }
    ).named(renames["HttpHeaderMatchIn"])
    types["HttpHeaderMatchOut"] = t.struct(
        {
            "rangeMatch": t.proxy(renames["Int64RangeMatchOut"]).optional(),
            "headerName": t.string().optional(),
            "exactMatch": t.string().optional(),
            "invertMatch": t.boolean().optional(),
            "regexMatch": t.string().optional(),
            "prefixMatch": t.string().optional(),
            "presentMatch": t.boolean().optional(),
            "suffixMatch": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpHeaderMatchOut"])
    types["BindingIn"] = t.struct(
        {
            "condition": t.proxy(renames["ExprIn"]).optional(),
            "members": t.array(t.string()).optional(),
            "bindingId": t.string().optional(),
            "role": t.string().optional(),
        }
    ).named(renames["BindingIn"])
    types["BindingOut"] = t.struct(
        {
            "condition": t.proxy(renames["ExprOut"]).optional(),
            "members": t.array(t.string()).optional(),
            "bindingId": t.string().optional(),
            "role": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BindingOut"])
    types["RegionListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["RegionIn"])).optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["RegionListIn"])
    types["RegionListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["RegionOut"])).optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionListOut"])
    types["NetworksGetEffectiveFirewallsResponseIn"] = t.struct(
        {
            "firewallPolicys": t.array(
                t.proxy(
                    renames[
                        "NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyIn"
                    ]
                )
            ).optional(),
            "firewalls": t.array(t.proxy(renames["FirewallIn"])).optional(),
        }
    ).named(renames["NetworksGetEffectiveFirewallsResponseIn"])
    types["NetworksGetEffectiveFirewallsResponseOut"] = t.struct(
        {
            "firewallPolicys": t.array(
                t.proxy(
                    renames[
                        "NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyOut"
                    ]
                )
            ).optional(),
            "firewalls": t.array(t.proxy(renames["FirewallOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworksGetEffectiveFirewallsResponseOut"])
    types["SslCertificateAggregatedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["SslCertificateAggregatedListIn"])
    types["SslCertificateAggregatedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SslCertificateAggregatedListOut"])
    types["HTTP2HealthCheckIn"] = t.struct(
        {
            "host": t.string().optional(),
            "port": t.integer().optional(),
            "requestPath": t.string().optional(),
            "response": t.string().optional(),
            "portName": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "portSpecification": t.string().optional(),
        }
    ).named(renames["HTTP2HealthCheckIn"])
    types["HTTP2HealthCheckOut"] = t.struct(
        {
            "host": t.string().optional(),
            "port": t.integer().optional(),
            "requestPath": t.string().optional(),
            "response": t.string().optional(),
            "portName": t.string().optional(),
            "proxyHeader": t.string().optional(),
            "portSpecification": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HTTP2HealthCheckOut"])
    types["DeprecationStatusIn"] = t.struct(
        {
            "deleted": t.string().optional(),
            "state": t.string().optional(),
            "deprecated": t.string().optional(),
            "replacement": t.string().optional(),
            "obsolete": t.string().optional(),
        }
    ).named(renames["DeprecationStatusIn"])
    types["DeprecationStatusOut"] = t.struct(
        {
            "deleted": t.string().optional(),
            "state": t.string().optional(),
            "deprecated": t.string().optional(),
            "replacement": t.string().optional(),
            "obsolete": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DeprecationStatusOut"])
    types["SslPolicyReferenceIn"] = t.struct(
        {"sslPolicy": t.string().optional()}
    ).named(renames["SslPolicyReferenceIn"])
    types["SslPolicyReferenceOut"] = t.struct(
        {
            "sslPolicy": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SslPolicyReferenceOut"])
    types["InstancePropertiesIn"] = t.struct(
        {
            "tags": t.proxy(renames["TagsIn"]).optional(),
            "guestAccelerators": t.array(
                t.proxy(renames["AcceleratorConfigIn"])
            ).optional(),
            "minCpuPlatform": t.string().optional(),
            "privateIpv6GoogleAccess": t.string().optional(),
            "confidentialInstanceConfig": t.proxy(
                renames["ConfidentialInstanceConfigIn"]
            ).optional(),
            "networkInterfaces": t.array(
                t.proxy(renames["NetworkInterfaceIn"])
            ).optional(),
            "keyRevocationActionType": t.string().optional(),
            "serviceAccounts": t.array(t.proxy(renames["ServiceAccountIn"])).optional(),
            "reservationAffinity": t.proxy(renames["ReservationAffinityIn"]).optional(),
            "resourceManagerTags": t.struct({"_": t.string().optional()}).optional(),
            "shieldedInstanceConfig": t.proxy(
                renames["ShieldedInstanceConfigIn"]
            ).optional(),
            "metadata": t.proxy(renames["MetadataIn"]).optional(),
            "networkPerformanceConfig": t.proxy(
                renames["NetworkPerformanceConfigIn"]
            ).optional(),
            "canIpForward": t.boolean().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "description": t.string().optional(),
            "scheduling": t.proxy(renames["SchedulingIn"]).optional(),
            "advancedMachineFeatures": t.proxy(
                renames["AdvancedMachineFeaturesIn"]
            ).optional(),
            "disks": t.array(t.proxy(renames["AttachedDiskIn"])).optional(),
            "resourcePolicies": t.array(t.string()).optional(),
            "machineType": t.string().optional(),
        }
    ).named(renames["InstancePropertiesIn"])
    types["InstancePropertiesOut"] = t.struct(
        {
            "tags": t.proxy(renames["TagsOut"]).optional(),
            "guestAccelerators": t.array(
                t.proxy(renames["AcceleratorConfigOut"])
            ).optional(),
            "minCpuPlatform": t.string().optional(),
            "privateIpv6GoogleAccess": t.string().optional(),
            "confidentialInstanceConfig": t.proxy(
                renames["ConfidentialInstanceConfigOut"]
            ).optional(),
            "networkInterfaces": t.array(
                t.proxy(renames["NetworkInterfaceOut"])
            ).optional(),
            "keyRevocationActionType": t.string().optional(),
            "serviceAccounts": t.array(
                t.proxy(renames["ServiceAccountOut"])
            ).optional(),
            "reservationAffinity": t.proxy(
                renames["ReservationAffinityOut"]
            ).optional(),
            "resourceManagerTags": t.struct({"_": t.string().optional()}).optional(),
            "shieldedInstanceConfig": t.proxy(
                renames["ShieldedInstanceConfigOut"]
            ).optional(),
            "metadata": t.proxy(renames["MetadataOut"]).optional(),
            "networkPerformanceConfig": t.proxy(
                renames["NetworkPerformanceConfigOut"]
            ).optional(),
            "canIpForward": t.boolean().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "description": t.string().optional(),
            "scheduling": t.proxy(renames["SchedulingOut"]).optional(),
            "advancedMachineFeatures": t.proxy(
                renames["AdvancedMachineFeaturesOut"]
            ).optional(),
            "disks": t.array(t.proxy(renames["AttachedDiskOut"])).optional(),
            "resourcePolicies": t.array(t.string()).optional(),
            "machineType": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstancePropertiesOut"])
    types["LogConfigDataAccessOptionsIn"] = t.struct(
        {"logMode": t.string().optional()}
    ).named(renames["LogConfigDataAccessOptionsIn"])
    types["LogConfigDataAccessOptionsOut"] = t.struct(
        {
            "logMode": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LogConfigDataAccessOptionsOut"])
    types["NetworkAttachmentConnectedEndpointIn"] = t.struct(
        {
            "secondaryIpCidrRanges": t.array(t.string()).optional(),
            "projectIdOrNum": t.string().optional(),
            "status": t.string().optional(),
            "subnetwork": t.string().optional(),
            "ipAddress": t.string().optional(),
        }
    ).named(renames["NetworkAttachmentConnectedEndpointIn"])
    types["NetworkAttachmentConnectedEndpointOut"] = t.struct(
        {
            "secondaryIpCidrRanges": t.array(t.string()).optional(),
            "projectIdOrNum": t.string().optional(),
            "status": t.string().optional(),
            "subnetwork": t.string().optional(),
            "ipAddress": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkAttachmentConnectedEndpointOut"])
    types["NodeTypeListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["NodeTypeIn"])).optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["NodeTypeListIn"])
    types["NodeTypeListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["NodeTypeOut"])).optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeTypeListOut"])
    types["DisksStopGroupAsyncReplicationResourceIn"] = t.struct(
        {"resourcePolicy": t.string().optional()}
    ).named(renames["DisksStopGroupAsyncReplicationResourceIn"])
    types["DisksStopGroupAsyncReplicationResourceOut"] = t.struct(
        {
            "resourcePolicy": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DisksStopGroupAsyncReplicationResourceOut"])
    types["InstanceTemplateAggregatedListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["InstanceTemplateAggregatedListIn"])
    types["InstanceTemplateAggregatedListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceTemplateAggregatedListOut"])
    types["MachineTypeListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["MachineTypeIn"])).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["MachineTypeListIn"])
    types["MachineTypeListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["MachineTypeOut"])).optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["MachineTypeListOut"])
    types["SecurityPolicyRulePreconfiguredWafConfigExclusionIn"] = t.struct(
        {
            "targetRuleIds": t.array(t.string()).optional(),
            "targetRuleSet": t.string().optional(),
            "requestUrisToExclude": t.array(
                t.proxy(
                    renames[
                        "SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsIn"
                    ]
                )
            ).optional(),
            "requestCookiesToExclude": t.array(
                t.proxy(
                    renames[
                        "SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsIn"
                    ]
                )
            ).optional(),
            "requestQueryParamsToExclude": t.array(
                t.proxy(
                    renames[
                        "SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsIn"
                    ]
                )
            ).optional(),
            "requestHeadersToExclude": t.array(
                t.proxy(
                    renames[
                        "SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsIn"
                    ]
                )
            ).optional(),
        }
    ).named(renames["SecurityPolicyRulePreconfiguredWafConfigExclusionIn"])
    types["SecurityPolicyRulePreconfiguredWafConfigExclusionOut"] = t.struct(
        {
            "targetRuleIds": t.array(t.string()).optional(),
            "targetRuleSet": t.string().optional(),
            "requestUrisToExclude": t.array(
                t.proxy(
                    renames[
                        "SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsOut"
                    ]
                )
            ).optional(),
            "requestCookiesToExclude": t.array(
                t.proxy(
                    renames[
                        "SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsOut"
                    ]
                )
            ).optional(),
            "requestQueryParamsToExclude": t.array(
                t.proxy(
                    renames[
                        "SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsOut"
                    ]
                )
            ).optional(),
            "requestHeadersToExclude": t.array(
                t.proxy(
                    renames[
                        "SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsOut"
                    ]
                )
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyRulePreconfiguredWafConfigExclusionOut"])
    types["RouterBgpIn"] = t.struct(
        {
            "advertisedGroups": t.array(t.string()).optional(),
            "advertiseMode": t.string().optional(),
            "advertisedIpRanges": t.array(
                t.proxy(renames["RouterAdvertisedIpRangeIn"])
            ).optional(),
            "asn": t.integer().optional(),
            "keepaliveInterval": t.integer().optional(),
        }
    ).named(renames["RouterBgpIn"])
    types["RouterBgpOut"] = t.struct(
        {
            "advertisedGroups": t.array(t.string()).optional(),
            "advertiseMode": t.string().optional(),
            "advertisedIpRanges": t.array(
                t.proxy(renames["RouterAdvertisedIpRangeOut"])
            ).optional(),
            "asn": t.integer().optional(),
            "keepaliveInterval": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterBgpOut"])
    types["LocationPolicyLocationIn"] = t.struct(
        {
            "constraints": t.proxy(
                renames["LocationPolicyLocationConstraintsIn"]
            ).optional(),
            "preference": t.string().optional(),
        }
    ).named(renames["LocationPolicyLocationIn"])
    types["LocationPolicyLocationOut"] = t.struct(
        {
            "constraints": t.proxy(
                renames["LocationPolicyLocationConstraintsOut"]
            ).optional(),
            "preference": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LocationPolicyLocationOut"])
    types["RegionInstanceGroupManagersListInstanceConfigsRespIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["PerInstanceConfigIn"])).optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["RegionInstanceGroupManagersListInstanceConfigsRespIn"])
    types["RegionInstanceGroupManagersListInstanceConfigsRespOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["PerInstanceConfigOut"])).optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagersListInstanceConfigsRespOut"])
    types["CircuitBreakersIn"] = t.struct(
        {
            "maxRequests": t.integer().optional(),
            "maxRequestsPerConnection": t.integer().optional(),
            "maxRetries": t.integer().optional(),
            "maxConnections": t.integer().optional(),
            "maxPendingRequests": t.integer().optional(),
        }
    ).named(renames["CircuitBreakersIn"])
    types["CircuitBreakersOut"] = t.struct(
        {
            "maxRequests": t.integer().optional(),
            "maxRequestsPerConnection": t.integer().optional(),
            "maxRetries": t.integer().optional(),
            "maxConnections": t.integer().optional(),
            "maxPendingRequests": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["CircuitBreakersOut"])
    types["ResourcePolicySnapshotSchedulePolicyIn"] = t.struct(
        {
            "snapshotProperties": t.proxy(
                renames["ResourcePolicySnapshotSchedulePolicySnapshotPropertiesIn"]
            ).optional(),
            "schedule": t.proxy(
                renames["ResourcePolicySnapshotSchedulePolicyScheduleIn"]
            ).optional(),
            "retentionPolicy": t.proxy(
                renames["ResourcePolicySnapshotSchedulePolicyRetentionPolicyIn"]
            ).optional(),
        }
    ).named(renames["ResourcePolicySnapshotSchedulePolicyIn"])
    types["ResourcePolicySnapshotSchedulePolicyOut"] = t.struct(
        {
            "snapshotProperties": t.proxy(
                renames["ResourcePolicySnapshotSchedulePolicySnapshotPropertiesOut"]
            ).optional(),
            "schedule": t.proxy(
                renames["ResourcePolicySnapshotSchedulePolicyScheduleOut"]
            ).optional(),
            "retentionPolicy": t.proxy(
                renames["ResourcePolicySnapshotSchedulePolicyRetentionPolicyOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicySnapshotSchedulePolicyOut"])
    types["HelpLinkIn"] = t.struct(
        {"description": t.string().optional(), "url": t.string().optional()}
    ).named(renames["HelpLinkIn"])
    types["HelpLinkOut"] = t.struct(
        {
            "description": t.string().optional(),
            "url": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HelpLinkOut"])
    types["AutoscalingPolicyScalingScheduleIn"] = t.struct(
        {
            "schedule": t.string().optional(),
            "minRequiredReplicas": t.integer().optional(),
            "timeZone": t.string().optional(),
            "description": t.string().optional(),
            "disabled": t.boolean().optional(),
            "durationSec": t.integer().optional(),
        }
    ).named(renames["AutoscalingPolicyScalingScheduleIn"])
    types["AutoscalingPolicyScalingScheduleOut"] = t.struct(
        {
            "schedule": t.string().optional(),
            "minRequiredReplicas": t.integer().optional(),
            "timeZone": t.string().optional(),
            "description": t.string().optional(),
            "disabled": t.boolean().optional(),
            "durationSec": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AutoscalingPolicyScalingScheduleOut"])
    types["SubsettingIn"] = t.struct({"policy": t.string()}).named(
        renames["SubsettingIn"]
    )
    types["SubsettingOut"] = t.struct(
        {"policy": t.string(), "error": t.proxy(renames["ErrorResponse"]).optional()}
    ).named(renames["SubsettingOut"])
    types["RegionInstanceGroupManagersApplyUpdatesRequestIn"] = t.struct(
        {
            "minimalAction": t.string().optional(),
            "instances": t.array(t.string()).optional(),
            "allInstances": t.boolean().optional(),
            "mostDisruptiveAllowedAction": t.string().optional(),
        }
    ).named(renames["RegionInstanceGroupManagersApplyUpdatesRequestIn"])
    types["RegionInstanceGroupManagersApplyUpdatesRequestOut"] = t.struct(
        {
            "minimalAction": t.string().optional(),
            "instances": t.array(t.string()).optional(),
            "allInstances": t.boolean().optional(),
            "mostDisruptiveAllowedAction": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagersApplyUpdatesRequestOut"])
    types["AliasIpRangeIn"] = t.struct(
        {
            "ipCidrRange": t.string().optional(),
            "subnetworkRangeName": t.string().optional(),
        }
    ).named(renames["AliasIpRangeIn"])
    types["AliasIpRangeOut"] = t.struct(
        {
            "ipCidrRange": t.string().optional(),
            "subnetworkRangeName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AliasIpRangeOut"])
    types["StatefulPolicyPreservedStateIn"] = t.struct(
        {"disks": t.struct({"_": t.string().optional()}).optional()}
    ).named(renames["StatefulPolicyPreservedStateIn"])
    types["StatefulPolicyPreservedStateOut"] = t.struct(
        {
            "disks": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["StatefulPolicyPreservedStateOut"])
    types["ResourcePolicyWeeklyCycleIn"] = t.struct(
        {
            "dayOfWeeks": t.array(
                t.proxy(renames["ResourcePolicyWeeklyCycleDayOfWeekIn"])
            ).optional()
        }
    ).named(renames["ResourcePolicyWeeklyCycleIn"])
    types["ResourcePolicyWeeklyCycleOut"] = t.struct(
        {
            "dayOfWeeks": t.array(
                t.proxy(renames["ResourcePolicyWeeklyCycleDayOfWeekOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicyWeeklyCycleOut"])
    types["PacketMirroringListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["PacketMirroringIn"])).optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["PacketMirroringListIn"])
    types["PacketMirroringListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.array(t.proxy(renames["PacketMirroringOut"])).optional(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PacketMirroringListOut"])
    types["HealthChecksAggregatedListIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
        }
    ).named(renames["HealthChecksAggregatedListIn"])
    types["HealthChecksAggregatedListOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HealthChecksAggregatedListOut"])
    types["ServiceAttachmentsScopedListIn"] = t.struct(
        {
            "serviceAttachments": t.array(
                t.proxy(renames["ServiceAttachmentIn"])
            ).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["ServiceAttachmentsScopedListIn"])
    types["ServiceAttachmentsScopedListOut"] = t.struct(
        {
            "serviceAttachments": t.array(
                t.proxy(renames["ServiceAttachmentOut"])
            ).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ServiceAttachmentsScopedListOut"])
    types["NetworkEndpointGroupsListNetworkEndpointsIn"] = t.struct(
        {
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.array(
                t.proxy(renames["NetworkEndpointWithHealthStatusIn"])
            ).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["NetworkEndpointGroupsListNetworkEndpointsIn"])
    types["NetworkEndpointGroupsListNetworkEndpointsOut"] = t.struct(
        {
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "items": t.array(
                t.proxy(renames["NetworkEndpointWithHealthStatusOut"])
            ).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointGroupsListNetworkEndpointsOut"])
    types["InterconnectAttachmentIn"] = t.struct(
        {
            "labelFingerprint": t.string().optional(),
            "googleReferenceId": t.string().optional(),
            "ipsecInternalAddresses": t.array(t.string()).optional(),
            "partnerMetadata": t.proxy(
                renames["InterconnectAttachmentPartnerMetadataIn"]
            ).optional(),
            "subnetLength": t.integer().optional(),
            "encryption": t.string().optional(),
            "candidateSubnets": t.array(t.string()).optional(),
            "description": t.string().optional(),
            "customerRouterIpv6Address": t.string().optional(),
            "type": t.string().optional(),
            "operationalStatus": t.string().optional(),
            "cloudRouterIpv6InterfaceId": t.string().optional(),
            "vlanTag8021q": t.integer().optional(),
            "adminEnabled": t.boolean().optional(),
            "partnerAsn": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "name": t.string().optional(),
            "id": t.string().optional(),
            "mtu": t.integer().optional(),
            "configurationConstraints": t.proxy(
                renames["InterconnectAttachmentConfigurationConstraintsIn"]
            ).optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "candidateIpv6Subnets": t.array(t.string()).optional(),
            "cloudRouterIpAddress": t.string().optional(),
            "customerRouterIpAddress": t.string().optional(),
            "bandwidth": t.string().optional(),
            "edgeAvailabilityDomain": t.string().optional(),
            "state": t.string().optional(),
            "remoteService": t.string().optional(),
            "customerRouterIpv6InterfaceId": t.string().optional(),
            "selfLink": t.string().optional(),
            "stackType": t.string().optional(),
            "router": t.string().optional(),
            "satisfiesPzs": t.boolean().optional(),
            "kind": t.string().optional(),
            "pairingKey": t.string().optional(),
            "dataplaneVersion": t.integer().optional(),
            "cloudRouterIpv6Address": t.string().optional(),
            "interconnect": t.string().optional(),
            "privateInterconnectInfo": t.proxy(
                renames["InterconnectAttachmentPrivateInfoIn"]
            ).optional(),
            "region": t.string().optional(),
        }
    ).named(renames["InterconnectAttachmentIn"])
    types["InterconnectAttachmentOut"] = t.struct(
        {
            "labelFingerprint": t.string().optional(),
            "googleReferenceId": t.string().optional(),
            "ipsecInternalAddresses": t.array(t.string()).optional(),
            "partnerMetadata": t.proxy(
                renames["InterconnectAttachmentPartnerMetadataOut"]
            ).optional(),
            "subnetLength": t.integer().optional(),
            "encryption": t.string().optional(),
            "candidateSubnets": t.array(t.string()).optional(),
            "description": t.string().optional(),
            "customerRouterIpv6Address": t.string().optional(),
            "type": t.string().optional(),
            "operationalStatus": t.string().optional(),
            "cloudRouterIpv6InterfaceId": t.string().optional(),
            "vlanTag8021q": t.integer().optional(),
            "adminEnabled": t.boolean().optional(),
            "partnerAsn": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "name": t.string().optional(),
            "id": t.string().optional(),
            "mtu": t.integer().optional(),
            "configurationConstraints": t.proxy(
                renames["InterconnectAttachmentConfigurationConstraintsOut"]
            ).optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "candidateIpv6Subnets": t.array(t.string()).optional(),
            "cloudRouterIpAddress": t.string().optional(),
            "customerRouterIpAddress": t.string().optional(),
            "bandwidth": t.string().optional(),
            "edgeAvailabilityDomain": t.string().optional(),
            "state": t.string().optional(),
            "remoteService": t.string().optional(),
            "customerRouterIpv6InterfaceId": t.string().optional(),
            "selfLink": t.string().optional(),
            "stackType": t.string().optional(),
            "router": t.string().optional(),
            "satisfiesPzs": t.boolean().optional(),
            "kind": t.string().optional(),
            "pairingKey": t.string().optional(),
            "dataplaneVersion": t.integer().optional(),
            "cloudRouterIpv6Address": t.string().optional(),
            "interconnect": t.string().optional(),
            "privateInterconnectInfo": t.proxy(
                renames["InterconnectAttachmentPrivateInfoOut"]
            ).optional(),
            "region": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectAttachmentOut"])
    types["SavedAttachedDiskIn"] = t.struct(
        {
            "guestOsFeatures": t.array(t.proxy(renames["GuestOsFeatureIn"])).optional(),
            "deviceName": t.string().optional(),
            "storageBytesStatus": t.string().optional(),
            "mode": t.string().optional(),
            "kind": t.string().optional(),
            "source": t.string().optional(),
            "index": t.integer().optional(),
            "autoDelete": t.boolean().optional(),
            "diskEncryptionKey": t.proxy(renames["CustomerEncryptionKeyIn"]).optional(),
            "type": t.string().optional(),
            "boot": t.boolean().optional(),
            "diskType": t.string().optional(),
            "licenses": t.array(t.string()).optional(),
            "interface": t.string().optional(),
            "diskSizeGb": t.string().optional(),
            "storageBytes": t.string().optional(),
        }
    ).named(renames["SavedAttachedDiskIn"])
    types["SavedAttachedDiskOut"] = t.struct(
        {
            "guestOsFeatures": t.array(
                t.proxy(renames["GuestOsFeatureOut"])
            ).optional(),
            "deviceName": t.string().optional(),
            "storageBytesStatus": t.string().optional(),
            "mode": t.string().optional(),
            "kind": t.string().optional(),
            "source": t.string().optional(),
            "index": t.integer().optional(),
            "autoDelete": t.boolean().optional(),
            "diskEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "type": t.string().optional(),
            "boot": t.boolean().optional(),
            "diskType": t.string().optional(),
            "licenses": t.array(t.string()).optional(),
            "interface": t.string().optional(),
            "diskSizeGb": t.string().optional(),
            "storageBytes": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SavedAttachedDiskOut"])
    types["FirewallPolicyListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["FirewallPolicyIn"])).optional(),
        }
    ).named(renames["FirewallPolicyListIn"])
    types["FirewallPolicyListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["FirewallPolicyOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["FirewallPolicyListOut"])
    types["HealthCheckLogConfigIn"] = t.struct(
        {"enable": t.boolean().optional()}
    ).named(renames["HealthCheckLogConfigIn"])
    types["HealthCheckLogConfigOut"] = t.struct(
        {
            "enable": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HealthCheckLogConfigOut"])
    types["DiskInstantiationConfigIn"] = t.struct(
        {
            "instantiateFrom": t.string().optional(),
            "customImage": t.string().optional(),
            "autoDelete": t.boolean().optional(),
            "deviceName": t.string().optional(),
        }
    ).named(renames["DiskInstantiationConfigIn"])
    types["DiskInstantiationConfigOut"] = t.struct(
        {
            "instantiateFrom": t.string().optional(),
            "customImage": t.string().optional(),
            "autoDelete": t.boolean().optional(),
            "deviceName": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DiskInstantiationConfigOut"])
    types["NodeGroupAutoscalingPolicyIn"] = t.struct(
        {
            "maxNodes": t.integer().optional(),
            "minNodes": t.integer().optional(),
            "mode": t.string().optional(),
        }
    ).named(renames["NodeGroupAutoscalingPolicyIn"])
    types["NodeGroupAutoscalingPolicyOut"] = t.struct(
        {
            "maxNodes": t.integer().optional(),
            "minNodes": t.integer().optional(),
            "mode": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeGroupAutoscalingPolicyOut"])
    types["InterconnectLocationListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["InterconnectLocationIn"])).optional(),
        }
    ).named(renames["InterconnectLocationListIn"])
    types["InterconnectLocationListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["InterconnectLocationOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectLocationListOut"])
    types["MachineTypeAggregatedListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
        }
    ).named(renames["MachineTypeAggregatedListIn"])
    types["MachineTypeAggregatedListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["MachineTypeAggregatedListOut"])
    types["AddressAggregatedListIn"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
        }
    ).named(renames["AddressAggregatedListIn"])
    types["AddressAggregatedListOut"] = t.struct(
        {
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AddressAggregatedListOut"])
    types["SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigIn"] = t.struct(
        {"enable": t.boolean().optional(), "ruleVisibility": t.string().optional()}
    ).named(renames["SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigIn"])
    types[
        "SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigOut"
    ] = t.struct(
        {
            "enable": t.boolean().optional(),
            "ruleVisibility": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(
        renames["SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigOut"]
    )
    types["AllocationSpecificSKUAllocationReservedInstancePropertiesIn"] = t.struct(
        {
            "machineType": t.string().optional(),
            "locationHint": t.string().optional(),
            "localSsds": t.array(
                t.proxy(
                    renames[
                        "AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskIn"
                    ]
                )
            ).optional(),
            "minCpuPlatform": t.string().optional(),
            "guestAccelerators": t.array(
                t.proxy(renames["AcceleratorConfigIn"])
            ).optional(),
        }
    ).named(renames["AllocationSpecificSKUAllocationReservedInstancePropertiesIn"])
    types["AllocationSpecificSKUAllocationReservedInstancePropertiesOut"] = t.struct(
        {
            "machineType": t.string().optional(),
            "locationHint": t.string().optional(),
            "localSsds": t.array(
                t.proxy(
                    renames[
                        "AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskOut"
                    ]
                )
            ).optional(),
            "minCpuPlatform": t.string().optional(),
            "guestAccelerators": t.array(
                t.proxy(renames["AcceleratorConfigOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AllocationSpecificSKUAllocationReservedInstancePropertiesOut"])
    types["InstanceGroupManagerActionsSummaryIn"] = t.struct(
        {
            "restarting": t.integer().optional(),
            "stopping": t.integer().optional(),
            "deleting": t.integer().optional(),
            "starting": t.integer().optional(),
            "creating": t.integer().optional(),
            "none": t.integer().optional(),
            "creatingWithoutRetries": t.integer().optional(),
            "suspending": t.integer().optional(),
            "recreating": t.integer().optional(),
            "abandoning": t.integer().optional(),
            "resuming": t.integer().optional(),
            "verifying": t.integer().optional(),
            "refreshing": t.integer().optional(),
        }
    ).named(renames["InstanceGroupManagerActionsSummaryIn"])
    types["InstanceGroupManagerActionsSummaryOut"] = t.struct(
        {
            "restarting": t.integer().optional(),
            "stopping": t.integer().optional(),
            "deleting": t.integer().optional(),
            "starting": t.integer().optional(),
            "creating": t.integer().optional(),
            "none": t.integer().optional(),
            "creatingWithoutRetries": t.integer().optional(),
            "suspending": t.integer().optional(),
            "recreating": t.integer().optional(),
            "abandoning": t.integer().optional(),
            "resuming": t.integer().optional(),
            "verifying": t.integer().optional(),
            "refreshing": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagerActionsSummaryOut"])
    types["VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappingsIn"] = t.struct(
        {
            "natIpPortRanges": t.array(t.string()).optional(),
            "numTotalNatPorts": t.integer().optional(),
            "ruleNumber": t.integer().optional(),
            "numTotalDrainNatPorts": t.integer().optional(),
            "drainNatIpPortRanges": t.array(t.string()).optional(),
        }
    ).named(renames["VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappingsIn"])
    types["VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappingsOut"] = t.struct(
        {
            "natIpPortRanges": t.array(t.string()).optional(),
            "numTotalNatPorts": t.integer().optional(),
            "ruleNumber": t.integer().optional(),
            "numTotalDrainNatPorts": t.integer().optional(),
            "drainNatIpPortRanges": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappingsOut"])
    types["VpnGatewayStatusHighAvailabilityRequirementStateIn"] = t.struct(
        {"unsatisfiedReason": t.string().optional(), "state": t.string().optional()}
    ).named(renames["VpnGatewayStatusHighAvailabilityRequirementStateIn"])
    types["VpnGatewayStatusHighAvailabilityRequirementStateOut"] = t.struct(
        {
            "unsatisfiedReason": t.string().optional(),
            "state": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnGatewayStatusHighAvailabilityRequirementStateOut"])
    types["ServiceAttachmentListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["ServiceAttachmentIn"])).optional(),
        }
    ).named(renames["ServiceAttachmentListIn"])
    types["ServiceAttachmentListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["ServiceAttachmentOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ServiceAttachmentListOut"])
    types["NetworkEndpointGroupsListEndpointsRequestIn"] = t.struct(
        {"healthStatus": t.string().optional()}
    ).named(renames["NetworkEndpointGroupsListEndpointsRequestIn"])
    types["NetworkEndpointGroupsListEndpointsRequestOut"] = t.struct(
        {
            "healthStatus": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointGroupsListEndpointsRequestOut"])
    types["ReservationsScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "reservations": t.array(t.proxy(renames["ReservationIn"])).optional(),
        }
    ).named(renames["ReservationsScopedListIn"])
    types["ReservationsScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "reservations": t.array(t.proxy(renames["ReservationOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ReservationsScopedListOut"])
    types["BackendServiceConnectionTrackingPolicyIn"] = t.struct(
        {
            "idleTimeoutSec": t.integer().optional(),
            "connectionPersistenceOnUnhealthyBackends": t.string().optional(),
            "enableStrongAffinity": t.boolean().optional(),
            "trackingMode": t.string().optional(),
        }
    ).named(renames["BackendServiceConnectionTrackingPolicyIn"])
    types["BackendServiceConnectionTrackingPolicyOut"] = t.struct(
        {
            "idleTimeoutSec": t.integer().optional(),
            "connectionPersistenceOnUnhealthyBackends": t.string().optional(),
            "enableStrongAffinity": t.boolean().optional(),
            "trackingMode": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceConnectionTrackingPolicyOut"])
    types["UrlMapsValidateResponseIn"] = t.struct(
        {"result": t.proxy(renames["UrlMapValidationResultIn"])}
    ).named(renames["UrlMapsValidateResponseIn"])
    types["UrlMapsValidateResponseOut"] = t.struct(
        {
            "result": t.proxy(renames["UrlMapValidationResultOut"]),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UrlMapsValidateResponseOut"])
    types["PreconfiguredWafSetIn"] = t.struct(
        {"expressionSets": t.array(t.proxy(renames["WafExpressionSetIn"])).optional()}
    ).named(renames["PreconfiguredWafSetIn"])
    types["PreconfiguredWafSetOut"] = t.struct(
        {
            "expressionSets": t.array(
                t.proxy(renames["WafExpressionSetOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PreconfiguredWafSetOut"])
    types["LocalDiskIn"] = t.struct(
        {
            "diskType": t.string().optional(),
            "diskCount": t.integer().optional(),
            "diskSizeGb": t.integer().optional(),
        }
    ).named(renames["LocalDiskIn"])
    types["LocalDiskOut"] = t.struct(
        {
            "diskType": t.string().optional(),
            "diskCount": t.integer().optional(),
            "diskSizeGb": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LocalDiskOut"])
    types["RouterStatusNatStatusNatRuleStatusIn"] = t.struct(
        {
            "ruleNumber": t.integer().optional(),
            "drainNatIps": t.array(t.string()).optional(),
            "activeNatIps": t.array(t.string()).optional(),
            "numVmEndpointsWithNatMappings": t.integer().optional(),
            "minExtraIpsNeeded": t.integer().optional(),
        }
    ).named(renames["RouterStatusNatStatusNatRuleStatusIn"])
    types["RouterStatusNatStatusNatRuleStatusOut"] = t.struct(
        {
            "ruleNumber": t.integer().optional(),
            "drainNatIps": t.array(t.string()).optional(),
            "activeNatIps": t.array(t.string()).optional(),
            "numVmEndpointsWithNatMappings": t.integer().optional(),
            "minExtraIpsNeeded": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterStatusNatStatusNatRuleStatusOut"])
    types["DiskAsyncReplicationListIn"] = t.struct(
        {"asyncReplicationDisk": t.proxy(renames["DiskAsyncReplicationIn"])}
    ).named(renames["DiskAsyncReplicationListIn"])
    types["DiskAsyncReplicationListOut"] = t.struct(
        {
            "asyncReplicationDisk": t.proxy(renames["DiskAsyncReplicationOut"]),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DiskAsyncReplicationListOut"])
    types["NetworkEdgeSecurityServiceAggregatedListIn"] = t.struct(
        {
            "etag": t.string(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
        }
    ).named(renames["NetworkEdgeSecurityServiceAggregatedListIn"])
    types["NetworkEdgeSecurityServiceAggregatedListOut"] = t.struct(
        {
            "etag": t.string(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEdgeSecurityServiceAggregatedListOut"])
    types["InstancesScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "instances": t.array(t.proxy(renames["InstanceIn"])).optional(),
        }
    ).named(renames["InstancesScopedListIn"])
    types["InstancesScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "instances": t.array(t.proxy(renames["InstanceOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstancesScopedListOut"])
    types["HttpRetryPolicyIn"] = t.struct(
        {
            "retryConditions": t.array(t.string()).optional(),
            "numRetries": t.integer().optional(),
            "perTryTimeout": t.proxy(renames["DurationIn"]).optional(),
        }
    ).named(renames["HttpRetryPolicyIn"])
    types["HttpRetryPolicyOut"] = t.struct(
        {
            "retryConditions": t.array(t.string()).optional(),
            "numRetries": t.integer().optional(),
            "perTryTimeout": t.proxy(renames["DurationOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpRetryPolicyOut"])
    types["ForwardingRulesScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "forwardingRules": t.array(t.proxy(renames["ForwardingRuleIn"])).optional(),
        }
    ).named(renames["ForwardingRulesScopedListIn"])
    types["ForwardingRulesScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "forwardingRules": t.array(
                t.proxy(renames["ForwardingRuleOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ForwardingRulesScopedListOut"])
    types["InstanceGroupsScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "instanceGroups": t.array(t.proxy(renames["InstanceGroupIn"])).optional(),
        }
    ).named(renames["InstanceGroupsScopedListIn"])
    types["InstanceGroupsScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "instanceGroups": t.array(t.proxy(renames["InstanceGroupOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupsScopedListOut"])
    types["AuthorizationLoggingOptionsIn"] = t.struct(
        {"permissionType": t.string().optional()}
    ).named(renames["AuthorizationLoggingOptionsIn"])
    types["AuthorizationLoggingOptionsOut"] = t.struct(
        {
            "permissionType": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AuthorizationLoggingOptionsOut"])
    types["SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsIn"] = t.struct(
        {"val": t.string().optional(), "op": t.string().optional()}
    ).named(renames["SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsIn"])
    types["SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsOut"] = t.struct(
        {
            "val": t.string().optional(),
            "op": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsOut"])
    types["AcceleratorTypeIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "maximumCardsPerInstance": t.integer().optional(),
            "creationTimestamp": t.string().optional(),
            "zone": t.string().optional(),
            "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
            "description": t.string().optional(),
            "name": t.string().optional(),
        }
    ).named(renames["AcceleratorTypeIn"])
    types["AcceleratorTypeOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "maximumCardsPerInstance": t.integer().optional(),
            "creationTimestamp": t.string().optional(),
            "zone": t.string().optional(),
            "deprecated": t.proxy(renames["DeprecationStatusOut"]).optional(),
            "description": t.string().optional(),
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AcceleratorTypeOut"])
    types["SecurityPolicyDdosProtectionConfigIn"] = t.struct(
        {"ddosProtection": t.string()}
    ).named(renames["SecurityPolicyDdosProtectionConfigIn"])
    types["SecurityPolicyDdosProtectionConfigOut"] = t.struct(
        {
            "ddosProtection": t.string(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyDdosProtectionConfigOut"])
    types["AutoscalerStatusDetailsIn"] = t.struct(
        {"type": t.string().optional(), "message": t.string().optional()}
    ).named(renames["AutoscalerStatusDetailsIn"])
    types["AutoscalerStatusDetailsOut"] = t.struct(
        {
            "type": t.string().optional(),
            "message": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AutoscalerStatusDetailsOut"])
    types["NodeGroupsScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nodeGroups": t.array(t.proxy(renames["NodeGroupIn"])).optional(),
        }
    ).named(renames["NodeGroupsScopedListIn"])
    types["NodeGroupsScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nodeGroups": t.array(t.proxy(renames["NodeGroupOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeGroupsScopedListOut"])
    types["VpnGatewayIn"] = t.struct(
        {
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "region": t.string().optional(),
            "vpnInterfaces": t.array(
                t.proxy(renames["VpnGatewayVpnGatewayInterfaceIn"])
            ).optional(),
            "labelFingerprint": t.string().optional(),
            "kind": t.string().optional(),
            "network": t.string().optional(),
            "selfLink": t.string().optional(),
            "name": t.string().optional(),
            "id": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "stackType": t.string().optional(),
        }
    ).named(renames["VpnGatewayIn"])
    types["VpnGatewayOut"] = t.struct(
        {
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "region": t.string().optional(),
            "vpnInterfaces": t.array(
                t.proxy(renames["VpnGatewayVpnGatewayInterfaceOut"])
            ).optional(),
            "labelFingerprint": t.string().optional(),
            "kind": t.string().optional(),
            "network": t.string().optional(),
            "selfLink": t.string().optional(),
            "name": t.string().optional(),
            "id": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "stackType": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnGatewayOut"])
    types["AllocationResourceStatusSpecificSKUAllocationIn"] = t.struct(
        {"sourceInstanceTemplateId": t.string().optional()}
    ).named(renames["AllocationResourceStatusSpecificSKUAllocationIn"])
    types["AllocationResourceStatusSpecificSKUAllocationOut"] = t.struct(
        {
            "sourceInstanceTemplateId": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AllocationResourceStatusSpecificSKUAllocationOut"])
    types["AllocationSpecificSKUReservationIn"] = t.struct(
        {
            "assuredCount": t.string().optional(),
            "count": t.string().optional(),
            "inUseCount": t.string().optional(),
            "sourceInstanceTemplate": t.string().optional(),
            "instanceProperties": t.proxy(
                renames["AllocationSpecificSKUAllocationReservedInstancePropertiesIn"]
            ).optional(),
        }
    ).named(renames["AllocationSpecificSKUReservationIn"])
    types["AllocationSpecificSKUReservationOut"] = t.struct(
        {
            "assuredCount": t.string().optional(),
            "count": t.string().optional(),
            "inUseCount": t.string().optional(),
            "sourceInstanceTemplate": t.string().optional(),
            "instanceProperties": t.proxy(
                renames["AllocationSpecificSKUAllocationReservedInstancePropertiesOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AllocationSpecificSKUReservationOut"])
    types["SubnetworksSetPrivateIpGoogleAccessRequestIn"] = t.struct(
        {"privateIpGoogleAccess": t.boolean()}
    ).named(renames["SubnetworksSetPrivateIpGoogleAccessRequestIn"])
    types["SubnetworksSetPrivateIpGoogleAccessRequestOut"] = t.struct(
        {
            "privateIpGoogleAccess": t.boolean(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SubnetworksSetPrivateIpGoogleAccessRequestOut"])
    types["UsableSubnetworkSecondaryRangeIn"] = t.struct(
        {"rangeName": t.string().optional(), "ipCidrRange": t.string().optional()}
    ).named(renames["UsableSubnetworkSecondaryRangeIn"])
    types["UsableSubnetworkSecondaryRangeOut"] = t.struct(
        {
            "rangeName": t.string().optional(),
            "ipCidrRange": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UsableSubnetworkSecondaryRangeOut"])
    types["SubnetworkLogConfigIn"] = t.struct(
        {
            "enable": t.boolean().optional(),
            "aggregationInterval": t.string().optional(),
            "metadata": t.string().optional(),
            "filterExpr": t.string().optional(),
            "metadataFields": t.array(t.string()).optional(),
            "flowSampling": t.number().optional(),
        }
    ).named(renames["SubnetworkLogConfigIn"])
    types["SubnetworkLogConfigOut"] = t.struct(
        {
            "enable": t.boolean().optional(),
            "aggregationInterval": t.string().optional(),
            "metadata": t.string().optional(),
            "filterExpr": t.string().optional(),
            "metadataFields": t.array(t.string()).optional(),
            "flowSampling": t.number().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SubnetworkLogConfigOut"])
    types["HealthStatusForNetworkEndpointIn"] = t.struct(
        {
            "healthCheckService": t.proxy(
                renames["HealthCheckServiceReferenceIn"]
            ).optional(),
            "forwardingRule": t.proxy(renames["ForwardingRuleReferenceIn"]).optional(),
            "healthCheck": t.proxy(renames["HealthCheckReferenceIn"]).optional(),
            "healthState": t.string().optional(),
            "backendService": t.proxy(renames["BackendServiceReferenceIn"]).optional(),
        }
    ).named(renames["HealthStatusForNetworkEndpointIn"])
    types["HealthStatusForNetworkEndpointOut"] = t.struct(
        {
            "healthCheckService": t.proxy(
                renames["HealthCheckServiceReferenceOut"]
            ).optional(),
            "forwardingRule": t.proxy(renames["ForwardingRuleReferenceOut"]).optional(),
            "healthCheck": t.proxy(renames["HealthCheckReferenceOut"]).optional(),
            "healthState": t.string().optional(),
            "backendService": t.proxy(renames["BackendServiceReferenceOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HealthStatusForNetworkEndpointOut"])
    types["AutoscalingPolicyScaleInControlIn"] = t.struct(
        {
            "maxScaledInReplicas": t.proxy(renames["FixedOrPercentIn"]).optional(),
            "timeWindowSec": t.integer().optional(),
        }
    ).named(renames["AutoscalingPolicyScaleInControlIn"])
    types["AutoscalingPolicyScaleInControlOut"] = t.struct(
        {
            "maxScaledInReplicas": t.proxy(renames["FixedOrPercentOut"]).optional(),
            "timeWindowSec": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AutoscalingPolicyScaleInControlOut"])
    types["InterconnectDiagnosticsIn"] = t.struct(
        {
            "macAddress": t.string().optional(),
            "bundleOperationalStatus": t.string().optional(),
            "links": t.array(
                t.proxy(renames["InterconnectDiagnosticsLinkStatusIn"])
            ).optional(),
            "bundleAggregationType": t.string().optional(),
            "arpCaches": t.array(
                t.proxy(renames["InterconnectDiagnosticsARPEntryIn"])
            ).optional(),
        }
    ).named(renames["InterconnectDiagnosticsIn"])
    types["InterconnectDiagnosticsOut"] = t.struct(
        {
            "macAddress": t.string().optional(),
            "bundleOperationalStatus": t.string().optional(),
            "links": t.array(
                t.proxy(renames["InterconnectDiagnosticsLinkStatusOut"])
            ).optional(),
            "bundleAggregationType": t.string().optional(),
            "arpCaches": t.array(
                t.proxy(renames["InterconnectDiagnosticsARPEntryOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectDiagnosticsOut"])
    types["NetworkAttachmentAggregatedListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string(),
        }
    ).named(renames["NetworkAttachmentAggregatedListIn"])
    types["NetworkAttachmentAggregatedListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkAttachmentAggregatedListOut"])
    types["HealthStatusIn"] = t.struct(
        {
            "port": t.integer().optional(),
            "forwardingRule": t.string().optional(),
            "healthState": t.string().optional(),
            "weightError": t.string(),
            "annotations": t.struct({"_": t.string().optional()}).optional(),
            "ipAddress": t.string().optional(),
            "weight": t.string(),
            "instance": t.string().optional(),
            "forwardingRuleIp": t.string().optional(),
        }
    ).named(renames["HealthStatusIn"])
    types["HealthStatusOut"] = t.struct(
        {
            "port": t.integer().optional(),
            "forwardingRule": t.string().optional(),
            "healthState": t.string().optional(),
            "weightError": t.string(),
            "annotations": t.struct({"_": t.string().optional()}).optional(),
            "ipAddress": t.string().optional(),
            "weight": t.string(),
            "instance": t.string().optional(),
            "forwardingRuleIp": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HealthStatusOut"])
    types["AddressIn"] = t.struct(
        {
            "name": t.string().optional(),
            "labelFingerprint": t.string().optional(),
            "networkTier": t.string().optional(),
            "ipVersion": t.string().optional(),
            "ipv6EndpointType": t.string().optional(),
            "addressType": t.string().optional(),
            "selfLink": t.string().optional(),
            "prefixLength": t.integer().optional(),
            "status": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "address": t.string().optional(),
            "region": t.string().optional(),
            "network": t.string().optional(),
            "purpose": t.string().optional(),
            "users": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "id": t.string().optional(),
            "subnetwork": t.string().optional(),
        }
    ).named(renames["AddressIn"])
    types["AddressOut"] = t.struct(
        {
            "name": t.string().optional(),
            "labelFingerprint": t.string().optional(),
            "networkTier": t.string().optional(),
            "ipVersion": t.string().optional(),
            "ipv6EndpointType": t.string().optional(),
            "addressType": t.string().optional(),
            "selfLink": t.string().optional(),
            "prefixLength": t.integer().optional(),
            "status": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "address": t.string().optional(),
            "region": t.string().optional(),
            "network": t.string().optional(),
            "purpose": t.string().optional(),
            "users": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "id": t.string().optional(),
            "subnetwork": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AddressOut"])
    types["ResourcePolicyWeeklyCycleDayOfWeekIn"] = t.struct(
        {
            "duration": t.string().optional(),
            "day": t.string().optional(),
            "startTime": t.string().optional(),
        }
    ).named(renames["ResourcePolicyWeeklyCycleDayOfWeekIn"])
    types["ResourcePolicyWeeklyCycleDayOfWeekOut"] = t.struct(
        {
            "duration": t.string().optional(),
            "day": t.string().optional(),
            "startTime": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicyWeeklyCycleDayOfWeekOut"])
    types["ResourceCommitmentIn"] = t.struct(
        {
            "acceleratorType": t.string().optional(),
            "amount": t.string().optional(),
            "type": t.string().optional(),
        }
    ).named(renames["ResourceCommitmentIn"])
    types["ResourceCommitmentOut"] = t.struct(
        {
            "acceleratorType": t.string().optional(),
            "amount": t.string().optional(),
            "type": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourceCommitmentOut"])
    types["AutoscalingPolicyIn"] = t.struct(
        {
            "cpuUtilization": t.proxy(
                renames["AutoscalingPolicyCpuUtilizationIn"]
            ).optional(),
            "maxNumReplicas": t.integer().optional(),
            "minNumReplicas": t.integer().optional(),
            "mode": t.string().optional(),
            "loadBalancingUtilization": t.proxy(
                renames["AutoscalingPolicyLoadBalancingUtilizationIn"]
            ).optional(),
            "customMetricUtilizations": t.array(
                t.proxy(renames["AutoscalingPolicyCustomMetricUtilizationIn"])
            ).optional(),
            "scalingSchedules": t.struct({"_": t.string().optional()}).optional(),
            "coolDownPeriodSec": t.integer().optional(),
            "scaleInControl": t.proxy(renames["AutoscalingPolicyScaleInControlIn"]),
        }
    ).named(renames["AutoscalingPolicyIn"])
    types["AutoscalingPolicyOut"] = t.struct(
        {
            "cpuUtilization": t.proxy(
                renames["AutoscalingPolicyCpuUtilizationOut"]
            ).optional(),
            "maxNumReplicas": t.integer().optional(),
            "minNumReplicas": t.integer().optional(),
            "mode": t.string().optional(),
            "loadBalancingUtilization": t.proxy(
                renames["AutoscalingPolicyLoadBalancingUtilizationOut"]
            ).optional(),
            "customMetricUtilizations": t.array(
                t.proxy(renames["AutoscalingPolicyCustomMetricUtilizationOut"])
            ).optional(),
            "scalingSchedules": t.struct({"_": t.string().optional()}).optional(),
            "coolDownPeriodSec": t.integer().optional(),
            "scaleInControl": t.proxy(renames["AutoscalingPolicyScaleInControlOut"]),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["AutoscalingPolicyOut"])
    types["VpnGatewayStatusIn"] = t.struct(
        {
            "vpnConnections": t.array(
                t.proxy(renames["VpnGatewayStatusVpnConnectionIn"])
            ).optional()
        }
    ).named(renames["VpnGatewayStatusIn"])
    types["VpnGatewayStatusOut"] = t.struct(
        {
            "vpnConnections": t.array(
                t.proxy(renames["VpnGatewayStatusVpnConnectionOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnGatewayStatusOut"])
    types["ResourcePolicyGroupPlacementPolicyIn"] = t.struct(
        {
            "availabilityDomainCount": t.integer().optional(),
            "vmCount": t.integer().optional(),
            "collocation": t.string().optional(),
        }
    ).named(renames["ResourcePolicyGroupPlacementPolicyIn"])
    types["ResourcePolicyGroupPlacementPolicyOut"] = t.struct(
        {
            "availabilityDomainCount": t.integer().optional(),
            "vmCount": t.integer().optional(),
            "collocation": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourcePolicyGroupPlacementPolicyOut"])
    types["SecurityPoliciesWafConfigIn"] = t.struct(
        {"wafRules": t.proxy(renames["PreconfiguredWafSetIn"])}
    ).named(renames["SecurityPoliciesWafConfigIn"])
    types["SecurityPoliciesWafConfigOut"] = t.struct(
        {
            "wafRules": t.proxy(renames["PreconfiguredWafSetOut"]),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPoliciesWafConfigOut"])
    types["ScalingScheduleStatusIn"] = t.struct(
        {
            "state": t.string().optional(),
            "nextStartTime": t.string().optional(),
            "lastStartTime": t.string().optional(),
        }
    ).named(renames["ScalingScheduleStatusIn"])
    types["ScalingScheduleStatusOut"] = t.struct(
        {
            "state": t.string().optional(),
            "nextStartTime": t.string().optional(),
            "lastStartTime": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ScalingScheduleStatusOut"])
    types["RoutersScopedListIn"] = t.struct(
        {
            "routers": t.array(t.proxy(renames["RouterIn"])).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
        }
    ).named(renames["RoutersScopedListIn"])
    types["RoutersScopedListOut"] = t.struct(
        {
            "routers": t.array(t.proxy(renames["RouterOut"])).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RoutersScopedListOut"])
    types["BackendServiceFailoverPolicyIn"] = t.struct(
        {
            "disableConnectionDrainOnFailover": t.boolean().optional(),
            "failoverRatio": t.number().optional(),
            "dropTrafficIfUnhealthy": t.boolean().optional(),
        }
    ).named(renames["BackendServiceFailoverPolicyIn"])
    types["BackendServiceFailoverPolicyOut"] = t.struct(
        {
            "disableConnectionDrainOnFailover": t.boolean().optional(),
            "failoverRatio": t.number().optional(),
            "dropTrafficIfUnhealthy": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceFailoverPolicyOut"])
    types["RegionAutoscalerListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["AutoscalerIn"])).optional(),
        }
    ).named(renames["RegionAutoscalerListIn"])
    types["RegionAutoscalerListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["AutoscalerOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionAutoscalerListOut"])
    types["InterconnectRemoteLocationIn"] = t.struct(
        {
            "permittedConnections": t.array(
                t.proxy(renames["InterconnectRemoteLocationPermittedConnectionsIn"])
            ).optional(),
            "address": t.string().optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "continent": t.string().optional(),
            "facilityProviderFacilityId": t.string().optional(),
            "remoteService": t.string().optional(),
            "peeringdbFacilityId": t.string().optional(),
            "name": t.string().optional(),
            "maxLagSize100Gbps": t.integer().optional(),
            "maxLagSize10Gbps": t.integer().optional(),
            "selfLink": t.string().optional(),
            "status": t.string().optional(),
            "facilityProvider": t.string().optional(),
            "attachmentConfigurationConstraints": t.proxy(
                renames["InterconnectAttachmentConfigurationConstraintsIn"]
            ).optional(),
            "creationTimestamp": t.string().optional(),
            "lacp": t.string().optional(),
            "id": t.string().optional(),
            "city": t.string().optional(),
            "constraints": t.proxy(
                renames["InterconnectRemoteLocationConstraintsIn"]
            ).optional(),
        }
    ).named(renames["InterconnectRemoteLocationIn"])
    types["InterconnectRemoteLocationOut"] = t.struct(
        {
            "permittedConnections": t.array(
                t.proxy(renames["InterconnectRemoteLocationPermittedConnectionsOut"])
            ).optional(),
            "address": t.string().optional(),
            "description": t.string().optional(),
            "kind": t.string().optional(),
            "continent": t.string().optional(),
            "facilityProviderFacilityId": t.string().optional(),
            "remoteService": t.string().optional(),
            "peeringdbFacilityId": t.string().optional(),
            "name": t.string().optional(),
            "maxLagSize100Gbps": t.integer().optional(),
            "maxLagSize10Gbps": t.integer().optional(),
            "selfLink": t.string().optional(),
            "status": t.string().optional(),
            "facilityProvider": t.string().optional(),
            "attachmentConfigurationConstraints": t.proxy(
                renames["InterconnectAttachmentConfigurationConstraintsOut"]
            ).optional(),
            "creationTimestamp": t.string().optional(),
            "lacp": t.string().optional(),
            "id": t.string().optional(),
            "city": t.string().optional(),
            "constraints": t.proxy(
                renames["InterconnectRemoteLocationConstraintsOut"]
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectRemoteLocationOut"])
    types["HttpRouteRuleIn"] = t.struct(
        {
            "headerAction": t.proxy(renames["HttpHeaderActionIn"]).optional(),
            "service": t.string().optional(),
            "routeAction": t.proxy(renames["HttpRouteActionIn"]).optional(),
            "description": t.string().optional(),
            "priority": t.integer().optional(),
            "urlRedirect": t.proxy(renames["HttpRedirectActionIn"]).optional(),
            "matchRules": t.array(t.proxy(renames["HttpRouteRuleMatchIn"])).optional(),
        }
    ).named(renames["HttpRouteRuleIn"])
    types["HttpRouteRuleOut"] = t.struct(
        {
            "headerAction": t.proxy(renames["HttpHeaderActionOut"]).optional(),
            "service": t.string().optional(),
            "routeAction": t.proxy(renames["HttpRouteActionOut"]).optional(),
            "description": t.string().optional(),
            "priority": t.integer().optional(),
            "urlRedirect": t.proxy(renames["HttpRedirectActionOut"]).optional(),
            "matchRules": t.array(t.proxy(renames["HttpRouteRuleMatchOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpRouteRuleOut"])
    types["ExternalVpnGatewayInterfaceIn"] = t.struct(
        {"ipAddress": t.string().optional(), "id": t.integer().optional()}
    ).named(renames["ExternalVpnGatewayInterfaceIn"])
    types["ExternalVpnGatewayInterfaceOut"] = t.struct(
        {
            "ipAddress": t.string().optional(),
            "id": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ExternalVpnGatewayInterfaceOut"])
    types["NetworkEndpointGroupListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["NetworkEndpointGroupIn"])).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
        }
    ).named(renames["NetworkEndpointGroupListIn"])
    types["NetworkEndpointGroupListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["NetworkEndpointGroupOut"])).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointGroupListOut"])
    types["UrlMapIn"] = t.struct(
        {
            "id": t.string().optional(),
            "region": t.string().optional(),
            "kind": t.string().optional(),
            "defaultRouteAction": t.proxy(renames["HttpRouteActionIn"]).optional(),
            "description": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "headerAction": t.proxy(renames["HttpHeaderActionIn"]).optional(),
            "defaultService": t.string().optional(),
            "pathMatchers": t.array(t.proxy(renames["PathMatcherIn"])).optional(),
            "selfLink": t.string().optional(),
            "tests": t.array(t.proxy(renames["UrlMapTestIn"])).optional(),
            "fingerprint": t.string().optional(),
            "hostRules": t.array(t.proxy(renames["HostRuleIn"])).optional(),
            "name": t.string().optional(),
            "defaultUrlRedirect": t.proxy(renames["HttpRedirectActionIn"]).optional(),
        }
    ).named(renames["UrlMapIn"])
    types["UrlMapOut"] = t.struct(
        {
            "id": t.string().optional(),
            "region": t.string().optional(),
            "kind": t.string().optional(),
            "defaultRouteAction": t.proxy(renames["HttpRouteActionOut"]).optional(),
            "description": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "headerAction": t.proxy(renames["HttpHeaderActionOut"]).optional(),
            "defaultService": t.string().optional(),
            "pathMatchers": t.array(t.proxy(renames["PathMatcherOut"])).optional(),
            "selfLink": t.string().optional(),
            "tests": t.array(t.proxy(renames["UrlMapTestOut"])).optional(),
            "fingerprint": t.string().optional(),
            "hostRules": t.array(t.proxy(renames["HostRuleOut"])).optional(),
            "name": t.string().optional(),
            "defaultUrlRedirect": t.proxy(renames["HttpRedirectActionOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UrlMapOut"])
    types["DiskMoveRequestIn"] = t.struct(
        {"targetDisk": t.string().optional(), "destinationZone": t.string().optional()}
    ).named(renames["DiskMoveRequestIn"])
    types["DiskMoveRequestOut"] = t.struct(
        {
            "targetDisk": t.string().optional(),
            "destinationZone": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DiskMoveRequestOut"])
    types["NetworkIn"] = t.struct(
        {
            "gatewayIPv4": t.string().optional(),
            "routingConfig": t.proxy(renames["NetworkRoutingConfigIn"]).optional(),
            "IPv4Range": t.string().optional(),
            "autoCreateSubnetworks": t.boolean().optional(),
            "firewallPolicy": t.string().optional(),
            "networkFirewallPolicyEnforcementOrder": t.string().optional(),
            "id": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "peerings": t.array(t.proxy(renames["NetworkPeeringIn"])).optional(),
            "description": t.string().optional(),
            "selfLinkWithId": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "enableUlaInternalIpv6": t.boolean().optional(),
            "mtu": t.integer().optional(),
            "subnetworks": t.array(t.string()).optional(),
            "internalIpv6Range": t.string().optional(),
            "name": t.string().optional(),
        }
    ).named(renames["NetworkIn"])
    types["NetworkOut"] = t.struct(
        {
            "gatewayIPv4": t.string().optional(),
            "routingConfig": t.proxy(renames["NetworkRoutingConfigOut"]).optional(),
            "IPv4Range": t.string().optional(),
            "autoCreateSubnetworks": t.boolean().optional(),
            "firewallPolicy": t.string().optional(),
            "networkFirewallPolicyEnforcementOrder": t.string().optional(),
            "id": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "peerings": t.array(t.proxy(renames["NetworkPeeringOut"])).optional(),
            "description": t.string().optional(),
            "selfLinkWithId": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "enableUlaInternalIpv6": t.boolean().optional(),
            "mtu": t.integer().optional(),
            "subnetworks": t.array(t.string()).optional(),
            "internalIpv6Range": t.string().optional(),
            "name": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkOut"])
    types["OperationsScopedListIn"] = t.struct(
        {
            "operations": t.array(t.proxy(renames["OperationIn"])).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["OperationsScopedListIn"])
    types["OperationsScopedListOut"] = t.struct(
        {
            "operations": t.array(t.proxy(renames["OperationOut"])).optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["OperationsScopedListOut"])
    types["DisksScopedListIn"] = t.struct(
        {
            "disks": t.array(t.proxy(renames["DiskIn"])).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["DisksScopedListIn"])
    types["DisksScopedListOut"] = t.struct(
        {
            "disks": t.array(t.proxy(renames["DiskOut"])).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["DisksScopedListOut"])
    types["InterconnectAttachmentPrivateInfoIn"] = t.struct(
        {"tag8021q": t.integer().optional()}
    ).named(renames["InterconnectAttachmentPrivateInfoIn"])
    types["InterconnectAttachmentPrivateInfoOut"] = t.struct(
        {
            "tag8021q": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectAttachmentPrivateInfoOut"])
    types["NetworksAddPeeringRequestIn"] = t.struct(
        {
            "autoCreateRoutes": t.boolean().optional(),
            "name": t.string().optional(),
            "networkPeering": t.proxy(renames["NetworkPeeringIn"]).optional(),
            "peerNetwork": t.string().optional(),
        }
    ).named(renames["NetworksAddPeeringRequestIn"])
    types["NetworksAddPeeringRequestOut"] = t.struct(
        {
            "autoCreateRoutes": t.boolean().optional(),
            "name": t.string().optional(),
            "networkPeering": t.proxy(renames["NetworkPeeringOut"]).optional(),
            "peerNetwork": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworksAddPeeringRequestOut"])
    types["RequestMirrorPolicyIn"] = t.struct(
        {"backendService": t.string().optional()}
    ).named(renames["RequestMirrorPolicyIn"])
    types["RequestMirrorPolicyOut"] = t.struct(
        {
            "backendService": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RequestMirrorPolicyOut"])
    types["InstanceManagedByIgmErrorManagedInstanceErrorIn"] = t.struct(
        {"code": t.string().optional(), "message": t.string().optional()}
    ).named(renames["InstanceManagedByIgmErrorManagedInstanceErrorIn"])
    types["InstanceManagedByIgmErrorManagedInstanceErrorOut"] = t.struct(
        {
            "code": t.string().optional(),
            "message": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceManagedByIgmErrorManagedInstanceErrorOut"])
    types["RegionInstanceGroupManagerDeleteInstanceConfigReqIn"] = t.struct(
        {"names": t.array(t.string()).optional()}
    ).named(renames["RegionInstanceGroupManagerDeleteInstanceConfigReqIn"])
    types["RegionInstanceGroupManagerDeleteInstanceConfigReqOut"] = t.struct(
        {
            "names": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagerDeleteInstanceConfigReqOut"])
    types["ShareSettingsIn"] = t.struct(
        {
            "shareType": t.string().optional(),
            "projectMap": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["ShareSettingsIn"])
    types["ShareSettingsOut"] = t.struct(
        {
            "shareType": t.string().optional(),
            "projectMap": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ShareSettingsOut"])
    types["RegionInstanceGroupManagerListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceGroupManagerIn"])).optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["RegionInstanceGroupManagerListIn"])
    types["RegionInstanceGroupManagerListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceGroupManagerOut"])).optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagerListOut"])
    types["PublicAdvertisedPrefixIn"] = t.struct(
        {
            "ipCidrRange": t.string().optional(),
            "description": t.string().optional(),
            "status": t.string().optional(),
            "fingerprint": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "dnsVerificationIp": t.string().optional(),
            "publicDelegatedPrefixs": t.array(
                t.proxy(renames["PublicAdvertisedPrefixPublicDelegatedPrefixIn"])
            ).optional(),
            "sharedSecret": t.string().optional(),
            "kind": t.string().optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
        }
    ).named(renames["PublicAdvertisedPrefixIn"])
    types["PublicAdvertisedPrefixOut"] = t.struct(
        {
            "ipCidrRange": t.string().optional(),
            "description": t.string().optional(),
            "status": t.string().optional(),
            "fingerprint": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "dnsVerificationIp": t.string().optional(),
            "publicDelegatedPrefixs": t.array(
                t.proxy(renames["PublicAdvertisedPrefixPublicDelegatedPrefixOut"])
            ).optional(),
            "sharedSecret": t.string().optional(),
            "kind": t.string().optional(),
            "name": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PublicAdvertisedPrefixOut"])
    types["BackendServiceAggregatedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["BackendServiceAggregatedListIn"])
    types["BackendServiceAggregatedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "unreachables": t.array(t.string()).optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceAggregatedListOut"])
    types["RegionInstanceGroupManagersSetTemplateRequestIn"] = t.struct(
        {"instanceTemplate": t.string().optional()}
    ).named(renames["RegionInstanceGroupManagersSetTemplateRequestIn"])
    types["RegionInstanceGroupManagersSetTemplateRequestOut"] = t.struct(
        {
            "instanceTemplate": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionInstanceGroupManagersSetTemplateRequestOut"])
    types["RegionSetPolicyRequestIn"] = t.struct(
        {
            "etag": t.string().optional(),
            "policy": t.proxy(renames["PolicyIn"]).optional(),
            "bindings": t.array(t.proxy(renames["BindingIn"])).optional(),
        }
    ).named(renames["RegionSetPolicyRequestIn"])
    types["RegionSetPolicyRequestOut"] = t.struct(
        {
            "etag": t.string().optional(),
            "policy": t.proxy(renames["PolicyOut"]).optional(),
            "bindings": t.array(t.proxy(renames["BindingOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionSetPolicyRequestOut"])
    types["VpnTunnelListIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["VpnTunnelIn"])).optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["VpnTunnelListIn"])
    types["VpnTunnelListOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["VpnTunnelOut"])).optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnTunnelListOut"])
    types["BackendServiceListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["BackendServiceIn"])).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
        }
    ).named(renames["BackendServiceListIn"])
    types["BackendServiceListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["BackendServiceOut"])).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceListOut"])
    types["InstanceTemplatesScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "instanceTemplates": t.array(
                t.proxy(renames["InstanceTemplateIn"])
            ).optional(),
        }
    ).named(renames["InstanceTemplatesScopedListIn"])
    types["InstanceTemplatesScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "instanceTemplates": t.array(
                t.proxy(renames["InstanceTemplateOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceTemplatesScopedListOut"])
    types["RouteIn"] = t.struct(
        {
            "routeType": t.string().optional(),
            "tags": t.array(t.string()).optional(),
            "destRange": t.string().optional(),
            "kind": t.string().optional(),
            "priority": t.integer().optional(),
            "nextHopVpnTunnel": t.string().optional(),
            "nextHopGateway": t.string().optional(),
            "network": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextHopIp": t.string().optional(),
            "asPaths": t.array(t.proxy(renames["RouteAsPathIn"])).optional(),
            "description": t.string().optional(),
            "routeStatus": t.string().optional(),
            "nextHopInstance": t.string().optional(),
            "id": t.string().optional(),
            "nextHopIlb": t.string().optional(),
            "nextHopNetwork": t.string().optional(),
            "name": t.string().optional(),
            "warnings": t.array(
                t.struct(
                    {
                        "code": t.string().optional(),
                        "data": t.array(
                            t.struct(
                                {
                                    "value": t.string().optional(),
                                    "key": t.string().optional(),
                                }
                            )
                        ).optional(),
                        "message": t.string().optional(),
                    }
                )
            ).optional(),
            "creationTimestamp": t.string().optional(),
            "nextHopPeering": t.string().optional(),
        }
    ).named(renames["RouteIn"])
    types["RouteOut"] = t.struct(
        {
            "routeType": t.string().optional(),
            "tags": t.array(t.string()).optional(),
            "destRange": t.string().optional(),
            "kind": t.string().optional(),
            "priority": t.integer().optional(),
            "nextHopVpnTunnel": t.string().optional(),
            "nextHopGateway": t.string().optional(),
            "network": t.string().optional(),
            "selfLink": t.string().optional(),
            "nextHopIp": t.string().optional(),
            "asPaths": t.array(t.proxy(renames["RouteAsPathOut"])).optional(),
            "description": t.string().optional(),
            "routeStatus": t.string().optional(),
            "nextHopInstance": t.string().optional(),
            "id": t.string().optional(),
            "nextHopIlb": t.string().optional(),
            "nextHopNetwork": t.string().optional(),
            "name": t.string().optional(),
            "warnings": t.array(
                t.struct(
                    {
                        "code": t.string().optional(),
                        "data": t.array(
                            t.struct(
                                {
                                    "value": t.string().optional(),
                                    "key": t.string().optional(),
                                }
                            )
                        ).optional(),
                        "message": t.string().optional(),
                    }
                )
            ).optional(),
            "creationTimestamp": t.string().optional(),
            "nextHopPeering": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouteOut"])
    types["ManagedInstanceInstanceHealthIn"] = t.struct(
        {
            "healthCheck": t.string().optional(),
            "detailedHealthState": t.string().optional(),
        }
    ).named(renames["ManagedInstanceInstanceHealthIn"])
    types["ManagedInstanceInstanceHealthOut"] = t.struct(
        {
            "healthCheck": t.string().optional(),
            "detailedHealthState": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ManagedInstanceInstanceHealthOut"])
    types["InterconnectLocationIn"] = t.struct(
        {
            "facilityProvider": t.string().optional(),
            "continent": t.string().optional(),
            "supportsPzs": t.boolean().optional(),
            "peeringdbFacilityId": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "address": t.string().optional(),
            "availabilityZone": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "city": t.string().optional(),
            "facilityProviderFacilityId": t.string().optional(),
            "regionInfos": t.array(
                t.proxy(renames["InterconnectLocationRegionInfoIn"])
            ).optional(),
            "status": t.string().optional(),
            "name": t.string().optional(),
            "id": t.string().optional(),
        }
    ).named(renames["InterconnectLocationIn"])
    types["InterconnectLocationOut"] = t.struct(
        {
            "facilityProvider": t.string().optional(),
            "continent": t.string().optional(),
            "supportsPzs": t.boolean().optional(),
            "peeringdbFacilityId": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "address": t.string().optional(),
            "availabilityZone": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "city": t.string().optional(),
            "facilityProviderFacilityId": t.string().optional(),
            "regionInfos": t.array(
                t.proxy(renames["InterconnectLocationRegionInfoOut"])
            ).optional(),
            "status": t.string().optional(),
            "name": t.string().optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectLocationOut"])
    types["LogConfigIn"] = t.struct(
        {
            "counter": t.proxy(renames["LogConfigCounterOptionsIn"]).optional(),
            "cloudAudit": t.proxy(renames["LogConfigCloudAuditOptionsIn"]).optional(),
            "dataAccess": t.proxy(renames["LogConfigDataAccessOptionsIn"]).optional(),
        }
    ).named(renames["LogConfigIn"])
    types["LogConfigOut"] = t.struct(
        {
            "counter": t.proxy(renames["LogConfigCounterOptionsOut"]).optional(),
            "cloudAudit": t.proxy(renames["LogConfigCloudAuditOptionsOut"]).optional(),
            "dataAccess": t.proxy(renames["LogConfigDataAccessOptionsOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LogConfigOut"])
    types["SubnetworkIn"] = t.struct(
        {
            "enableFlowLogs": t.boolean().optional(),
            "gatewayAddress": t.string().optional(),
            "stackType": t.string().optional(),
            "selfLink": t.string().optional(),
            "ipCidrRange": t.string().optional(),
            "internalIpv6Prefix": t.string().optional(),
            "fingerprint": t.string().optional(),
            "id": t.string().optional(),
            "ipv6AccessType": t.string().optional(),
            "state": t.string().optional(),
            "name": t.string().optional(),
            "privateIpv6GoogleAccess": t.string().optional(),
            "secondaryIpRanges": t.array(
                t.proxy(renames["SubnetworkSecondaryRangeIn"])
            ).optional(),
            "externalIpv6Prefix": t.string().optional(),
            "region": t.string().optional(),
            "logConfig": t.proxy(renames["SubnetworkLogConfigIn"]).optional(),
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "network": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "privateIpGoogleAccess": t.boolean().optional(),
            "purpose": t.string().optional(),
            "ipv6CidrRange": t.string().optional(),
            "role": t.string().optional(),
        }
    ).named(renames["SubnetworkIn"])
    types["SubnetworkOut"] = t.struct(
        {
            "enableFlowLogs": t.boolean().optional(),
            "gatewayAddress": t.string().optional(),
            "stackType": t.string().optional(),
            "selfLink": t.string().optional(),
            "ipCidrRange": t.string().optional(),
            "internalIpv6Prefix": t.string().optional(),
            "fingerprint": t.string().optional(),
            "id": t.string().optional(),
            "ipv6AccessType": t.string().optional(),
            "state": t.string().optional(),
            "name": t.string().optional(),
            "privateIpv6GoogleAccess": t.string().optional(),
            "secondaryIpRanges": t.array(
                t.proxy(renames["SubnetworkSecondaryRangeOut"])
            ).optional(),
            "externalIpv6Prefix": t.string().optional(),
            "region": t.string().optional(),
            "logConfig": t.proxy(renames["SubnetworkLogConfigOut"]).optional(),
            "kind": t.string().optional(),
            "description": t.string().optional(),
            "network": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "privateIpGoogleAccess": t.boolean().optional(),
            "purpose": t.string().optional(),
            "ipv6CidrRange": t.string().optional(),
            "role": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SubnetworkOut"])
    types["TargetPoolAggregatedListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
        }
    ).named(renames["TargetPoolAggregatedListIn"])
    types["TargetPoolAggregatedListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "selfLink": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetPoolAggregatedListOut"])
    types["InstanceGroupsAddInstancesRequestIn"] = t.struct(
        {"instances": t.array(t.proxy(renames["InstanceReferenceIn"])).optional()}
    ).named(renames["InstanceGroupsAddInstancesRequestIn"])
    types["InstanceGroupsAddInstancesRequestOut"] = t.struct(
        {
            "instances": t.array(t.proxy(renames["InstanceReferenceOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupsAddInstancesRequestOut"])
    types["InstanceGroupIn"] = t.struct(
        {
            "creationTimestamp": t.string().optional(),
            "id": t.string().optional(),
            "description": t.string().optional(),
            "region": t.string().optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "subnetwork": t.string().optional(),
            "network": t.string().optional(),
            "zone": t.string().optional(),
            "namedPorts": t.array(t.proxy(renames["NamedPortIn"])).optional(),
            "fingerprint": t.string().optional(),
            "kind": t.string().optional(),
            "size": t.integer().optional(),
        }
    ).named(renames["InstanceGroupIn"])
    types["InstanceGroupOut"] = t.struct(
        {
            "creationTimestamp": t.string().optional(),
            "id": t.string().optional(),
            "description": t.string().optional(),
            "region": t.string().optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "subnetwork": t.string().optional(),
            "network": t.string().optional(),
            "zone": t.string().optional(),
            "namedPorts": t.array(t.proxy(renames["NamedPortOut"])).optional(),
            "fingerprint": t.string().optional(),
            "kind": t.string().optional(),
            "size": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupOut"])
    types["FirewallPolicyRuleSecureTagIn"] = t.struct(
        {"name": t.string().optional(), "state": t.string().optional()}
    ).named(renames["FirewallPolicyRuleSecureTagIn"])
    types["FirewallPolicyRuleSecureTagOut"] = t.struct(
        {
            "name": t.string().optional(),
            "state": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["FirewallPolicyRuleSecureTagOut"])
    types["SnapshotListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["SnapshotIn"])).optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["SnapshotListIn"])
    types["SnapshotListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["SnapshotOut"])).optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SnapshotListOut"])
    types["GlobalSetLabelsRequestIn"] = t.struct(
        {
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "labelFingerprint": t.string().optional(),
        }
    ).named(renames["GlobalSetLabelsRequestIn"])
    types["GlobalSetLabelsRequestOut"] = t.struct(
        {
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "labelFingerprint": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["GlobalSetLabelsRequestOut"])
    types["RegionAddressesMoveRequestIn"] = t.struct(
        {
            "destinationAddress": t.string().optional(),
            "description": t.string().optional(),
        }
    ).named(renames["RegionAddressesMoveRequestIn"])
    types["RegionAddressesMoveRequestOut"] = t.struct(
        {
            "destinationAddress": t.string().optional(),
            "description": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionAddressesMoveRequestOut"])
    types["InstanceGroupManagersListManagedInstancesResponseIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "managedInstances": t.array(
                t.proxy(renames["ManagedInstanceIn"])
            ).optional(),
        }
    ).named(renames["InstanceGroupManagersListManagedInstancesResponseIn"])
    types["InstanceGroupManagersListManagedInstancesResponseOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "managedInstances": t.array(
                t.proxy(renames["ManagedInstanceOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersListManagedInstancesResponseOut"])
    types["InstanceGroupManagersPatchPerInstanceConfigsReqIn"] = t.struct(
        {
            "perInstanceConfigs": t.array(
                t.proxy(renames["PerInstanceConfigIn"])
            ).optional()
        }
    ).named(renames["InstanceGroupManagersPatchPerInstanceConfigsReqIn"])
    types["InstanceGroupManagersPatchPerInstanceConfigsReqOut"] = t.struct(
        {
            "perInstanceConfigs": t.array(
                t.proxy(renames["PerInstanceConfigOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersPatchPerInstanceConfigsReqOut"])
    types["NetworkAttachmentListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["NetworkAttachmentIn"])).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
        }
    ).named(renames["NetworkAttachmentListIn"])
    types["NetworkAttachmentListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["NetworkAttachmentOut"])).optional(),
            "selfLink": t.string().optional(),
            "kind": t.string(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkAttachmentListOut"])
    types["NodeGroupsSetNodeTemplateRequestIn"] = t.struct(
        {"nodeTemplate": t.string().optional()}
    ).named(renames["NodeGroupsSetNodeTemplateRequestIn"])
    types["NodeGroupsSetNodeTemplateRequestOut"] = t.struct(
        {
            "nodeTemplate": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeGroupsSetNodeTemplateRequestOut"])
    types["NetworkInterfaceIn"] = t.struct(
        {
            "ipv6Address": t.string().optional(),
            "queueCount": t.integer().optional(),
            "accessConfigs": t.array(t.proxy(renames["AccessConfigIn"])).optional(),
            "kind": t.string().optional(),
            "name": t.string().optional(),
            "fingerprint": t.string().optional(),
            "stackType": t.string().optional(),
            "networkIP": t.string().optional(),
            "nicType": t.string().optional(),
            "network": t.string().optional(),
            "subnetwork": t.string().optional(),
            "ipv6AccessType": t.string().optional(),
            "ipv6AccessConfigs": t.array(t.proxy(renames["AccessConfigIn"])).optional(),
            "networkAttachment": t.string().optional(),
            "aliasIpRanges": t.array(t.proxy(renames["AliasIpRangeIn"])).optional(),
            "internalIpv6PrefixLength": t.integer().optional(),
        }
    ).named(renames["NetworkInterfaceIn"])
    types["NetworkInterfaceOut"] = t.struct(
        {
            "ipv6Address": t.string().optional(),
            "queueCount": t.integer().optional(),
            "accessConfigs": t.array(t.proxy(renames["AccessConfigOut"])).optional(),
            "kind": t.string().optional(),
            "name": t.string().optional(),
            "fingerprint": t.string().optional(),
            "stackType": t.string().optional(),
            "networkIP": t.string().optional(),
            "nicType": t.string().optional(),
            "network": t.string().optional(),
            "subnetwork": t.string().optional(),
            "ipv6AccessType": t.string().optional(),
            "ipv6AccessConfigs": t.array(
                t.proxy(renames["AccessConfigOut"])
            ).optional(),
            "networkAttachment": t.string().optional(),
            "aliasIpRanges": t.array(t.proxy(renames["AliasIpRangeOut"])).optional(),
            "internalIpv6PrefixLength": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkInterfaceOut"])
    types["TargetHttpsProxyIn"] = t.struct(
        {
            "description": t.string().optional(),
            "id": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "certificateMap": t.string().optional(),
            "fingerprint": t.string().optional(),
            "sslPolicy": t.string().optional(),
            "sslCertificates": t.array(t.string()).optional(),
            "quicOverride": t.string().optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "region": t.string().optional(),
            "proxyBind": t.boolean().optional(),
            "kind": t.string().optional(),
            "urlMap": t.string().optional(),
            "serverTlsPolicy": t.string().optional(),
            "authorizationPolicy": t.string().optional(),
        }
    ).named(renames["TargetHttpsProxyIn"])
    types["TargetHttpsProxyOut"] = t.struct(
        {
            "description": t.string().optional(),
            "id": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "certificateMap": t.string().optional(),
            "fingerprint": t.string().optional(),
            "sslPolicy": t.string().optional(),
            "sslCertificates": t.array(t.string()).optional(),
            "quicOverride": t.string().optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "region": t.string().optional(),
            "proxyBind": t.boolean().optional(),
            "kind": t.string().optional(),
            "urlMap": t.string().optional(),
            "serverTlsPolicy": t.string().optional(),
            "authorizationPolicy": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetHttpsProxyOut"])
    types["HttpFaultDelayIn"] = t.struct(
        {
            "percentage": t.number().optional(),
            "fixedDelay": t.proxy(renames["DurationIn"]).optional(),
        }
    ).named(renames["HttpFaultDelayIn"])
    types["HttpFaultDelayOut"] = t.struct(
        {
            "percentage": t.number().optional(),
            "fixedDelay": t.proxy(renames["DurationOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpFaultDelayOut"])
    types["BackendServiceLocalityLoadBalancingPolicyConfigIn"] = t.struct(
        {
            "policy": t.proxy(
                renames["BackendServiceLocalityLoadBalancingPolicyConfigPolicyIn"]
            ),
            "customPolicy": t.proxy(
                renames["BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicyIn"]
            ),
        }
    ).named(renames["BackendServiceLocalityLoadBalancingPolicyConfigIn"])
    types["BackendServiceLocalityLoadBalancingPolicyConfigOut"] = t.struct(
        {
            "policy": t.proxy(
                renames["BackendServiceLocalityLoadBalancingPolicyConfigPolicyOut"]
            ),
            "customPolicy": t.proxy(
                renames[
                    "BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicyOut"
                ]
            ),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendServiceLocalityLoadBalancingPolicyConfigOut"])
    types["RouteAsPathIn"] = t.struct(
        {
            "asLists": t.array(t.integer()).optional(),
            "pathSegmentType": t.string().optional(),
        }
    ).named(renames["RouteAsPathIn"])
    types["RouteAsPathOut"] = t.struct(
        {
            "asLists": t.array(t.integer()).optional(),
            "pathSegmentType": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouteAsPathOut"])
    types["ReservationListIn"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["ReservationIn"])).optional(),
            "id": t.string().optional(),
        }
    ).named(renames["ReservationListIn"])
    types["ReservationListOut"] = t.struct(
        {
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["ReservationOut"])).optional(),
            "id": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ReservationListOut"])
    types["UrlMapsValidateRequestIn"] = t.struct(
        {
            "loadBalancingSchemes": t.array(t.string()).optional(),
            "resource": t.proxy(renames["UrlMapIn"]).optional(),
        }
    ).named(renames["UrlMapsValidateRequestIn"])
    types["UrlMapsValidateRequestOut"] = t.struct(
        {
            "loadBalancingSchemes": t.array(t.string()).optional(),
            "resource": t.proxy(renames["UrlMapOut"]).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UrlMapsValidateRequestOut"])
    types["NodeTemplateIn"] = t.struct(
        {
            "id": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "nodeTypeFlexibility": t.proxy(
                renames["NodeTemplateNodeTypeFlexibilityIn"]
            ).optional(),
            "accelerators": t.array(t.proxy(renames["AcceleratorConfigIn"])),
            "disks": t.array(t.proxy(renames["LocalDiskIn"])),
            "nodeAffinityLabels": t.struct({"_": t.string().optional()}).optional(),
            "statusMessage": t.string().optional(),
            "serverBinding": t.proxy(renames["ServerBindingIn"]).optional(),
            "cpuOvercommitType": t.string().optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "description": t.string().optional(),
            "status": t.string().optional(),
            "region": t.string().optional(),
            "nodeType": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["NodeTemplateIn"])
    types["NodeTemplateOut"] = t.struct(
        {
            "id": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "nodeTypeFlexibility": t.proxy(
                renames["NodeTemplateNodeTypeFlexibilityOut"]
            ).optional(),
            "accelerators": t.array(t.proxy(renames["AcceleratorConfigOut"])),
            "disks": t.array(t.proxy(renames["LocalDiskOut"])),
            "nodeAffinityLabels": t.struct({"_": t.string().optional()}).optional(),
            "statusMessage": t.string().optional(),
            "serverBinding": t.proxy(renames["ServerBindingOut"]).optional(),
            "cpuOvercommitType": t.string().optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "description": t.string().optional(),
            "status": t.string().optional(),
            "region": t.string().optional(),
            "nodeType": t.string().optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NodeTemplateOut"])
    types["TargetHttpsProxyListIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["TargetHttpsProxyIn"])).optional(),
        }
    ).named(renames["TargetHttpsProxyListIn"])
    types["TargetHttpsProxyListOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["TargetHttpsProxyOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetHttpsProxyListOut"])
    types["PacketIntervalsIn"] = t.struct(
        {
            "maxMs": t.string().optional(),
            "type": t.string().optional(),
            "avgMs": t.string().optional(),
            "numIntervals": t.string().optional(),
            "duration": t.string().optional(),
            "minMs": t.string().optional(),
        }
    ).named(renames["PacketIntervalsIn"])
    types["PacketIntervalsOut"] = t.struct(
        {
            "maxMs": t.string().optional(),
            "type": t.string().optional(),
            "avgMs": t.string().optional(),
            "numIntervals": t.string().optional(),
            "duration": t.string().optional(),
            "minMs": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PacketIntervalsOut"])
    types["InstanceGroupManagersSetTargetPoolsRequestIn"] = t.struct(
        {
            "fingerprint": t.string().optional(),
            "targetPools": t.array(t.string()).optional(),
        }
    ).named(renames["InstanceGroupManagersSetTargetPoolsRequestIn"])
    types["InstanceGroupManagersSetTargetPoolsRequestOut"] = t.struct(
        {
            "fingerprint": t.string().optional(),
            "targetPools": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersSetTargetPoolsRequestOut"])
    types["SubnetworksScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "subnetworks": t.array(t.proxy(renames["SubnetworkIn"])).optional(),
        }
    ).named(renames["SubnetworksScopedListIn"])
    types["SubnetworksScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "subnetworks": t.array(t.proxy(renames["SubnetworkOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SubnetworksScopedListOut"])
    types["ServiceAttachmentConnectedEndpointIn"] = t.struct(
        {
            "endpoint": t.string().optional(),
            "pscConnectionId": t.string().optional(),
            "status": t.string().optional(),
        }
    ).named(renames["ServiceAttachmentConnectedEndpointIn"])
    types["ServiceAttachmentConnectedEndpointOut"] = t.struct(
        {
            "endpoint": t.string().optional(),
            "pscConnectionId": t.string().optional(),
            "status": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ServiceAttachmentConnectedEndpointOut"])
    types["PathMatcherIn"] = t.struct(
        {
            "defaultUrlRedirect": t.proxy(renames["HttpRedirectActionIn"]).optional(),
            "routeRules": t.array(t.proxy(renames["HttpRouteRuleIn"])).optional(),
            "defaultService": t.string().optional(),
            "headerAction": t.proxy(renames["HttpHeaderActionIn"]).optional(),
            "name": t.string().optional(),
            "description": t.string().optional(),
            "defaultRouteAction": t.proxy(renames["HttpRouteActionIn"]).optional(),
            "pathRules": t.array(t.proxy(renames["PathRuleIn"])).optional(),
        }
    ).named(renames["PathMatcherIn"])
    types["PathMatcherOut"] = t.struct(
        {
            "defaultUrlRedirect": t.proxy(renames["HttpRedirectActionOut"]).optional(),
            "routeRules": t.array(t.proxy(renames["HttpRouteRuleOut"])).optional(),
            "defaultService": t.string().optional(),
            "headerAction": t.proxy(renames["HttpHeaderActionOut"]).optional(),
            "name": t.string().optional(),
            "description": t.string().optional(),
            "defaultRouteAction": t.proxy(renames["HttpRouteActionOut"]).optional(),
            "pathRules": t.array(t.proxy(renames["PathRuleOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PathMatcherOut"])
    types["UrlMapTestIn"] = t.struct(
        {
            "description": t.string().optional(),
            "host": t.string().optional(),
            "expectedOutputUrl": t.string().optional(),
            "path": t.string().optional(),
            "service": t.string().optional(),
            "headers": t.array(t.proxy(renames["UrlMapTestHeaderIn"])).optional(),
            "expectedRedirectResponseCode": t.integer().optional(),
        }
    ).named(renames["UrlMapTestIn"])
    types["UrlMapTestOut"] = t.struct(
        {
            "description": t.string().optional(),
            "host": t.string().optional(),
            "expectedOutputUrl": t.string().optional(),
            "path": t.string().optional(),
            "service": t.string().optional(),
            "headers": t.array(t.proxy(renames["UrlMapTestHeaderOut"])).optional(),
            "expectedRedirectResponseCode": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UrlMapTestOut"])
    types["NetworkAttachmentIn"] = t.struct(
        {
            "subnetworks": t.array(t.string()).optional(),
            "description": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "connectionEndpoints": t.array(
                t.proxy(renames["NetworkAttachmentConnectedEndpointIn"])
            ).optional(),
            "network": t.string().optional(),
            "producerAcceptLists": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "selfLinkWithId": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "region": t.string().optional(),
            "producerRejectLists": t.array(t.string()).optional(),
            "name": t.string().optional(),
            "fingerprint": t.string().optional(),
            "connectionPreference": t.string(),
        }
    ).named(renames["NetworkAttachmentIn"])
    types["NetworkAttachmentOut"] = t.struct(
        {
            "subnetworks": t.array(t.string()).optional(),
            "description": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "connectionEndpoints": t.array(
                t.proxy(renames["NetworkAttachmentConnectedEndpointOut"])
            ).optional(),
            "network": t.string().optional(),
            "producerAcceptLists": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "selfLinkWithId": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "region": t.string().optional(),
            "producerRejectLists": t.array(t.string()).optional(),
            "name": t.string().optional(),
            "fingerprint": t.string().optional(),
            "connectionPreference": t.string(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkAttachmentOut"])
    types["NetworkEndpointGroupsDetachEndpointsRequestIn"] = t.struct(
        {"networkEndpoints": t.array(t.proxy(renames["NetworkEndpointIn"])).optional()}
    ).named(renames["NetworkEndpointGroupsDetachEndpointsRequestIn"])
    types["NetworkEndpointGroupsDetachEndpointsRequestOut"] = t.struct(
        {
            "networkEndpoints": t.array(
                t.proxy(renames["NetworkEndpointOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointGroupsDetachEndpointsRequestOut"])
    types["RouterInterfaceIn"] = t.struct(
        {
            "managementType": t.string().optional(),
            "name": t.string().optional(),
            "subnetwork": t.string().optional(),
            "redundantInterface": t.string().optional(),
            "privateIpAddress": t.string().optional(),
            "ipRange": t.string().optional(),
            "linkedInterconnectAttachment": t.string().optional(),
            "linkedVpnTunnel": t.string().optional(),
        }
    ).named(renames["RouterInterfaceIn"])
    types["RouterInterfaceOut"] = t.struct(
        {
            "managementType": t.string().optional(),
            "name": t.string().optional(),
            "subnetwork": t.string().optional(),
            "redundantInterface": t.string().optional(),
            "privateIpAddress": t.string().optional(),
            "ipRange": t.string().optional(),
            "linkedInterconnectAttachment": t.string().optional(),
            "linkedVpnTunnel": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterInterfaceOut"])
    types["ForwardingRuleServiceDirectoryRegistrationIn"] = t.struct(
        {
            "serviceDirectoryRegion": t.string().optional(),
            "namespace": t.string().optional(),
            "service": t.string().optional(),
        }
    ).named(renames["ForwardingRuleServiceDirectoryRegistrationIn"])
    types["ForwardingRuleServiceDirectoryRegistrationOut"] = t.struct(
        {
            "serviceDirectoryRegion": t.string().optional(),
            "namespace": t.string().optional(),
            "service": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ForwardingRuleServiceDirectoryRegistrationOut"])
    types["PublicDelegatedPrefixesScopedListIn"] = t.struct(
        {
            "publicDelegatedPrefixes": t.array(
                t.proxy(renames["PublicDelegatedPrefixIn"])
            ).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["PublicDelegatedPrefixesScopedListIn"])
    types["PublicDelegatedPrefixesScopedListOut"] = t.struct(
        {
            "publicDelegatedPrefixes": t.array(
                t.proxy(renames["PublicDelegatedPrefixOut"])
            ).optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["PublicDelegatedPrefixesScopedListOut"])
    types["InstanceIn"] = t.struct(
        {
            "canIpForward": t.boolean().optional(),
            "cpuPlatform": t.string().optional(),
            "kind": t.string().optional(),
            "status": t.string().optional(),
            "sourceMachineImage": t.string().optional(),
            "machineType": t.string().optional(),
            "satisfiesPzs": t.boolean().optional(),
            "tags": t.proxy(renames["TagsIn"]).optional(),
            "sourceMachineImageEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyIn"]
            ).optional(),
            "deletionProtection": t.boolean().optional(),
            "serviceAccounts": t.array(t.proxy(renames["ServiceAccountIn"])).optional(),
            "statusMessage": t.string().optional(),
            "hostname": t.string().optional(),
            "name": t.string().optional(),
            "confidentialInstanceConfig": t.proxy(
                renames["ConfidentialInstanceConfigIn"]
            ),
            "reservationAffinity": t.proxy(renames["ReservationAffinityIn"]).optional(),
            "metadata": t.proxy(renames["MetadataIn"]).optional(),
            "shieldedInstanceConfig": t.proxy(renames["ShieldedInstanceConfigIn"]),
            "keyRevocationActionType": t.string().optional(),
            "fingerprint": t.string().optional(),
            "displayDevice": t.proxy(renames["DisplayDeviceIn"]).optional(),
            "startRestricted": t.boolean().optional(),
            "lastSuspendedTimestamp": t.string().optional(),
            "guestAccelerators": t.array(
                t.proxy(renames["AcceleratorConfigIn"])
            ).optional(),
            "instanceEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyIn"]
            ).optional(),
            "resourcePolicies": t.array(t.string()).optional(),
            "shieldedInstanceIntegrityPolicy": t.proxy(
                renames["ShieldedInstanceIntegrityPolicyIn"]
            ),
            "creationTimestamp": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "labelFingerprint": t.string().optional(),
            "description": t.string().optional(),
            "scheduling": t.proxy(renames["SchedulingIn"]).optional(),
            "networkPerformanceConfig": t.proxy(renames["NetworkPerformanceConfigIn"]),
            "privateIpv6GoogleAccess": t.string().optional(),
            "networkInterfaces": t.array(
                t.proxy(renames["NetworkInterfaceIn"])
            ).optional(),
            "advancedMachineFeatures": t.proxy(
                renames["AdvancedMachineFeaturesIn"]
            ).optional(),
            "params": t.proxy(renames["InstanceParamsIn"]).optional(),
            "minCpuPlatform": t.string().optional(),
            "lastStartTimestamp": t.string().optional(),
            "resourceStatus": t.proxy(renames["ResourceStatusIn"]).optional(),
            "selfLink": t.string().optional(),
            "disks": t.array(t.proxy(renames["AttachedDiskIn"])).optional(),
            "id": t.string().optional(),
            "zone": t.string().optional(),
            "lastStopTimestamp": t.string().optional(),
        }
    ).named(renames["InstanceIn"])
    types["InstanceOut"] = t.struct(
        {
            "canIpForward": t.boolean().optional(),
            "cpuPlatform": t.string().optional(),
            "kind": t.string().optional(),
            "status": t.string().optional(),
            "sourceMachineImage": t.string().optional(),
            "machineType": t.string().optional(),
            "satisfiesPzs": t.boolean().optional(),
            "tags": t.proxy(renames["TagsOut"]).optional(),
            "sourceMachineImageEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "deletionProtection": t.boolean().optional(),
            "serviceAccounts": t.array(
                t.proxy(renames["ServiceAccountOut"])
            ).optional(),
            "statusMessage": t.string().optional(),
            "hostname": t.string().optional(),
            "name": t.string().optional(),
            "confidentialInstanceConfig": t.proxy(
                renames["ConfidentialInstanceConfigOut"]
            ),
            "reservationAffinity": t.proxy(
                renames["ReservationAffinityOut"]
            ).optional(),
            "metadata": t.proxy(renames["MetadataOut"]).optional(),
            "shieldedInstanceConfig": t.proxy(renames["ShieldedInstanceConfigOut"]),
            "keyRevocationActionType": t.string().optional(),
            "fingerprint": t.string().optional(),
            "displayDevice": t.proxy(renames["DisplayDeviceOut"]).optional(),
            "startRestricted": t.boolean().optional(),
            "lastSuspendedTimestamp": t.string().optional(),
            "guestAccelerators": t.array(
                t.proxy(renames["AcceleratorConfigOut"])
            ).optional(),
            "instanceEncryptionKey": t.proxy(
                renames["CustomerEncryptionKeyOut"]
            ).optional(),
            "resourcePolicies": t.array(t.string()).optional(),
            "shieldedInstanceIntegrityPolicy": t.proxy(
                renames["ShieldedInstanceIntegrityPolicyOut"]
            ),
            "creationTimestamp": t.string().optional(),
            "labels": t.struct({"_": t.string().optional()}).optional(),
            "labelFingerprint": t.string().optional(),
            "description": t.string().optional(),
            "scheduling": t.proxy(renames["SchedulingOut"]).optional(),
            "networkPerformanceConfig": t.proxy(renames["NetworkPerformanceConfigOut"]),
            "privateIpv6GoogleAccess": t.string().optional(),
            "networkInterfaces": t.array(
                t.proxy(renames["NetworkInterfaceOut"])
            ).optional(),
            "advancedMachineFeatures": t.proxy(
                renames["AdvancedMachineFeaturesOut"]
            ).optional(),
            "params": t.proxy(renames["InstanceParamsOut"]).optional(),
            "minCpuPlatform": t.string().optional(),
            "lastStartTimestamp": t.string().optional(),
            "resourceStatus": t.proxy(renames["ResourceStatusOut"]).optional(),
            "selfLink": t.string().optional(),
            "disks": t.array(t.proxy(renames["AttachedDiskOut"])).optional(),
            "id": t.string().optional(),
            "zone": t.string().optional(),
            "lastStopTimestamp": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceOut"])
    types["BackendBucketCdnPolicyCacheKeyPolicyIn"] = t.struct(
        {
            "includeHttpHeaders": t.array(t.string()).optional(),
            "queryStringWhitelist": t.array(t.string()).optional(),
        }
    ).named(renames["BackendBucketCdnPolicyCacheKeyPolicyIn"])
    types["BackendBucketCdnPolicyCacheKeyPolicyOut"] = t.struct(
        {
            "includeHttpHeaders": t.array(t.string()).optional(),
            "queryStringWhitelist": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["BackendBucketCdnPolicyCacheKeyPolicyOut"])
    types["CommitmentAggregatedListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["CommitmentAggregatedListIn"])
    types["CommitmentAggregatedListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "unreachables": t.array(t.string()).optional(),
            "selfLink": t.string().optional(),
            "items": t.struct({"_": t.string().optional()}).optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["CommitmentAggregatedListOut"])
    types["SslCertificateSelfManagedSslCertificateIn"] = t.struct(
        {"privateKey": t.string().optional(), "certificate": t.string().optional()}
    ).named(renames["SslCertificateSelfManagedSslCertificateIn"])
    types["SslCertificateSelfManagedSslCertificateOut"] = t.struct(
        {
            "privateKey": t.string().optional(),
            "certificate": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SslCertificateSelfManagedSslCertificateOut"])
    types["NetworkEndpointGroupCloudRunIn"] = t.struct(
        {
            "service": t.string().optional(),
            "tag": t.string().optional(),
            "urlMask": t.string().optional(),
        }
    ).named(renames["NetworkEndpointGroupCloudRunIn"])
    types["NetworkEndpointGroupCloudRunOut"] = t.struct(
        {
            "service": t.string().optional(),
            "tag": t.string().optional(),
            "urlMask": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEndpointGroupCloudRunOut"])
    types["TestPermissionsRequestIn"] = t.struct(
        {"permissions": t.array(t.string()).optional()}
    ).named(renames["TestPermissionsRequestIn"])
    types["TestPermissionsRequestOut"] = t.struct(
        {
            "permissions": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TestPermissionsRequestOut"])
    types["InstanceGroupManagerAutoHealingPolicyIn"] = t.struct(
        {
            "initialDelaySec": t.integer().optional(),
            "healthCheck": t.string().optional(),
        }
    ).named(renames["InstanceGroupManagerAutoHealingPolicyIn"])
    types["InstanceGroupManagerAutoHealingPolicyOut"] = t.struct(
        {
            "initialDelaySec": t.integer().optional(),
            "healthCheck": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagerAutoHealingPolicyOut"])
    types["SecurityPolicyListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["SecurityPolicyIn"])).optional(),
            "nextPageToken": t.string().optional(),
        }
    ).named(renames["SecurityPolicyListIn"])
    types["SecurityPolicyListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "items": t.array(t.proxy(renames["SecurityPolicyOut"])).optional(),
            "nextPageToken": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPolicyListOut"])
    types["SecurityPoliciesListPreconfiguredExpressionSetsResponseIn"] = t.struct(
        {"preconfiguredExpressionSets": t.proxy(renames["SecurityPoliciesWafConfigIn"])}
    ).named(renames["SecurityPoliciesListPreconfiguredExpressionSetsResponseIn"])
    types["SecurityPoliciesListPreconfiguredExpressionSetsResponseOut"] = t.struct(
        {
            "preconfiguredExpressionSets": t.proxy(
                renames["SecurityPoliciesWafConfigOut"]
            ),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SecurityPoliciesListPreconfiguredExpressionSetsResponseOut"])
    types["CacheInvalidationRuleIn"] = t.struct(
        {"path": t.string(), "host": t.string().optional()}
    ).named(renames["CacheInvalidationRuleIn"])
    types["CacheInvalidationRuleOut"] = t.struct(
        {
            "path": t.string(),
            "host": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["CacheInvalidationRuleOut"])
    types["UrlMapValidationResultIn"] = t.struct(
        {
            "loadErrors": t.array(t.string()),
            "loadSucceeded": t.boolean().optional(),
            "testFailures": t.array(t.proxy(renames["TestFailureIn"])),
            "testPassed": t.boolean().optional(),
        }
    ).named(renames["UrlMapValidationResultIn"])
    types["UrlMapValidationResultOut"] = t.struct(
        {
            "loadErrors": t.array(t.string()),
            "loadSucceeded": t.boolean().optional(),
            "testFailures": t.array(t.proxy(renames["TestFailureOut"])),
            "testPassed": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["UrlMapValidationResultOut"])
    types["TestFailureIn"] = t.struct(
        {
            "actualOutputUrl": t.string().optional(),
            "headers": t.array(t.proxy(renames["UrlMapTestHeaderIn"])).optional(),
            "path": t.string().optional(),
            "expectedRedirectResponseCode": t.integer().optional(),
            "actualRedirectResponseCode": t.integer().optional(),
            "host": t.string().optional(),
            "actualService": t.string().optional(),
            "expectedOutputUrl": t.string().optional(),
            "expectedService": t.string().optional(),
        }
    ).named(renames["TestFailureIn"])
    types["TestFailureOut"] = t.struct(
        {
            "actualOutputUrl": t.string().optional(),
            "headers": t.array(t.proxy(renames["UrlMapTestHeaderOut"])).optional(),
            "path": t.string().optional(),
            "expectedRedirectResponseCode": t.integer().optional(),
            "actualRedirectResponseCode": t.integer().optional(),
            "host": t.string().optional(),
            "actualService": t.string().optional(),
            "expectedOutputUrl": t.string().optional(),
            "expectedService": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TestFailureOut"])
    types["ExternalVpnGatewayListIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["ExternalVpnGatewayIn"])).optional(),
            "kind": t.string().optional(),
            "etag": t.string(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["ExternalVpnGatewayListIn"])
    types["ExternalVpnGatewayListOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["ExternalVpnGatewayOut"])).optional(),
            "kind": t.string().optional(),
            "etag": t.string(),
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ExternalVpnGatewayListOut"])
    types["VpnGatewayListIn"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["VpnGatewayIn"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["VpnGatewayListIn"])
    types["VpnGatewayListOut"] = t.struct(
        {
            "selfLink": t.string().optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["VpnGatewayOut"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["VpnGatewayListOut"])
    types["InstanceListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceIn"])).optional(),
        }
    ).named(renames["InstanceListIn"])
    types["InstanceListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "id": t.string().optional(),
            "items": t.array(t.proxy(renames["InstanceOut"])).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceListOut"])
    types["RegionTargetHttpsProxiesSetSslCertificatesRequestIn"] = t.struct(
        {"sslCertificates": t.array(t.string()).optional()}
    ).named(renames["RegionTargetHttpsProxiesSetSslCertificatesRequestIn"])
    types["RegionTargetHttpsProxiesSetSslCertificatesRequestOut"] = t.struct(
        {
            "sslCertificates": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionTargetHttpsProxiesSetSslCertificatesRequestOut"])
    types["InstanceTemplateListIn"] = t.struct(
        {
            "items": t.array(t.proxy(renames["InstanceTemplateIn"])).optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["InstanceTemplateListIn"])
    types["InstanceTemplateListOut"] = t.struct(
        {
            "items": t.array(t.proxy(renames["InstanceTemplateOut"])).optional(),
            "selfLink": t.string().optional(),
            "warning": t.struct(
                {
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceTemplateListOut"])
    types["ConfidentialInstanceConfigIn"] = t.struct(
        {"enableConfidentialCompute": t.boolean().optional()}
    ).named(renames["ConfidentialInstanceConfigIn"])
    types["ConfidentialInstanceConfigOut"] = t.struct(
        {
            "enableConfidentialCompute": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ConfidentialInstanceConfigOut"])
    types["HealthChecksScopedListIn"] = t.struct(
        {
            "healthChecks": t.array(t.proxy(renames["HealthCheckIn"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
        }
    ).named(renames["HealthChecksScopedListIn"])
    types["HealthChecksScopedListOut"] = t.struct(
        {
            "healthChecks": t.array(t.proxy(renames["HealthCheckOut"])).optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HealthChecksScopedListOut"])
    types["TargetTcpProxiesSetBackendServiceRequestIn"] = t.struct(
        {"service": t.string().optional()}
    ).named(renames["TargetTcpProxiesSetBackendServiceRequestIn"])
    types["TargetTcpProxiesSetBackendServiceRequestOut"] = t.struct(
        {
            "service": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetTcpProxiesSetBackendServiceRequestOut"])
    types["InterconnectDiagnosticsARPEntryIn"] = t.struct(
        {"macAddress": t.string().optional(), "ipAddress": t.string().optional()}
    ).named(renames["InterconnectDiagnosticsARPEntryIn"])
    types["InterconnectDiagnosticsARPEntryOut"] = t.struct(
        {
            "macAddress": t.string().optional(),
            "ipAddress": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InterconnectDiagnosticsARPEntryOut"])
    types["RegionDisksStartAsyncReplicationRequestIn"] = t.struct(
        {"asyncSecondaryDisk": t.string().optional()}
    ).named(renames["RegionDisksStartAsyncReplicationRequestIn"])
    types["RegionDisksStartAsyncReplicationRequestOut"] = t.struct(
        {
            "asyncSecondaryDisk": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RegionDisksStartAsyncReplicationRequestOut"])
    types["TargetInstancesScopedListIn"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "targetInstances": t.array(t.proxy(renames["TargetInstanceIn"])).optional(),
        }
    ).named(renames["TargetInstancesScopedListIn"])
    types["TargetInstancesScopedListOut"] = t.struct(
        {
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                }
            ).optional(),
            "targetInstances": t.array(
                t.proxy(renames["TargetInstanceOut"])
            ).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetInstancesScopedListOut"])
    types["InstanceGroupManagersAbandonInstancesRequestIn"] = t.struct(
        {"instances": t.array(t.string()).optional()}
    ).named(renames["InstanceGroupManagersAbandonInstancesRequestIn"])
    types["InstanceGroupManagersAbandonInstancesRequestOut"] = t.struct(
        {
            "instances": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupManagersAbandonInstancesRequestOut"])
    types["ResourceStatusIn"] = t.struct({"physicalHost": t.string().optional()}).named(
        renames["ResourceStatusIn"]
    )
    types["ResourceStatusOut"] = t.struct(
        {
            "physicalHost": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourceStatusOut"])
    types["ConsistentHashLoadBalancerSettingsHttpCookieIn"] = t.struct(
        {
            "ttl": t.proxy(renames["DurationIn"]).optional(),
            "name": t.string().optional(),
            "path": t.string().optional(),
        }
    ).named(renames["ConsistentHashLoadBalancerSettingsHttpCookieIn"])
    types["ConsistentHashLoadBalancerSettingsHttpCookieOut"] = t.struct(
        {
            "ttl": t.proxy(renames["DurationOut"]).optional(),
            "name": t.string().optional(),
            "path": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ConsistentHashLoadBalancerSettingsHttpCookieOut"])
    types["InstanceGroupsListInstancesRequestIn"] = t.struct(
        {"instanceState": t.string().optional()}
    ).named(renames["InstanceGroupsListInstancesRequestIn"])
    types["InstanceGroupsListInstancesRequestOut"] = t.struct(
        {
            "instanceState": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["InstanceGroupsListInstancesRequestOut"])
    types["LocationPolicyLocationConstraintsIn"] = t.struct(
        {"maxCount": t.integer().optional()}
    ).named(renames["LocationPolicyLocationConstraintsIn"])
    types["LocationPolicyLocationConstraintsOut"] = t.struct(
        {
            "maxCount": t.integer().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["LocationPolicyLocationConstraintsOut"])
    types["CorsPolicyIn"] = t.struct(
        {
            "disabled": t.boolean().optional(),
            "allowMethods": t.array(t.string()).optional(),
            "allowOriginRegexes": t.array(t.string()).optional(),
            "exposeHeaders": t.array(t.string()).optional(),
            "allowHeaders": t.array(t.string()).optional(),
            "allowOrigins": t.array(t.string()).optional(),
            "maxAge": t.integer().optional(),
            "allowCredentials": t.boolean().optional(),
        }
    ).named(renames["CorsPolicyIn"])
    types["CorsPolicyOut"] = t.struct(
        {
            "disabled": t.boolean().optional(),
            "allowMethods": t.array(t.string()).optional(),
            "allowOriginRegexes": t.array(t.string()).optional(),
            "exposeHeaders": t.array(t.string()).optional(),
            "allowHeaders": t.array(t.string()).optional(),
            "allowOrigins": t.array(t.string()).optional(),
            "maxAge": t.integer().optional(),
            "allowCredentials": t.boolean().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["CorsPolicyOut"])
    types["ResourceGroupReferenceIn"] = t.struct(
        {"group": t.string().optional()}
    ).named(renames["ResourceGroupReferenceIn"])
    types["ResourceGroupReferenceOut"] = t.struct(
        {
            "group": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["ResourceGroupReferenceOut"])
    types["SchedulingIn"] = t.struct(
        {
            "provisioningModel": t.string().optional(),
            "minNodeCpus": t.integer().optional(),
            "nodeAffinities": t.array(
                t.proxy(renames["SchedulingNodeAffinityIn"])
            ).optional(),
            "automaticRestart": t.boolean().optional(),
            "instanceTerminationAction": t.string().optional(),
            "preemptible": t.boolean().optional(),
            "locationHint": t.string().optional(),
            "onHostMaintenance": t.string().optional(),
        }
    ).named(renames["SchedulingIn"])
    types["SchedulingOut"] = t.struct(
        {
            "provisioningModel": t.string().optional(),
            "minNodeCpus": t.integer().optional(),
            "nodeAffinities": t.array(
                t.proxy(renames["SchedulingNodeAffinityOut"])
            ).optional(),
            "automaticRestart": t.boolean().optional(),
            "instanceTerminationAction": t.string().optional(),
            "preemptible": t.boolean().optional(),
            "locationHint": t.string().optional(),
            "onHostMaintenance": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SchedulingOut"])
    types["TestPermissionsResponseIn"] = t.struct(
        {"permissions": t.array(t.string()).optional()}
    ).named(renames["TestPermissionsResponseIn"])
    types["TestPermissionsResponseOut"] = t.struct(
        {
            "permissions": t.array(t.string()).optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TestPermissionsResponseOut"])
    types["TargetTcpProxyAggregatedListIn"] = t.struct(
        {
            "items": t.struct({"_": t.string().optional()}).optional(),
            "unreachables": t.array(t.string()).optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["TargetTcpProxyAggregatedListIn"])
    types["TargetTcpProxyAggregatedListOut"] = t.struct(
        {
            "items": t.struct({"_": t.string().optional()}).optional(),
            "unreachables": t.array(t.string()).optional(),
            "nextPageToken": t.string().optional(),
            "warning": t.struct(
                {
                    "data": t.array(
                        t.struct(
                            {
                                "value": t.string().optional(),
                                "key": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "message": t.string().optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "kind": t.string().optional(),
            "id": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["TargetTcpProxyAggregatedListOut"])
    types["SavedDiskIn"] = t.struct(
        {
            "kind": t.string().optional(),
            "storageBytesStatus": t.string().optional(),
            "architecture": t.string().optional(),
            "sourceDisk": t.string().optional(),
            "storageBytes": t.string().optional(),
        }
    ).named(renames["SavedDiskIn"])
    types["SavedDiskOut"] = t.struct(
        {
            "kind": t.string().optional(),
            "storageBytesStatus": t.string().optional(),
            "architecture": t.string().optional(),
            "sourceDisk": t.string().optional(),
            "storageBytes": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["SavedDiskOut"])
    types["HttpHealthCheckListIn"] = t.struct(
        {
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["HttpHealthCheckIn"])).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
        }
    ).named(renames["HttpHealthCheckListIn"])
    types["HttpHealthCheckListOut"] = t.struct(
        {
            "id": t.string().optional(),
            "warning": t.struct(
                {
                    "message": t.string().optional(),
                    "data": t.array(
                        t.struct(
                            {
                                "key": t.string().optional(),
                                "value": t.string().optional(),
                            }
                        )
                    ).optional(),
                    "code": t.string().optional(),
                }
            ).optional(),
            "nextPageToken": t.string().optional(),
            "items": t.array(t.proxy(renames["HttpHealthCheckOut"])).optional(),
            "kind": t.string().optional(),
            "selfLink": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["HttpHealthCheckListOut"])
    types["NetworkEdgeSecurityServiceIn"] = t.struct(
        {
            "fingerprint": t.string().optional(),
            "selfLinkWithId": t.string().optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "region": t.string().optional(),
            "securityPolicy": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
        }
    ).named(renames["NetworkEdgeSecurityServiceIn"])
    types["NetworkEdgeSecurityServiceOut"] = t.struct(
        {
            "fingerprint": t.string().optional(),
            "selfLinkWithId": t.string().optional(),
            "name": t.string().optional(),
            "selfLink": t.string().optional(),
            "region": t.string().optional(),
            "securityPolicy": t.string().optional(),
            "creationTimestamp": t.string().optional(),
            "description": t.string().optional(),
            "id": t.string().optional(),
            "kind": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["NetworkEdgeSecurityServiceOut"])
    types["RouterStatusBgpPeerStatusIn"] = t.struct(
        {
            "md5AuthEnabled": t.boolean().optional(),
            "ipv6NexthopAddress": t.string().optional(),
            "routerApplianceInstance": t.string().optional(),
            "status": t.string().optional(),
            "numLearnedRoutes": t.integer().optional(),
            "name": t.string().optional(),
            "peerIpv6NexthopAddress": t.string().optional(),
            "statusReason": t.string().optional(),
            "uptimeSeconds": t.string().optional(),
            "peerIpAddress": t.string().optional(),
            "enableIpv6": t.boolean().optional(),
            "advertisedRoutes": t.array(t.proxy(renames["RouteIn"])).optional(),
            "bfdStatus": t.proxy(renames["BfdStatusIn"]),
            "ipAddress": t.string().optional(),
            "uptime": t.string().optional(),
            "linkedVpnTunnel": t.string().optional(),
            "state": t.string().optional(),
        }
    ).named(renames["RouterStatusBgpPeerStatusIn"])
    types["RouterStatusBgpPeerStatusOut"] = t.struct(
        {
            "md5AuthEnabled": t.boolean().optional(),
            "ipv6NexthopAddress": t.string().optional(),
            "routerApplianceInstance": t.string().optional(),
            "status": t.string().optional(),
            "numLearnedRoutes": t.integer().optional(),
            "name": t.string().optional(),
            "peerIpv6NexthopAddress": t.string().optional(),
            "statusReason": t.string().optional(),
            "uptimeSeconds": t.string().optional(),
            "peerIpAddress": t.string().optional(),
            "enableIpv6": t.boolean().optional(),
            "advertisedRoutes": t.array(t.proxy(renames["RouteOut"])).optional(),
            "bfdStatus": t.proxy(renames["BfdStatusOut"]),
            "ipAddress": t.string().optional(),
            "uptime": t.string().optional(),
            "linkedVpnTunnel": t.string().optional(),
            "state": t.string().optional(),
            "error": t.proxy(renames["ErrorResponse"]).optional(),
        }
    ).named(renames["RouterStatusBgpPeerStatusOut"])

    functions = {}
    functions["machineTypesGet"] = compute.get(
        "projects/{project}/aggregated/machineTypes",
        t.struct(
            {
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["MachineTypeAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["machineTypesList"] = compute.get(
        "projects/{project}/aggregated/machineTypes",
        t.struct(
            {
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["MachineTypeAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["machineTypesAggregatedList"] = compute.get(
        "projects/{project}/aggregated/machineTypes",
        t.struct(
            {
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["MachineTypeAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["autoscalersUpdate"] = compute.get(
        "projects/{project}/aggregated/autoscalers",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AutoscalerAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["autoscalersPatch"] = compute.get(
        "projects/{project}/aggregated/autoscalers",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AutoscalerAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["autoscalersInsert"] = compute.get(
        "projects/{project}/aggregated/autoscalers",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AutoscalerAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["autoscalersList"] = compute.get(
        "projects/{project}/aggregated/autoscalers",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AutoscalerAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["autoscalersDelete"] = compute.get(
        "projects/{project}/aggregated/autoscalers",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AutoscalerAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["autoscalersGet"] = compute.get(
        "projects/{project}/aggregated/autoscalers",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AutoscalerAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["autoscalersAggregatedList"] = compute.get(
        "projects/{project}/aggregated/autoscalers",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AutoscalerAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["publicDelegatedPrefixesInsert"] = compute.get(
        "projects/{project}/aggregated/publicDelegatedPrefixes",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PublicDelegatedPrefixAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["publicDelegatedPrefixesGet"] = compute.get(
        "projects/{project}/aggregated/publicDelegatedPrefixes",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PublicDelegatedPrefixAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["publicDelegatedPrefixesPatch"] = compute.get(
        "projects/{project}/aggregated/publicDelegatedPrefixes",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PublicDelegatedPrefixAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["publicDelegatedPrefixesDelete"] = compute.get(
        "projects/{project}/aggregated/publicDelegatedPrefixes",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PublicDelegatedPrefixAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["publicDelegatedPrefixesList"] = compute.get(
        "projects/{project}/aggregated/publicDelegatedPrefixes",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PublicDelegatedPrefixAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["publicDelegatedPrefixesAggregatedList"] = compute.get(
        "projects/{project}/aggregated/publicDelegatedPrefixes",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PublicDelegatedPrefixAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networksList"] = compute.post(
        "projects/{project}/global/networks/{network}/addPeering",
        t.struct(
            {
                "network": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "autoCreateRoutes": t.boolean().optional(),
                "name": t.string().optional(),
                "networkPeering": t.proxy(renames["NetworkPeeringIn"]).optional(),
                "peerNetwork": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networksGet"] = compute.post(
        "projects/{project}/global/networks/{network}/addPeering",
        t.struct(
            {
                "network": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "autoCreateRoutes": t.boolean().optional(),
                "name": t.string().optional(),
                "networkPeering": t.proxy(renames["NetworkPeeringIn"]).optional(),
                "peerNetwork": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networksPatch"] = compute.post(
        "projects/{project}/global/networks/{network}/addPeering",
        t.struct(
            {
                "network": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "autoCreateRoutes": t.boolean().optional(),
                "name": t.string().optional(),
                "networkPeering": t.proxy(renames["NetworkPeeringIn"]).optional(),
                "peerNetwork": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networksDelete"] = compute.post(
        "projects/{project}/global/networks/{network}/addPeering",
        t.struct(
            {
                "network": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "autoCreateRoutes": t.boolean().optional(),
                "name": t.string().optional(),
                "networkPeering": t.proxy(renames["NetworkPeeringIn"]).optional(),
                "peerNetwork": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networksSwitchToCustomMode"] = compute.post(
        "projects/{project}/global/networks/{network}/addPeering",
        t.struct(
            {
                "network": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "autoCreateRoutes": t.boolean().optional(),
                "name": t.string().optional(),
                "networkPeering": t.proxy(renames["NetworkPeeringIn"]).optional(),
                "peerNetwork": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networksRemovePeering"] = compute.post(
        "projects/{project}/global/networks/{network}/addPeering",
        t.struct(
            {
                "network": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "autoCreateRoutes": t.boolean().optional(),
                "name": t.string().optional(),
                "networkPeering": t.proxy(renames["NetworkPeeringIn"]).optional(),
                "peerNetwork": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networksInsert"] = compute.post(
        "projects/{project}/global/networks/{network}/addPeering",
        t.struct(
            {
                "network": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "autoCreateRoutes": t.boolean().optional(),
                "name": t.string().optional(),
                "networkPeering": t.proxy(renames["NetworkPeeringIn"]).optional(),
                "peerNetwork": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networksListPeeringRoutes"] = compute.post(
        "projects/{project}/global/networks/{network}/addPeering",
        t.struct(
            {
                "network": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "autoCreateRoutes": t.boolean().optional(),
                "name": t.string().optional(),
                "networkPeering": t.proxy(renames["NetworkPeeringIn"]).optional(),
                "peerNetwork": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networksGetEffectiveFirewalls"] = compute.post(
        "projects/{project}/global/networks/{network}/addPeering",
        t.struct(
            {
                "network": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "autoCreateRoutes": t.boolean().optional(),
                "name": t.string().optional(),
                "networkPeering": t.proxy(renames["NetworkPeeringIn"]).optional(),
                "peerNetwork": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networksUpdatePeering"] = compute.post(
        "projects/{project}/global/networks/{network}/addPeering",
        t.struct(
            {
                "network": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "autoCreateRoutes": t.boolean().optional(),
                "name": t.string().optional(),
                "networkPeering": t.proxy(renames["NetworkPeeringIn"]).optional(),
                "peerNetwork": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networksAddPeering"] = compute.post(
        "projects/{project}/global/networks/{network}/addPeering",
        t.struct(
            {
                "network": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "autoCreateRoutes": t.boolean().optional(),
                "name": t.string().optional(),
                "networkPeering": t.proxy(renames["NetworkPeeringIn"]).optional(),
                "peerNetwork": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpsProxiesInsert"] = compute.post(
        "projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "targetHttpsProxy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpsProxiesSetUrlMap"] = compute.post(
        "projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "targetHttpsProxy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpsProxiesSetSslPolicy"] = compute.post(
        "projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "targetHttpsProxy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpsProxiesPatch"] = compute.post(
        "projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "targetHttpsProxy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpsProxiesAggregatedList"] = compute.post(
        "projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "targetHttpsProxy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpsProxiesGet"] = compute.post(
        "projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "targetHttpsProxy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpsProxiesList"] = compute.post(
        "projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "targetHttpsProxy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpsProxiesDelete"] = compute.post(
        "projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "targetHttpsProxy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpsProxiesSetCertificateMap"] = compute.post(
        "projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "targetHttpsProxy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpsProxiesSetQuicOverride"] = compute.post(
        "projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "targetHttpsProxy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpsProxiesSetSslCertificates"] = compute.post(
        "projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "targetHttpsProxy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetTcpProxiesDelete"] = compute.get(
        "projects/{project}/aggregated/targetTcpProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetTcpProxyAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetTcpProxiesGet"] = compute.get(
        "projects/{project}/aggregated/targetTcpProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetTcpProxyAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetTcpProxiesList"] = compute.get(
        "projects/{project}/aggregated/targetTcpProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetTcpProxyAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetTcpProxiesSetProxyHeader"] = compute.get(
        "projects/{project}/aggregated/targetTcpProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetTcpProxyAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetTcpProxiesInsert"] = compute.get(
        "projects/{project}/aggregated/targetTcpProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetTcpProxyAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetTcpProxiesSetBackendService"] = compute.get(
        "projects/{project}/aggregated/targetTcpProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetTcpProxyAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetTcpProxiesAggregatedList"] = compute.get(
        "projects/{project}/aggregated/targetTcpProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetTcpProxyAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["packetMirroringsGet"] = compute.patch(
        "projects/{project}/regions/{region}/packetMirrorings/{packetMirroring}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "packetMirroring": t.string().optional(),
                "region": t.string().optional(),
                "enable": t.string().optional(),
                "filter": t.proxy(renames["PacketMirroringFilterIn"]).optional(),
                "network": t.proxy(renames["PacketMirroringNetworkInfoIn"]).optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "mirroredResources": t.proxy(
                    renames["PacketMirroringMirroredResourceInfoIn"]
                ).optional(),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "priority": t.integer().optional(),
                "collectorIlb": t.proxy(
                    renames["PacketMirroringForwardingRuleInfoIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["packetMirroringsAggregatedList"] = compute.patch(
        "projects/{project}/regions/{region}/packetMirrorings/{packetMirroring}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "packetMirroring": t.string().optional(),
                "region": t.string().optional(),
                "enable": t.string().optional(),
                "filter": t.proxy(renames["PacketMirroringFilterIn"]).optional(),
                "network": t.proxy(renames["PacketMirroringNetworkInfoIn"]).optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "mirroredResources": t.proxy(
                    renames["PacketMirroringMirroredResourceInfoIn"]
                ).optional(),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "priority": t.integer().optional(),
                "collectorIlb": t.proxy(
                    renames["PacketMirroringForwardingRuleInfoIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["packetMirroringsTestIamPermissions"] = compute.patch(
        "projects/{project}/regions/{region}/packetMirrorings/{packetMirroring}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "packetMirroring": t.string().optional(),
                "region": t.string().optional(),
                "enable": t.string().optional(),
                "filter": t.proxy(renames["PacketMirroringFilterIn"]).optional(),
                "network": t.proxy(renames["PacketMirroringNetworkInfoIn"]).optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "mirroredResources": t.proxy(
                    renames["PacketMirroringMirroredResourceInfoIn"]
                ).optional(),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "priority": t.integer().optional(),
                "collectorIlb": t.proxy(
                    renames["PacketMirroringForwardingRuleInfoIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["packetMirroringsDelete"] = compute.patch(
        "projects/{project}/regions/{region}/packetMirrorings/{packetMirroring}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "packetMirroring": t.string().optional(),
                "region": t.string().optional(),
                "enable": t.string().optional(),
                "filter": t.proxy(renames["PacketMirroringFilterIn"]).optional(),
                "network": t.proxy(renames["PacketMirroringNetworkInfoIn"]).optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "mirroredResources": t.proxy(
                    renames["PacketMirroringMirroredResourceInfoIn"]
                ).optional(),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "priority": t.integer().optional(),
                "collectorIlb": t.proxy(
                    renames["PacketMirroringForwardingRuleInfoIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["packetMirroringsList"] = compute.patch(
        "projects/{project}/regions/{region}/packetMirrorings/{packetMirroring}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "packetMirroring": t.string().optional(),
                "region": t.string().optional(),
                "enable": t.string().optional(),
                "filter": t.proxy(renames["PacketMirroringFilterIn"]).optional(),
                "network": t.proxy(renames["PacketMirroringNetworkInfoIn"]).optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "mirroredResources": t.proxy(
                    renames["PacketMirroringMirroredResourceInfoIn"]
                ).optional(),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "priority": t.integer().optional(),
                "collectorIlb": t.proxy(
                    renames["PacketMirroringForwardingRuleInfoIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["packetMirroringsInsert"] = compute.patch(
        "projects/{project}/regions/{region}/packetMirrorings/{packetMirroring}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "packetMirroring": t.string().optional(),
                "region": t.string().optional(),
                "enable": t.string().optional(),
                "filter": t.proxy(renames["PacketMirroringFilterIn"]).optional(),
                "network": t.proxy(renames["PacketMirroringNetworkInfoIn"]).optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "mirroredResources": t.proxy(
                    renames["PacketMirroringMirroredResourceInfoIn"]
                ).optional(),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "priority": t.integer().optional(),
                "collectorIlb": t.proxy(
                    renames["PacketMirroringForwardingRuleInfoIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["packetMirroringsPatch"] = compute.patch(
        "projects/{project}/regions/{region}/packetMirrorings/{packetMirroring}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "packetMirroring": t.string().optional(),
                "region": t.string().optional(),
                "enable": t.string().optional(),
                "filter": t.proxy(renames["PacketMirroringFilterIn"]).optional(),
                "network": t.proxy(renames["PacketMirroringNetworkInfoIn"]).optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "mirroredResources": t.proxy(
                    renames["PacketMirroringMirroredResourceInfoIn"]
                ).optional(),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "priority": t.integer().optional(),
                "collectorIlb": t.proxy(
                    renames["PacketMirroringForwardingRuleInfoIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionCommitmentsUpdate"] = compute.get(
        "projects/{project}/regions/{region}/commitments",
        t.struct(
            {
                "maxResults": t.integer().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["CommitmentListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionCommitmentsGet"] = compute.get(
        "projects/{project}/regions/{region}/commitments",
        t.struct(
            {
                "maxResults": t.integer().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["CommitmentListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionCommitmentsInsert"] = compute.get(
        "projects/{project}/regions/{region}/commitments",
        t.struct(
            {
                "maxResults": t.integer().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["CommitmentListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionCommitmentsAggregatedList"] = compute.get(
        "projects/{project}/regions/{region}/commitments",
        t.struct(
            {
                "maxResults": t.integer().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["CommitmentListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionCommitmentsList"] = compute.get(
        "projects/{project}/regions/{region}/commitments",
        t.struct(
            {
                "maxResults": t.integer().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["CommitmentListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeTypesGet"] = compute.get(
        "projects/{project}/zones/{zone}/nodeTypes",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "zone": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NodeTypeListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeTypesAggregatedList"] = compute.get(
        "projects/{project}/zones/{zone}/nodeTypes",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "zone": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NodeTypeListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeTypesList"] = compute.get(
        "projects/{project}/zones/{zone}/nodeTypes",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "zone": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NodeTypeListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnTunnelsDelete"] = compute.get(
        "projects/{project}/aggregated/vpnTunnels",
        t.struct(
            {
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnTunnelAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnTunnelsList"] = compute.get(
        "projects/{project}/aggregated/vpnTunnels",
        t.struct(
            {
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnTunnelAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnTunnelsGet"] = compute.get(
        "projects/{project}/aggregated/vpnTunnels",
        t.struct(
            {
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnTunnelAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnTunnelsSetLabels"] = compute.get(
        "projects/{project}/aggregated/vpnTunnels",
        t.struct(
            {
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnTunnelAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnTunnelsInsert"] = compute.get(
        "projects/{project}/aggregated/vpnTunnels",
        t.struct(
            {
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnTunnelAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnTunnelsAggregatedList"] = compute.get(
        "projects/{project}/aggregated/vpnTunnels",
        t.struct(
            {
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnTunnelAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["licenseCodesTestIamPermissions"] = compute.get(
        "projects/{project}/global/licenseCodes/{licenseCode}",
        t.struct(
            {
                "project": t.string().optional(),
                "licenseCode": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["LicenseCodeOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["licenseCodesGet"] = compute.get(
        "projects/{project}/global/licenseCodes/{licenseCode}",
        t.struct(
            {
                "project": t.string().optional(),
                "licenseCode": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["LicenseCodeOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSecurityPoliciesList"] = compute.patch(
        "projects/{project}/regions/{region}/securityPolicies/{securityPolicy}",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "securityPolicy": t.string().optional(),
                "adaptiveProtectionConfig": t.proxy(
                    renames["SecurityPolicyAdaptiveProtectionConfigIn"]
                ),
                "recaptchaOptionsConfig": t.proxy(
                    renames["SecurityPolicyRecaptchaOptionsConfigIn"]
                ),
                "id": t.string().optional(),
                "type": t.string().optional(),
                "description": t.string().optional(),
                "advancedOptionsConfig": t.proxy(
                    renames["SecurityPolicyAdvancedOptionsConfigIn"]
                ),
                "labelFingerprint": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "fingerprint": t.string().optional(),
                "name": t.string().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "ddosProtectionConfig": t.proxy(
                    renames["SecurityPolicyDdosProtectionConfigIn"]
                ),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "rules": t.array(t.proxy(renames["SecurityPolicyRuleIn"])).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSecurityPoliciesDelete"] = compute.patch(
        "projects/{project}/regions/{region}/securityPolicies/{securityPolicy}",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "securityPolicy": t.string().optional(),
                "adaptiveProtectionConfig": t.proxy(
                    renames["SecurityPolicyAdaptiveProtectionConfigIn"]
                ),
                "recaptchaOptionsConfig": t.proxy(
                    renames["SecurityPolicyRecaptchaOptionsConfigIn"]
                ),
                "id": t.string().optional(),
                "type": t.string().optional(),
                "description": t.string().optional(),
                "advancedOptionsConfig": t.proxy(
                    renames["SecurityPolicyAdvancedOptionsConfigIn"]
                ),
                "labelFingerprint": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "fingerprint": t.string().optional(),
                "name": t.string().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "ddosProtectionConfig": t.proxy(
                    renames["SecurityPolicyDdosProtectionConfigIn"]
                ),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "rules": t.array(t.proxy(renames["SecurityPolicyRuleIn"])).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSecurityPoliciesInsert"] = compute.patch(
        "projects/{project}/regions/{region}/securityPolicies/{securityPolicy}",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "securityPolicy": t.string().optional(),
                "adaptiveProtectionConfig": t.proxy(
                    renames["SecurityPolicyAdaptiveProtectionConfigIn"]
                ),
                "recaptchaOptionsConfig": t.proxy(
                    renames["SecurityPolicyRecaptchaOptionsConfigIn"]
                ),
                "id": t.string().optional(),
                "type": t.string().optional(),
                "description": t.string().optional(),
                "advancedOptionsConfig": t.proxy(
                    renames["SecurityPolicyAdvancedOptionsConfigIn"]
                ),
                "labelFingerprint": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "fingerprint": t.string().optional(),
                "name": t.string().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "ddosProtectionConfig": t.proxy(
                    renames["SecurityPolicyDdosProtectionConfigIn"]
                ),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "rules": t.array(t.proxy(renames["SecurityPolicyRuleIn"])).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSecurityPoliciesGet"] = compute.patch(
        "projects/{project}/regions/{region}/securityPolicies/{securityPolicy}",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "securityPolicy": t.string().optional(),
                "adaptiveProtectionConfig": t.proxy(
                    renames["SecurityPolicyAdaptiveProtectionConfigIn"]
                ),
                "recaptchaOptionsConfig": t.proxy(
                    renames["SecurityPolicyRecaptchaOptionsConfigIn"]
                ),
                "id": t.string().optional(),
                "type": t.string().optional(),
                "description": t.string().optional(),
                "advancedOptionsConfig": t.proxy(
                    renames["SecurityPolicyAdvancedOptionsConfigIn"]
                ),
                "labelFingerprint": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "fingerprint": t.string().optional(),
                "name": t.string().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "ddosProtectionConfig": t.proxy(
                    renames["SecurityPolicyDdosProtectionConfigIn"]
                ),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "rules": t.array(t.proxy(renames["SecurityPolicyRuleIn"])).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSecurityPoliciesPatch"] = compute.patch(
        "projects/{project}/regions/{region}/securityPolicies/{securityPolicy}",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "securityPolicy": t.string().optional(),
                "adaptiveProtectionConfig": t.proxy(
                    renames["SecurityPolicyAdaptiveProtectionConfigIn"]
                ),
                "recaptchaOptionsConfig": t.proxy(
                    renames["SecurityPolicyRecaptchaOptionsConfigIn"]
                ),
                "id": t.string().optional(),
                "type": t.string().optional(),
                "description": t.string().optional(),
                "advancedOptionsConfig": t.proxy(
                    renames["SecurityPolicyAdvancedOptionsConfigIn"]
                ),
                "labelFingerprint": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "fingerprint": t.string().optional(),
                "name": t.string().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "ddosProtectionConfig": t.proxy(
                    renames["SecurityPolicyDdosProtectionConfigIn"]
                ),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "rules": t.array(t.proxy(renames["SecurityPolicyRuleIn"])).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["sslPoliciesPatch"] = compute.post(
        "projects/{project}/global/sslPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "warnings": t.array(
                    t.struct(
                        {
                            "message": t.string().optional(),
                            "data": t.array(
                                t.struct(
                                    {
                                        "value": t.string().optional(),
                                        "key": t.string().optional(),
                                    }
                                )
                            ).optional(),
                            "code": t.string().optional(),
                        }
                    )
                ).optional(),
                "profile": t.string().optional(),
                "id": t.string().optional(),
                "kind": t.string().optional(),
                "region": t.string().optional(),
                "customFeatures": t.array(t.string()).optional(),
                "name": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLink": t.string().optional(),
                "enabledFeatures": t.array(t.string()).optional(),
                "minTlsVersion": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["sslPoliciesGet"] = compute.post(
        "projects/{project}/global/sslPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "warnings": t.array(
                    t.struct(
                        {
                            "message": t.string().optional(),
                            "data": t.array(
                                t.struct(
                                    {
                                        "value": t.string().optional(),
                                        "key": t.string().optional(),
                                    }
                                )
                            ).optional(),
                            "code": t.string().optional(),
                        }
                    )
                ).optional(),
                "profile": t.string().optional(),
                "id": t.string().optional(),
                "kind": t.string().optional(),
                "region": t.string().optional(),
                "customFeatures": t.array(t.string()).optional(),
                "name": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLink": t.string().optional(),
                "enabledFeatures": t.array(t.string()).optional(),
                "minTlsVersion": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["sslPoliciesListAvailableFeatures"] = compute.post(
        "projects/{project}/global/sslPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "warnings": t.array(
                    t.struct(
                        {
                            "message": t.string().optional(),
                            "data": t.array(
                                t.struct(
                                    {
                                        "value": t.string().optional(),
                                        "key": t.string().optional(),
                                    }
                                )
                            ).optional(),
                            "code": t.string().optional(),
                        }
                    )
                ).optional(),
                "profile": t.string().optional(),
                "id": t.string().optional(),
                "kind": t.string().optional(),
                "region": t.string().optional(),
                "customFeatures": t.array(t.string()).optional(),
                "name": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLink": t.string().optional(),
                "enabledFeatures": t.array(t.string()).optional(),
                "minTlsVersion": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["sslPoliciesList"] = compute.post(
        "projects/{project}/global/sslPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "warnings": t.array(
                    t.struct(
                        {
                            "message": t.string().optional(),
                            "data": t.array(
                                t.struct(
                                    {
                                        "value": t.string().optional(),
                                        "key": t.string().optional(),
                                    }
                                )
                            ).optional(),
                            "code": t.string().optional(),
                        }
                    )
                ).optional(),
                "profile": t.string().optional(),
                "id": t.string().optional(),
                "kind": t.string().optional(),
                "region": t.string().optional(),
                "customFeatures": t.array(t.string()).optional(),
                "name": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLink": t.string().optional(),
                "enabledFeatures": t.array(t.string()).optional(),
                "minTlsVersion": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["sslPoliciesDelete"] = compute.post(
        "projects/{project}/global/sslPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "warnings": t.array(
                    t.struct(
                        {
                            "message": t.string().optional(),
                            "data": t.array(
                                t.struct(
                                    {
                                        "value": t.string().optional(),
                                        "key": t.string().optional(),
                                    }
                                )
                            ).optional(),
                            "code": t.string().optional(),
                        }
                    )
                ).optional(),
                "profile": t.string().optional(),
                "id": t.string().optional(),
                "kind": t.string().optional(),
                "region": t.string().optional(),
                "customFeatures": t.array(t.string()).optional(),
                "name": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLink": t.string().optional(),
                "enabledFeatures": t.array(t.string()).optional(),
                "minTlsVersion": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["sslPoliciesAggregatedList"] = compute.post(
        "projects/{project}/global/sslPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "warnings": t.array(
                    t.struct(
                        {
                            "message": t.string().optional(),
                            "data": t.array(
                                t.struct(
                                    {
                                        "value": t.string().optional(),
                                        "key": t.string().optional(),
                                    }
                                )
                            ).optional(),
                            "code": t.string().optional(),
                        }
                    )
                ).optional(),
                "profile": t.string().optional(),
                "id": t.string().optional(),
                "kind": t.string().optional(),
                "region": t.string().optional(),
                "customFeatures": t.array(t.string()).optional(),
                "name": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLink": t.string().optional(),
                "enabledFeatures": t.array(t.string()).optional(),
                "minTlsVersion": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["sslPoliciesInsert"] = compute.post(
        "projects/{project}/global/sslPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "warnings": t.array(
                    t.struct(
                        {
                            "message": t.string().optional(),
                            "data": t.array(
                                t.struct(
                                    {
                                        "value": t.string().optional(),
                                        "key": t.string().optional(),
                                    }
                                )
                            ).optional(),
                            "code": t.string().optional(),
                        }
                    )
                ).optional(),
                "profile": t.string().optional(),
                "id": t.string().optional(),
                "kind": t.string().optional(),
                "region": t.string().optional(),
                "customFeatures": t.array(t.string()).optional(),
                "name": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLink": t.string().optional(),
                "enabledFeatures": t.array(t.string()).optional(),
                "minTlsVersion": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["sslCertificatesDelete"] = compute.get(
        "projects/{project}/global/sslCertificates/{sslCertificate}",
        t.struct(
            {
                "sslCertificate": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslCertificateOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["sslCertificatesList"] = compute.get(
        "projects/{project}/global/sslCertificates/{sslCertificate}",
        t.struct(
            {
                "sslCertificate": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslCertificateOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["sslCertificatesInsert"] = compute.get(
        "projects/{project}/global/sslCertificates/{sslCertificate}",
        t.struct(
            {
                "sslCertificate": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslCertificateOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["sslCertificatesAggregatedList"] = compute.get(
        "projects/{project}/global/sslCertificates/{sslCertificate}",
        t.struct(
            {
                "sslCertificate": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslCertificateOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["sslCertificatesGet"] = compute.get(
        "projects/{project}/global/sslCertificates/{sslCertificate}",
        t.struct(
            {
                "sslCertificate": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslCertificateOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnGatewaysInsert"] = compute.get(
        "projects/{project}/regions/{region}/vpnGateways",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnGatewayListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnGatewaysDelete"] = compute.get(
        "projects/{project}/regions/{region}/vpnGateways",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnGatewayListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnGatewaysSetLabels"] = compute.get(
        "projects/{project}/regions/{region}/vpnGateways",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnGatewayListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnGatewaysGet"] = compute.get(
        "projects/{project}/regions/{region}/vpnGateways",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnGatewayListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnGatewaysAggregatedList"] = compute.get(
        "projects/{project}/regions/{region}/vpnGateways",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnGatewayListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnGatewaysGetStatus"] = compute.get(
        "projects/{project}/regions/{region}/vpnGateways",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnGatewayListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnGatewaysTestIamPermissions"] = compute.get(
        "projects/{project}/regions/{region}/vpnGateways",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnGatewayListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["vpnGatewaysList"] = compute.get(
        "projects/{project}/regions/{region}/vpnGateways",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["VpnGatewayListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesAddAssociation"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesGetAssociation"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesAddRule"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesRemoveRule"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesGet"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesDelete"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesPatch"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesGetIamPolicy"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesRemoveAssociation"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesSetIamPolicy"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesTestIamPermissions"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesInsert"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesPatchRule"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesList"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesCloneRules"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkFirewallPoliciesGetRule"] = compute.get(
        "projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["FirewallPolicyRuleOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetVpnGatewaysDelete"] = compute.post(
        "projects/{project}/regions/{region}/targetVpnGateways/{resource}/setLabels",
        t.struct(
            {
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "resource": t.string().optional(),
                "project": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetVpnGatewaysAggregatedList"] = compute.post(
        "projects/{project}/regions/{region}/targetVpnGateways/{resource}/setLabels",
        t.struct(
            {
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "resource": t.string().optional(),
                "project": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetVpnGatewaysList"] = compute.post(
        "projects/{project}/regions/{region}/targetVpnGateways/{resource}/setLabels",
        t.struct(
            {
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "resource": t.string().optional(),
                "project": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetVpnGatewaysGet"] = compute.post(
        "projects/{project}/regions/{region}/targetVpnGateways/{resource}/setLabels",
        t.struct(
            {
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "resource": t.string().optional(),
                "project": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetVpnGatewaysInsert"] = compute.post(
        "projects/{project}/regions/{region}/targetVpnGateways/{resource}/setLabels",
        t.struct(
            {
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "resource": t.string().optional(),
                "project": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetVpnGatewaysSetLabels"] = compute.post(
        "projects/{project}/regions/{region}/targetVpnGateways/{resource}/setLabels",
        t.struct(
            {
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "resource": t.string().optional(),
                "project": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallsList"] = compute.post(
        "projects/{project}/global/firewalls",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "sourceServiceAccounts": t.array(t.string()).optional(),
                "kind": t.string().optional(),
                "direction": t.string().optional(),
                "disabled": t.boolean().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "denied": t.array(
                    t.struct(
                        {
                            "IPProtocol": t.string().optional(),
                            "ports": t.array(t.string()).optional(),
                        }
                    )
                ).optional(),
                "allowed": t.array(
                    t.struct(
                        {
                            "IPProtocol": t.string().optional(),
                            "ports": t.array(t.string()).optional(),
                        }
                    )
                ).optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "description": t.string().optional(),
                "priority": t.integer().optional(),
                "creationTimestamp": t.string().optional(),
                "targetTags": t.array(t.string()).optional(),
                "logConfig": t.proxy(renames["FirewallLogConfigIn"]).optional(),
                "destinationRanges": t.array(t.string()).optional(),
                "name": t.string().optional(),
                "sourceRanges": t.array(t.string()).optional(),
                "network": t.string().optional(),
                "sourceTags": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallsGet"] = compute.post(
        "projects/{project}/global/firewalls",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "sourceServiceAccounts": t.array(t.string()).optional(),
                "kind": t.string().optional(),
                "direction": t.string().optional(),
                "disabled": t.boolean().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "denied": t.array(
                    t.struct(
                        {
                            "IPProtocol": t.string().optional(),
                            "ports": t.array(t.string()).optional(),
                        }
                    )
                ).optional(),
                "allowed": t.array(
                    t.struct(
                        {
                            "IPProtocol": t.string().optional(),
                            "ports": t.array(t.string()).optional(),
                        }
                    )
                ).optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "description": t.string().optional(),
                "priority": t.integer().optional(),
                "creationTimestamp": t.string().optional(),
                "targetTags": t.array(t.string()).optional(),
                "logConfig": t.proxy(renames["FirewallLogConfigIn"]).optional(),
                "destinationRanges": t.array(t.string()).optional(),
                "name": t.string().optional(),
                "sourceRanges": t.array(t.string()).optional(),
                "network": t.string().optional(),
                "sourceTags": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallsDelete"] = compute.post(
        "projects/{project}/global/firewalls",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "sourceServiceAccounts": t.array(t.string()).optional(),
                "kind": t.string().optional(),
                "direction": t.string().optional(),
                "disabled": t.boolean().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "denied": t.array(
                    t.struct(
                        {
                            "IPProtocol": t.string().optional(),
                            "ports": t.array(t.string()).optional(),
                        }
                    )
                ).optional(),
                "allowed": t.array(
                    t.struct(
                        {
                            "IPProtocol": t.string().optional(),
                            "ports": t.array(t.string()).optional(),
                        }
                    )
                ).optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "description": t.string().optional(),
                "priority": t.integer().optional(),
                "creationTimestamp": t.string().optional(),
                "targetTags": t.array(t.string()).optional(),
                "logConfig": t.proxy(renames["FirewallLogConfigIn"]).optional(),
                "destinationRanges": t.array(t.string()).optional(),
                "name": t.string().optional(),
                "sourceRanges": t.array(t.string()).optional(),
                "network": t.string().optional(),
                "sourceTags": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallsUpdate"] = compute.post(
        "projects/{project}/global/firewalls",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "sourceServiceAccounts": t.array(t.string()).optional(),
                "kind": t.string().optional(),
                "direction": t.string().optional(),
                "disabled": t.boolean().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "denied": t.array(
                    t.struct(
                        {
                            "IPProtocol": t.string().optional(),
                            "ports": t.array(t.string()).optional(),
                        }
                    )
                ).optional(),
                "allowed": t.array(
                    t.struct(
                        {
                            "IPProtocol": t.string().optional(),
                            "ports": t.array(t.string()).optional(),
                        }
                    )
                ).optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "description": t.string().optional(),
                "priority": t.integer().optional(),
                "creationTimestamp": t.string().optional(),
                "targetTags": t.array(t.string()).optional(),
                "logConfig": t.proxy(renames["FirewallLogConfigIn"]).optional(),
                "destinationRanges": t.array(t.string()).optional(),
                "name": t.string().optional(),
                "sourceRanges": t.array(t.string()).optional(),
                "network": t.string().optional(),
                "sourceTags": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallsPatch"] = compute.post(
        "projects/{project}/global/firewalls",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "sourceServiceAccounts": t.array(t.string()).optional(),
                "kind": t.string().optional(),
                "direction": t.string().optional(),
                "disabled": t.boolean().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "denied": t.array(
                    t.struct(
                        {
                            "IPProtocol": t.string().optional(),
                            "ports": t.array(t.string()).optional(),
                        }
                    )
                ).optional(),
                "allowed": t.array(
                    t.struct(
                        {
                            "IPProtocol": t.string().optional(),
                            "ports": t.array(t.string()).optional(),
                        }
                    )
                ).optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "description": t.string().optional(),
                "priority": t.integer().optional(),
                "creationTimestamp": t.string().optional(),
                "targetTags": t.array(t.string()).optional(),
                "logConfig": t.proxy(renames["FirewallLogConfigIn"]).optional(),
                "destinationRanges": t.array(t.string()).optional(),
                "name": t.string().optional(),
                "sourceRanges": t.array(t.string()).optional(),
                "network": t.string().optional(),
                "sourceTags": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallsInsert"] = compute.post(
        "projects/{project}/global/firewalls",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "sourceServiceAccounts": t.array(t.string()).optional(),
                "kind": t.string().optional(),
                "direction": t.string().optional(),
                "disabled": t.boolean().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "denied": t.array(
                    t.struct(
                        {
                            "IPProtocol": t.string().optional(),
                            "ports": t.array(t.string()).optional(),
                        }
                    )
                ).optional(),
                "allowed": t.array(
                    t.struct(
                        {
                            "IPProtocol": t.string().optional(),
                            "ports": t.array(t.string()).optional(),
                        }
                    )
                ).optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "description": t.string().optional(),
                "priority": t.integer().optional(),
                "creationTimestamp": t.string().optional(),
                "targetTags": t.array(t.string()).optional(),
                "logConfig": t.proxy(renames["FirewallLogConfigIn"]).optional(),
                "destinationRanges": t.array(t.string()).optional(),
                "name": t.string().optional(),
                "sourceRanges": t.array(t.string()).optional(),
                "network": t.string().optional(),
                "sourceTags": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionAutoscalersList"] = compute.get(
        "projects/{project}/regions/{region}/autoscalers/{autoscaler}",
        t.struct(
            {
                "region": t.string().optional(),
                "project": t.string().optional(),
                "autoscaler": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AutoscalerOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionAutoscalersPatch"] = compute.get(
        "projects/{project}/regions/{region}/autoscalers/{autoscaler}",
        t.struct(
            {
                "region": t.string().optional(),
                "project": t.string().optional(),
                "autoscaler": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AutoscalerOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionAutoscalersInsert"] = compute.get(
        "projects/{project}/regions/{region}/autoscalers/{autoscaler}",
        t.struct(
            {
                "region": t.string().optional(),
                "project": t.string().optional(),
                "autoscaler": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AutoscalerOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionAutoscalersUpdate"] = compute.get(
        "projects/{project}/regions/{region}/autoscalers/{autoscaler}",
        t.struct(
            {
                "region": t.string().optional(),
                "project": t.string().optional(),
                "autoscaler": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AutoscalerOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionAutoscalersDelete"] = compute.get(
        "projects/{project}/regions/{region}/autoscalers/{autoscaler}",
        t.struct(
            {
                "region": t.string().optional(),
                "project": t.string().optional(),
                "autoscaler": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AutoscalerOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionAutoscalersGet"] = compute.get(
        "projects/{project}/regions/{region}/autoscalers/{autoscaler}",
        t.struct(
            {
                "region": t.string().optional(),
                "project": t.string().optional(),
                "autoscaler": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AutoscalerOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["licensesSetIamPolicy"] = compute.get(
        "projects/{project}/global/licenses",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["LicensesListResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["licensesGet"] = compute.get(
        "projects/{project}/global/licenses",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["LicensesListResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["licensesInsert"] = compute.get(
        "projects/{project}/global/licenses",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["LicensesListResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["licensesGetIamPolicy"] = compute.get(
        "projects/{project}/global/licenses",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["LicensesListResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["licensesTestIamPermissions"] = compute.get(
        "projects/{project}/global/licenses",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["LicensesListResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["licensesDelete"] = compute.get(
        "projects/{project}/global/licenses",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["LicensesListResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["licensesList"] = compute.get(
        "projects/{project}/global/licenses",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["LicensesListResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionHealthCheckServicesPatch"] = compute.get(
        "projects/{project}/regions/{region}/healthCheckServices",
        t.struct(
            {
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HealthCheckServicesListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionHealthCheckServicesInsert"] = compute.get(
        "projects/{project}/regions/{region}/healthCheckServices",
        t.struct(
            {
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HealthCheckServicesListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionHealthCheckServicesGet"] = compute.get(
        "projects/{project}/regions/{region}/healthCheckServices",
        t.struct(
            {
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HealthCheckServicesListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionHealthCheckServicesDelete"] = compute.get(
        "projects/{project}/regions/{region}/healthCheckServices",
        t.struct(
            {
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HealthCheckServicesListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionHealthCheckServicesList"] = compute.get(
        "projects/{project}/regions/{region}/healthCheckServices",
        t.struct(
            {
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HealthCheckServicesListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpProxiesPatch"] = compute.post(
        "projects/{project}/targetHttpProxies/{targetHttpProxy}/setUrlMap",
        t.struct(
            {
                "targetHttpProxy": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpProxiesGet"] = compute.post(
        "projects/{project}/targetHttpProxies/{targetHttpProxy}/setUrlMap",
        t.struct(
            {
                "targetHttpProxy": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpProxiesAggregatedList"] = compute.post(
        "projects/{project}/targetHttpProxies/{targetHttpProxy}/setUrlMap",
        t.struct(
            {
                "targetHttpProxy": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpProxiesList"] = compute.post(
        "projects/{project}/targetHttpProxies/{targetHttpProxy}/setUrlMap",
        t.struct(
            {
                "targetHttpProxy": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpProxiesDelete"] = compute.post(
        "projects/{project}/targetHttpProxies/{targetHttpProxy}/setUrlMap",
        t.struct(
            {
                "targetHttpProxy": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpProxiesInsert"] = compute.post(
        "projects/{project}/targetHttpProxies/{targetHttpProxy}/setUrlMap",
        t.struct(
            {
                "targetHttpProxy": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetHttpProxiesSetUrlMap"] = compute.post(
        "projects/{project}/targetHttpProxies/{targetHttpProxy}/setUrlMap",
        t.struct(
            {
                "targetHttpProxy": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceTemplatesInsert"] = compute.get(
        "projects/{project}/global/instanceTemplates/{resource}/getIamPolicy",
        t.struct(
            {
                "project": t.string().optional(),
                "optionsRequestedPolicyVersion": t.integer().optional(),
                "resource": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PolicyOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceTemplatesGet"] = compute.get(
        "projects/{project}/global/instanceTemplates/{resource}/getIamPolicy",
        t.struct(
            {
                "project": t.string().optional(),
                "optionsRequestedPolicyVersion": t.integer().optional(),
                "resource": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PolicyOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceTemplatesList"] = compute.get(
        "projects/{project}/global/instanceTemplates/{resource}/getIamPolicy",
        t.struct(
            {
                "project": t.string().optional(),
                "optionsRequestedPolicyVersion": t.integer().optional(),
                "resource": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PolicyOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceTemplatesSetIamPolicy"] = compute.get(
        "projects/{project}/global/instanceTemplates/{resource}/getIamPolicy",
        t.struct(
            {
                "project": t.string().optional(),
                "optionsRequestedPolicyVersion": t.integer().optional(),
                "resource": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PolicyOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceTemplatesDelete"] = compute.get(
        "projects/{project}/global/instanceTemplates/{resource}/getIamPolicy",
        t.struct(
            {
                "project": t.string().optional(),
                "optionsRequestedPolicyVersion": t.integer().optional(),
                "resource": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PolicyOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceTemplatesTestIamPermissions"] = compute.get(
        "projects/{project}/global/instanceTemplates/{resource}/getIamPolicy",
        t.struct(
            {
                "project": t.string().optional(),
                "optionsRequestedPolicyVersion": t.integer().optional(),
                "resource": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PolicyOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceTemplatesAggregatedList"] = compute.get(
        "projects/{project}/global/instanceTemplates/{resource}/getIamPolicy",
        t.struct(
            {
                "project": t.string().optional(),
                "optionsRequestedPolicyVersion": t.integer().optional(),
                "resource": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PolicyOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceTemplatesGetIamPolicy"] = compute.get(
        "projects/{project}/global/instanceTemplates/{resource}/getIamPolicy",
        t.struct(
            {
                "project": t.string().optional(),
                "optionsRequestedPolicyVersion": t.integer().optional(),
                "resource": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PolicyOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeTemplatesDelete"] = compute.post(
        "projects/{project}/regions/{region}/nodeTemplates/{resource}/testIamPermissions",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "resource": t.string().optional(),
                "permissions": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TestPermissionsResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeTemplatesList"] = compute.post(
        "projects/{project}/regions/{region}/nodeTemplates/{resource}/testIamPermissions",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "resource": t.string().optional(),
                "permissions": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TestPermissionsResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeTemplatesGet"] = compute.post(
        "projects/{project}/regions/{region}/nodeTemplates/{resource}/testIamPermissions",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "resource": t.string().optional(),
                "permissions": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TestPermissionsResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeTemplatesSetIamPolicy"] = compute.post(
        "projects/{project}/regions/{region}/nodeTemplates/{resource}/testIamPermissions",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "resource": t.string().optional(),
                "permissions": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TestPermissionsResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeTemplatesInsert"] = compute.post(
        "projects/{project}/regions/{region}/nodeTemplates/{resource}/testIamPermissions",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "resource": t.string().optional(),
                "permissions": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TestPermissionsResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeTemplatesGetIamPolicy"] = compute.post(
        "projects/{project}/regions/{region}/nodeTemplates/{resource}/testIamPermissions",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "resource": t.string().optional(),
                "permissions": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TestPermissionsResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeTemplatesAggregatedList"] = compute.post(
        "projects/{project}/regions/{region}/nodeTemplates/{resource}/testIamPermissions",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "resource": t.string().optional(),
                "permissions": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TestPermissionsResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeTemplatesTestIamPermissions"] = compute.post(
        "projects/{project}/regions/{region}/nodeTemplates/{resource}/testIamPermissions",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "resource": t.string().optional(),
                "permissions": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TestPermissionsResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkEndpointGroupsList"] = compute.get(
        "projects/{project}/regions/{region}/networkEndpointGroups/{networkEndpointGroup}",
        t.struct(
            {
                "project": t.string().optional(),
                "networkEndpointGroup": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEndpointGroupOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkEndpointGroupsInsert"] = compute.get(
        "projects/{project}/regions/{region}/networkEndpointGroups/{networkEndpointGroup}",
        t.struct(
            {
                "project": t.string().optional(),
                "networkEndpointGroup": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEndpointGroupOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkEndpointGroupsDelete"] = compute.get(
        "projects/{project}/regions/{region}/networkEndpointGroups/{networkEndpointGroup}",
        t.struct(
            {
                "project": t.string().optional(),
                "networkEndpointGroup": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEndpointGroupOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkEndpointGroupsGet"] = compute.get(
        "projects/{project}/regions/{region}/networkEndpointGroups/{networkEndpointGroup}",
        t.struct(
            {
                "project": t.string().optional(),
                "networkEndpointGroup": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEndpointGroupOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["serviceAttachmentsGet"] = compute.delete(
        "projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}",
        t.struct(
            {
                "serviceAttachment": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["serviceAttachmentsInsert"] = compute.delete(
        "projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}",
        t.struct(
            {
                "serviceAttachment": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["serviceAttachmentsPatch"] = compute.delete(
        "projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}",
        t.struct(
            {
                "serviceAttachment": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["serviceAttachmentsList"] = compute.delete(
        "projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}",
        t.struct(
            {
                "serviceAttachment": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["serviceAttachmentsAggregatedList"] = compute.delete(
        "projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}",
        t.struct(
            {
                "serviceAttachment": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["serviceAttachmentsTestIamPermissions"] = compute.delete(
        "projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}",
        t.struct(
            {
                "serviceAttachment": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["serviceAttachmentsSetIamPolicy"] = compute.delete(
        "projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}",
        t.struct(
            {
                "serviceAttachment": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["serviceAttachmentsGetIamPolicy"] = compute.delete(
        "projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}",
        t.struct(
            {
                "serviceAttachment": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["serviceAttachmentsDelete"] = compute.delete(
        "projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}",
        t.struct(
            {
                "serviceAttachment": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["healthChecksGet"] = compute.get(
        "projects/{project}/aggregated/healthChecks",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HealthChecksAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["healthChecksDelete"] = compute.get(
        "projects/{project}/aggregated/healthChecks",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HealthChecksAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["healthChecksPatch"] = compute.get(
        "projects/{project}/aggregated/healthChecks",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HealthChecksAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["healthChecksUpdate"] = compute.get(
        "projects/{project}/aggregated/healthChecks",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HealthChecksAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["healthChecksList"] = compute.get(
        "projects/{project}/aggregated/healthChecks",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HealthChecksAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["healthChecksInsert"] = compute.get(
        "projects/{project}/aggregated/healthChecks",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HealthChecksAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["healthChecksAggregatedList"] = compute.get(
        "projects/{project}/aggregated/healthChecks",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HealthChecksAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupsRemoveInstances"] = compute.get(
        "projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}",
        t.struct(
            {
                "instanceGroup": t.string().optional(),
                "project": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InstanceGroupOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupsSetNamedPorts"] = compute.get(
        "projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}",
        t.struct(
            {
                "instanceGroup": t.string().optional(),
                "project": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InstanceGroupOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupsListInstances"] = compute.get(
        "projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}",
        t.struct(
            {
                "instanceGroup": t.string().optional(),
                "project": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InstanceGroupOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupsAddInstances"] = compute.get(
        "projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}",
        t.struct(
            {
                "instanceGroup": t.string().optional(),
                "project": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InstanceGroupOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupsInsert"] = compute.get(
        "projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}",
        t.struct(
            {
                "instanceGroup": t.string().optional(),
                "project": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InstanceGroupOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupsList"] = compute.get(
        "projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}",
        t.struct(
            {
                "instanceGroup": t.string().optional(),
                "project": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InstanceGroupOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupsAggregatedList"] = compute.get(
        "projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}",
        t.struct(
            {
                "instanceGroup": t.string().optional(),
                "project": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InstanceGroupOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupsDelete"] = compute.get(
        "projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}",
        t.struct(
            {
                "instanceGroup": t.string().optional(),
                "project": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InstanceGroupOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupsGet"] = compute.get(
        "projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}",
        t.struct(
            {
                "instanceGroup": t.string().optional(),
                "project": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InstanceGroupOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetHttpsProxiesGet"] = compute.post(
        "projects/{project}/regions/{region}/targetHttpsProxies",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "description": t.string().optional(),
                "id": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "certificateMap": t.string().optional(),
                "fingerprint": t.string().optional(),
                "sslPolicy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "quicOverride": t.string().optional(),
                "name": t.string().optional(),
                "selfLink": t.string().optional(),
                "proxyBind": t.boolean().optional(),
                "kind": t.string().optional(),
                "urlMap": t.string().optional(),
                "serverTlsPolicy": t.string().optional(),
                "authorizationPolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetHttpsProxiesSetSslCertificates"] = compute.post(
        "projects/{project}/regions/{region}/targetHttpsProxies",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "description": t.string().optional(),
                "id": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "certificateMap": t.string().optional(),
                "fingerprint": t.string().optional(),
                "sslPolicy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "quicOverride": t.string().optional(),
                "name": t.string().optional(),
                "selfLink": t.string().optional(),
                "proxyBind": t.boolean().optional(),
                "kind": t.string().optional(),
                "urlMap": t.string().optional(),
                "serverTlsPolicy": t.string().optional(),
                "authorizationPolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetHttpsProxiesDelete"] = compute.post(
        "projects/{project}/regions/{region}/targetHttpsProxies",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "description": t.string().optional(),
                "id": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "certificateMap": t.string().optional(),
                "fingerprint": t.string().optional(),
                "sslPolicy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "quicOverride": t.string().optional(),
                "name": t.string().optional(),
                "selfLink": t.string().optional(),
                "proxyBind": t.boolean().optional(),
                "kind": t.string().optional(),
                "urlMap": t.string().optional(),
                "serverTlsPolicy": t.string().optional(),
                "authorizationPolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetHttpsProxiesList"] = compute.post(
        "projects/{project}/regions/{region}/targetHttpsProxies",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "description": t.string().optional(),
                "id": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "certificateMap": t.string().optional(),
                "fingerprint": t.string().optional(),
                "sslPolicy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "quicOverride": t.string().optional(),
                "name": t.string().optional(),
                "selfLink": t.string().optional(),
                "proxyBind": t.boolean().optional(),
                "kind": t.string().optional(),
                "urlMap": t.string().optional(),
                "serverTlsPolicy": t.string().optional(),
                "authorizationPolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetHttpsProxiesSetUrlMap"] = compute.post(
        "projects/{project}/regions/{region}/targetHttpsProxies",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "description": t.string().optional(),
                "id": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "certificateMap": t.string().optional(),
                "fingerprint": t.string().optional(),
                "sslPolicy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "quicOverride": t.string().optional(),
                "name": t.string().optional(),
                "selfLink": t.string().optional(),
                "proxyBind": t.boolean().optional(),
                "kind": t.string().optional(),
                "urlMap": t.string().optional(),
                "serverTlsPolicy": t.string().optional(),
                "authorizationPolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetHttpsProxiesPatch"] = compute.post(
        "projects/{project}/regions/{region}/targetHttpsProxies",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "description": t.string().optional(),
                "id": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "certificateMap": t.string().optional(),
                "fingerprint": t.string().optional(),
                "sslPolicy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "quicOverride": t.string().optional(),
                "name": t.string().optional(),
                "selfLink": t.string().optional(),
                "proxyBind": t.boolean().optional(),
                "kind": t.string().optional(),
                "urlMap": t.string().optional(),
                "serverTlsPolicy": t.string().optional(),
                "authorizationPolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetHttpsProxiesInsert"] = compute.post(
        "projects/{project}/regions/{region}/targetHttpsProxies",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "description": t.string().optional(),
                "id": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "certificateMap": t.string().optional(),
                "fingerprint": t.string().optional(),
                "sslPolicy": t.string().optional(),
                "sslCertificates": t.array(t.string()).optional(),
                "quicOverride": t.string().optional(),
                "name": t.string().optional(),
                "selfLink": t.string().optional(),
                "proxyBind": t.boolean().optional(),
                "kind": t.string().optional(),
                "urlMap": t.string().optional(),
                "serverTlsPolicy": t.string().optional(),
                "authorizationPolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksTestIamPermissions"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksStartAsyncReplication"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksDelete"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksAggregatedList"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksResize"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksSetIamPolicy"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksGetIamPolicy"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksAddResourcePolicies"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksRemoveResourcePolicies"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksStopAsyncReplication"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksSetLabels"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksCreateSnapshot"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksList"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksBulkInsert"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksStopGroupAsyncReplication"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksGet"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksUpdate"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["disksInsert"] = compute.post(
        "projects/{project}/zones/{zone}/disks",
        t.struct(
            {
                "sourceImage": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "licenses": t.array(t.string()).optional(),
                "creationTimestamp": t.string().optional(),
                "diskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "replicaZones": t.array(t.string()).optional(),
                "id": t.string().optional(),
                "sourceImageId": t.string().optional(),
                "physicalBlockSizeBytes": t.string().optional(),
                "sourceConsistencyGroupPolicyId": t.string().optional(),
                "sourceDisk": t.string().optional(),
                "options": t.string().optional(),
                "asyncSecondaryDisks": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "resourceStatus": t.proxy(renames["DiskResourceStatusIn"]).optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceStorageObject": t.string().optional(),
                "architecture": t.string().optional(),
                "users": t.array(t.string()).optional(),
                "region": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "params": t.proxy(renames["DiskParamsIn"]).optional(),
                "kind": t.string().optional(),
                "provisionedIops": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "type": t.string().optional(),
                "sizeGb": t.string().optional(),
                "resourcePolicies": t.array(t.string()).optional(),
                "sourceDiskId": t.string().optional(),
                "asyncPrimaryDisk": t.proxy(
                    renames["DiskAsyncReplicationIn"]
                ).optional(),
                "sourceSnapshot": t.string().optional(),
                "locationHint": t.string().optional(),
                "name": t.string().optional(),
                "lastDetachTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceConsistencyGroupPolicy": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "lastAttachTimestamp": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "provisionedThroughput": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["zoneOperationsList"] = compute.get(
        "projects/{project}/zones/{zone}/operations/{operation}",
        t.struct(
            {
                "operation": t.string().optional(),
                "project": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["zoneOperationsWait"] = compute.get(
        "projects/{project}/zones/{zone}/operations/{operation}",
        t.struct(
            {
                "operation": t.string().optional(),
                "project": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["zoneOperationsDelete"] = compute.get(
        "projects/{project}/zones/{zone}/operations/{operation}",
        t.struct(
            {
                "operation": t.string().optional(),
                "project": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["zoneOperationsGet"] = compute.get(
        "projects/{project}/zones/{zone}/operations/{operation}",
        t.struct(
            {
                "operation": t.string().optional(),
                "project": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetGrpcProxiesInsert"] = compute.patch(
        "projects/{project}/global/targetGrpcProxies/{targetGrpcProxy}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "targetGrpcProxy": t.string().optional(),
                "project": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "fingerprint": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "validateForProxyless": t.boolean().optional(),
                "name": t.string().optional(),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "urlMap": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetGrpcProxiesGet"] = compute.patch(
        "projects/{project}/global/targetGrpcProxies/{targetGrpcProxy}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "targetGrpcProxy": t.string().optional(),
                "project": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "fingerprint": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "validateForProxyless": t.boolean().optional(),
                "name": t.string().optional(),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "urlMap": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetGrpcProxiesList"] = compute.patch(
        "projects/{project}/global/targetGrpcProxies/{targetGrpcProxy}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "targetGrpcProxy": t.string().optional(),
                "project": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "fingerprint": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "validateForProxyless": t.boolean().optional(),
                "name": t.string().optional(),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "urlMap": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetGrpcProxiesDelete"] = compute.patch(
        "projects/{project}/global/targetGrpcProxies/{targetGrpcProxy}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "targetGrpcProxy": t.string().optional(),
                "project": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "fingerprint": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "validateForProxyless": t.boolean().optional(),
                "name": t.string().optional(),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "urlMap": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetGrpcProxiesPatch"] = compute.patch(
        "projects/{project}/global/targetGrpcProxies/{targetGrpcProxy}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "targetGrpcProxy": t.string().optional(),
                "project": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "fingerprint": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "validateForProxyless": t.boolean().optional(),
                "name": t.string().optional(),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "urlMap": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["acceleratorTypesList"] = compute.get(
        "projects/{project}/aggregated/acceleratorTypes",
        t.struct(
            {
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AcceleratorTypeAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["acceleratorTypesGet"] = compute.get(
        "projects/{project}/aggregated/acceleratorTypes",
        t.struct(
            {
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AcceleratorTypeAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["acceleratorTypesAggregatedList"] = compute.get(
        "projects/{project}/aggregated/acceleratorTypes",
        t.struct(
            {
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AcceleratorTypeAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionBackendServicesSetIamPolicy"] = compute.post(
        "projects/{project}/regions/{region}/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "region": t.string().optional(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionBackendServicesDelete"] = compute.post(
        "projects/{project}/regions/{region}/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "region": t.string().optional(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionBackendServicesGetIamPolicy"] = compute.post(
        "projects/{project}/regions/{region}/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "region": t.string().optional(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionBackendServicesGet"] = compute.post(
        "projects/{project}/regions/{region}/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "region": t.string().optional(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionBackendServicesList"] = compute.post(
        "projects/{project}/regions/{region}/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "region": t.string().optional(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionBackendServicesUpdate"] = compute.post(
        "projects/{project}/regions/{region}/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "region": t.string().optional(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionBackendServicesInsert"] = compute.post(
        "projects/{project}/regions/{region}/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "region": t.string().optional(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionBackendServicesPatch"] = compute.post(
        "projects/{project}/regions/{region}/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "region": t.string().optional(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionBackendServicesGetHealth"] = compute.post(
        "projects/{project}/regions/{region}/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "region": t.string().optional(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionsGet"] = compute.get(
        "projects/{project}/regions",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["RegionListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionsList"] = compute.get(
        "projects/{project}/regions",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["RegionListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["projectsSetCommonInstanceMetadata"] = compute.post(
        "projects/{project}/setDefaultNetworkTier",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "networkTier": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["projectsGetXpnHost"] = compute.post(
        "projects/{project}/setDefaultNetworkTier",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "networkTier": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["projectsDisableXpnHost"] = compute.post(
        "projects/{project}/setDefaultNetworkTier",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "networkTier": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["projectsEnableXpnHost"] = compute.post(
        "projects/{project}/setDefaultNetworkTier",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "networkTier": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["projectsListXpnHosts"] = compute.post(
        "projects/{project}/setDefaultNetworkTier",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "networkTier": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["projectsMoveDisk"] = compute.post(
        "projects/{project}/setDefaultNetworkTier",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "networkTier": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["projectsDisableXpnResource"] = compute.post(
        "projects/{project}/setDefaultNetworkTier",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "networkTier": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["projectsMoveInstance"] = compute.post(
        "projects/{project}/setDefaultNetworkTier",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "networkTier": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["projectsSetUsageExportBucket"] = compute.post(
        "projects/{project}/setDefaultNetworkTier",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "networkTier": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["projectsGet"] = compute.post(
        "projects/{project}/setDefaultNetworkTier",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "networkTier": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["projectsGetXpnResources"] = compute.post(
        "projects/{project}/setDefaultNetworkTier",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "networkTier": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["projectsEnableXpnResource"] = compute.post(
        "projects/{project}/setDefaultNetworkTier",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "networkTier": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["projectsSetDefaultNetworkTier"] = compute.post(
        "projects/{project}/setDefaultNetworkTier",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "networkTier": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesGetRule"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesGetAssociation"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesListAssociations"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesRemoveRule"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesGetIamPolicy"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesCloneRules"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesAddAssociation"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesMove"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesSetIamPolicy"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesInsert"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesDelete"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesRemoveAssociation"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesTestIamPermissions"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesPatch"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesList"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesGet"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesAddRule"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["firewallPoliciesPatchRule"] = compute.post(
        "locations/global/firewallPolicies/{firewallPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "firewallPolicy": t.string().optional(),
                "requestId": t.string().optional(),
                "disabled": t.boolean().optional(),
                "action": t.string().optional(),
                "ruleName": t.string().optional(),
                "targetServiceAccounts": t.array(t.string()).optional(),
                "targetResources": t.array(t.string()).optional(),
                "targetSecureTags": t.array(
                    t.proxy(renames["FirewallPolicyRuleSecureTagIn"])
                ).optional(),
                "ruleTupleCount": t.integer().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "enableLogging": t.boolean().optional(),
                "match": t.proxy(renames["FirewallPolicyRuleMatcherIn"]).optional(),
                "direction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetInstancesGet"] = compute.post(
        "projects/{project}/zones/{zone}/targetInstances",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "kind": t.string().optional(),
                "natPolicy": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "description": t.string().optional(),
                "network": t.string().optional(),
                "instance": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetInstancesList"] = compute.post(
        "projects/{project}/zones/{zone}/targetInstances",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "kind": t.string().optional(),
                "natPolicy": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "description": t.string().optional(),
                "network": t.string().optional(),
                "instance": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetInstancesAggregatedList"] = compute.post(
        "projects/{project}/zones/{zone}/targetInstances",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "kind": t.string().optional(),
                "natPolicy": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "description": t.string().optional(),
                "network": t.string().optional(),
                "instance": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetInstancesDelete"] = compute.post(
        "projects/{project}/zones/{zone}/targetInstances",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "kind": t.string().optional(),
                "natPolicy": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "description": t.string().optional(),
                "network": t.string().optional(),
                "instance": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetInstancesInsert"] = compute.post(
        "projects/{project}/zones/{zone}/targetInstances",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "kind": t.string().optional(),
                "natPolicy": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "description": t.string().optional(),
                "network": t.string().optional(),
                "instance": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionOperationsDelete"] = compute.get(
        "projects/{project}/regions/{region}/operations",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "region": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionOperationsGet"] = compute.get(
        "projects/{project}/regions/{region}/operations",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "region": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionOperationsWait"] = compute.get(
        "projects/{project}/regions/{region}/operations",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "region": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionOperationsList"] = compute.get(
        "projects/{project}/regions/{region}/operations",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "region": t.string().optional(),
                "filter": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetTcpProxiesInsert"] = compute.delete(
        "projects/{project}/regions/{region}/targetTcpProxies/{targetTcpProxy}",
        t.struct(
            {
                "project": t.string().optional(),
                "targetTcpProxy": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetTcpProxiesGet"] = compute.delete(
        "projects/{project}/regions/{region}/targetTcpProxies/{targetTcpProxy}",
        t.struct(
            {
                "project": t.string().optional(),
                "targetTcpProxy": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetTcpProxiesList"] = compute.delete(
        "projects/{project}/regions/{region}/targetTcpProxies/{targetTcpProxy}",
        t.struct(
            {
                "project": t.string().optional(),
                "targetTcpProxy": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetTcpProxiesDelete"] = compute.delete(
        "projects/{project}/regions/{region}/targetTcpProxies/{targetTcpProxy}",
        t.struct(
            {
                "project": t.string().optional(),
                "targetTcpProxy": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesList"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesUpdate"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesDetachDisk"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesInsert"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesDeleteAccessConfig"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesUpdateShieldedInstanceConfig"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesRemoveResourcePolicies"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSendDiagnosticInterrupt"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesGetScreenshot"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSetTags"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesUpdateNetworkInterface"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesDelete"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesBulkInsert"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSetShieldedInstanceIntegrityPolicy"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesUpdateDisplayDevice"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSetMachineResources"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesGetIamPolicy"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesReset"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSetMachineType"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesGetShieldedInstanceIdentity"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesGetGuestAttributes"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesAddAccessConfig"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesStart"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSuspend"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesGet"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesAggregatedList"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSetMinCpuPlatform"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSetDiskAutoDelete"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesTestIamPermissions"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSetLabels"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesStop"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSimulateMaintenanceEvent"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSetIamPolicy"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesGetSerialPortOutput"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSetScheduling"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSetMetadata"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesAttachDisk"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesListReferrers"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesUpdateAccessConfig"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSetName"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesAddResourcePolicies"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesGetEffectiveFirewalls"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSetServiceAccount"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesResume"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesSetDeletionProtection"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instancesStartWithEncryptionKey"] = compute.post(
        "projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey",
        t.struct(
            {
                "zone": t.string().optional(),
                "requestId": t.string().optional(),
                "instance": t.string().optional(),
                "project": t.string().optional(),
                "disks": t.array(
                    t.proxy(renames["CustomerEncryptionKeyProtectedDiskIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsDeleteNodes"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsGetIamPolicy"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsDelete"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsAddNodes"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsSetIamPolicy"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsTestIamPermissions"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsSimulateMaintenanceEvent"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsInsert"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsListNodes"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsGet"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsList"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsAggregatedList"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsSetNodeTemplate"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["nodeGroupsPatch"] = compute.patch(
        "projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}",
        t.struct(
            {
                "nodeGroup": t.string().optional(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "autoscalingPolicy": t.proxy(
                    renames["NodeGroupAutoscalingPolicyIn"]
                ).optional(),
                "status": t.string(),
                "fingerprint": t.string(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "locationHint": t.string().optional(),
                "maintenancePolicy": t.string().optional(),
                "description": t.string().optional(),
                "maintenanceWindow": t.proxy(renames["NodeGroupMaintenanceWindowIn"]),
                "nodeTemplate": t.string().optional(),
                "size": t.integer().optional(),
                "selfLink": t.string().optional(),
                "kind": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routersPreview"] = compute.delete(
        "projects/{project}/regions/{region}/routers/{router}",
        t.struct(
            {
                "project": t.string().optional(),
                "router": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routersGet"] = compute.delete(
        "projects/{project}/regions/{region}/routers/{router}",
        t.struct(
            {
                "project": t.string().optional(),
                "router": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routersGetRouterStatus"] = compute.delete(
        "projects/{project}/regions/{region}/routers/{router}",
        t.struct(
            {
                "project": t.string().optional(),
                "router": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routersPatch"] = compute.delete(
        "projects/{project}/regions/{region}/routers/{router}",
        t.struct(
            {
                "project": t.string().optional(),
                "router": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routersUpdate"] = compute.delete(
        "projects/{project}/regions/{region}/routers/{router}",
        t.struct(
            {
                "project": t.string().optional(),
                "router": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routersList"] = compute.delete(
        "projects/{project}/regions/{region}/routers/{router}",
        t.struct(
            {
                "project": t.string().optional(),
                "router": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routersInsert"] = compute.delete(
        "projects/{project}/regions/{region}/routers/{router}",
        t.struct(
            {
                "project": t.string().optional(),
                "router": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routersGetNatMappingInfo"] = compute.delete(
        "projects/{project}/regions/{region}/routers/{router}",
        t.struct(
            {
                "project": t.string().optional(),
                "router": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routersAggregatedList"] = compute.delete(
        "projects/{project}/regions/{region}/routers/{router}",
        t.struct(
            {
                "project": t.string().optional(),
                "router": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routersDelete"] = compute.delete(
        "projects/{project}/regions/{region}/routers/{router}",
        t.struct(
            {
                "project": t.string().optional(),
                "router": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["forwardingRulesGet"] = compute.get(
        "projects/{project}/regions/{region}/forwardingRules",
        t.struct(
            {
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ForwardingRuleListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["forwardingRulesPatch"] = compute.get(
        "projects/{project}/regions/{region}/forwardingRules",
        t.struct(
            {
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ForwardingRuleListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["forwardingRulesInsert"] = compute.get(
        "projects/{project}/regions/{region}/forwardingRules",
        t.struct(
            {
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ForwardingRuleListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["forwardingRulesSetLabels"] = compute.get(
        "projects/{project}/regions/{region}/forwardingRules",
        t.struct(
            {
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ForwardingRuleListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["forwardingRulesDelete"] = compute.get(
        "projects/{project}/regions/{region}/forwardingRules",
        t.struct(
            {
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ForwardingRuleListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["forwardingRulesSetTarget"] = compute.get(
        "projects/{project}/regions/{region}/forwardingRules",
        t.struct(
            {
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ForwardingRuleListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["forwardingRulesAggregatedList"] = compute.get(
        "projects/{project}/regions/{region}/forwardingRules",
        t.struct(
            {
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ForwardingRuleListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["forwardingRulesList"] = compute.get(
        "projects/{project}/regions/{region}/forwardingRules",
        t.struct(
            {
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ForwardingRuleListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstancesBulkInsert"] = compute.post(
        "projects/{project}/regions/{region}/instances/bulkInsert",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "perInstanceProperties": t.struct(
                    {"_": t.string().optional()}
                ).optional(),
                "namePattern": t.string().optional(),
                "count": t.string().optional(),
                "instanceProperties": t.proxy(
                    renames["InstancePropertiesIn"]
                ).optional(),
                "locationPolicy": t.proxy(renames["LocationPolicyIn"]).optional(),
                "sourceInstanceTemplate": t.string().optional(),
                "minCount": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetSslProxiesDelete"] = compute.get(
        "projects/{project}/global/targetSslProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetSslProxyListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetSslProxiesSetSslPolicy"] = compute.get(
        "projects/{project}/global/targetSslProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetSslProxyListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetSslProxiesSetSslCertificates"] = compute.get(
        "projects/{project}/global/targetSslProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetSslProxyListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetSslProxiesGet"] = compute.get(
        "projects/{project}/global/targetSslProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetSslProxyListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetSslProxiesSetCertificateMap"] = compute.get(
        "projects/{project}/global/targetSslProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetSslProxyListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetSslProxiesSetProxyHeader"] = compute.get(
        "projects/{project}/global/targetSslProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetSslProxyListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetSslProxiesSetBackendService"] = compute.get(
        "projects/{project}/global/targetSslProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetSslProxyListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetSslProxiesInsert"] = compute.get(
        "projects/{project}/global/targetSslProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetSslProxyListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetSslProxiesList"] = compute.get(
        "projects/{project}/global/targetSslProxies",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetSslProxyListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetHttpProxiesDelete"] = compute.post(
        "projects/{project}/regions/{region}/targetHttpProxies",
        t.struct(
            {
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "fingerprint": t.string().optional(),
                "urlMap": t.string().optional(),
                "description": t.string().optional(),
                "proxyBind": t.boolean().optional(),
                "creationTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "kind": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetHttpProxiesList"] = compute.post(
        "projects/{project}/regions/{region}/targetHttpProxies",
        t.struct(
            {
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "fingerprint": t.string().optional(),
                "urlMap": t.string().optional(),
                "description": t.string().optional(),
                "proxyBind": t.boolean().optional(),
                "creationTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "kind": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetHttpProxiesGet"] = compute.post(
        "projects/{project}/regions/{region}/targetHttpProxies",
        t.struct(
            {
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "fingerprint": t.string().optional(),
                "urlMap": t.string().optional(),
                "description": t.string().optional(),
                "proxyBind": t.boolean().optional(),
                "creationTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "kind": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetHttpProxiesSetUrlMap"] = compute.post(
        "projects/{project}/regions/{region}/targetHttpProxies",
        t.struct(
            {
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "fingerprint": t.string().optional(),
                "urlMap": t.string().optional(),
                "description": t.string().optional(),
                "proxyBind": t.boolean().optional(),
                "creationTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "kind": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionTargetHttpProxiesInsert"] = compute.post(
        "projects/{project}/regions/{region}/targetHttpProxies",
        t.struct(
            {
                "region": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "fingerprint": t.string().optional(),
                "urlMap": t.string().optional(),
                "description": t.string().optional(),
                "proxyBind": t.boolean().optional(),
                "creationTimestamp": t.string().optional(),
                "selfLink": t.string().optional(),
                "id": t.string().optional(),
                "name": t.string().optional(),
                "kind": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalNetworkEndpointGroupsDetachNetworkEndpoints"] = compute.post(
        "projects/{project}/global/networkEndpointGroups",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "description": t.string().optional(),
                "annotations": t.struct({"_": t.string().optional()}).optional(),
                "network": t.string().optional(),
                "kind": t.string().optional(),
                "appEngine": t.proxy(
                    renames["NetworkEndpointGroupAppEngineIn"]
                ).optional(),
                "name": t.string().optional(),
                "defaultPort": t.integer().optional(),
                "selfLink": t.string().optional(),
                "networkEndpointType": t.string().optional(),
                "size": t.integer().optional(),
                "creationTimestamp": t.string().optional(),
                "cloudRun": t.proxy(
                    renames["NetworkEndpointGroupCloudRunIn"]
                ).optional(),
                "subnetwork": t.string().optional(),
                "pscData": t.proxy(renames["NetworkEndpointGroupPscDataIn"]),
                "pscTargetService": t.string().optional(),
                "region": t.string().optional(),
                "cloudFunction": t.proxy(
                    renames["NetworkEndpointGroupCloudFunctionIn"]
                ).optional(),
                "id": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalNetworkEndpointGroupsAttachNetworkEndpoints"] = compute.post(
        "projects/{project}/global/networkEndpointGroups",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "description": t.string().optional(),
                "annotations": t.struct({"_": t.string().optional()}).optional(),
                "network": t.string().optional(),
                "kind": t.string().optional(),
                "appEngine": t.proxy(
                    renames["NetworkEndpointGroupAppEngineIn"]
                ).optional(),
                "name": t.string().optional(),
                "defaultPort": t.integer().optional(),
                "selfLink": t.string().optional(),
                "networkEndpointType": t.string().optional(),
                "size": t.integer().optional(),
                "creationTimestamp": t.string().optional(),
                "cloudRun": t.proxy(
                    renames["NetworkEndpointGroupCloudRunIn"]
                ).optional(),
                "subnetwork": t.string().optional(),
                "pscData": t.proxy(renames["NetworkEndpointGroupPscDataIn"]),
                "pscTargetService": t.string().optional(),
                "region": t.string().optional(),
                "cloudFunction": t.proxy(
                    renames["NetworkEndpointGroupCloudFunctionIn"]
                ).optional(),
                "id": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalNetworkEndpointGroupsList"] = compute.post(
        "projects/{project}/global/networkEndpointGroups",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "description": t.string().optional(),
                "annotations": t.struct({"_": t.string().optional()}).optional(),
                "network": t.string().optional(),
                "kind": t.string().optional(),
                "appEngine": t.proxy(
                    renames["NetworkEndpointGroupAppEngineIn"]
                ).optional(),
                "name": t.string().optional(),
                "defaultPort": t.integer().optional(),
                "selfLink": t.string().optional(),
                "networkEndpointType": t.string().optional(),
                "size": t.integer().optional(),
                "creationTimestamp": t.string().optional(),
                "cloudRun": t.proxy(
                    renames["NetworkEndpointGroupCloudRunIn"]
                ).optional(),
                "subnetwork": t.string().optional(),
                "pscData": t.proxy(renames["NetworkEndpointGroupPscDataIn"]),
                "pscTargetService": t.string().optional(),
                "region": t.string().optional(),
                "cloudFunction": t.proxy(
                    renames["NetworkEndpointGroupCloudFunctionIn"]
                ).optional(),
                "id": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalNetworkEndpointGroupsGet"] = compute.post(
        "projects/{project}/global/networkEndpointGroups",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "description": t.string().optional(),
                "annotations": t.struct({"_": t.string().optional()}).optional(),
                "network": t.string().optional(),
                "kind": t.string().optional(),
                "appEngine": t.proxy(
                    renames["NetworkEndpointGroupAppEngineIn"]
                ).optional(),
                "name": t.string().optional(),
                "defaultPort": t.integer().optional(),
                "selfLink": t.string().optional(),
                "networkEndpointType": t.string().optional(),
                "size": t.integer().optional(),
                "creationTimestamp": t.string().optional(),
                "cloudRun": t.proxy(
                    renames["NetworkEndpointGroupCloudRunIn"]
                ).optional(),
                "subnetwork": t.string().optional(),
                "pscData": t.proxy(renames["NetworkEndpointGroupPscDataIn"]),
                "pscTargetService": t.string().optional(),
                "region": t.string().optional(),
                "cloudFunction": t.proxy(
                    renames["NetworkEndpointGroupCloudFunctionIn"]
                ).optional(),
                "id": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalNetworkEndpointGroupsDelete"] = compute.post(
        "projects/{project}/global/networkEndpointGroups",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "description": t.string().optional(),
                "annotations": t.struct({"_": t.string().optional()}).optional(),
                "network": t.string().optional(),
                "kind": t.string().optional(),
                "appEngine": t.proxy(
                    renames["NetworkEndpointGroupAppEngineIn"]
                ).optional(),
                "name": t.string().optional(),
                "defaultPort": t.integer().optional(),
                "selfLink": t.string().optional(),
                "networkEndpointType": t.string().optional(),
                "size": t.integer().optional(),
                "creationTimestamp": t.string().optional(),
                "cloudRun": t.proxy(
                    renames["NetworkEndpointGroupCloudRunIn"]
                ).optional(),
                "subnetwork": t.string().optional(),
                "pscData": t.proxy(renames["NetworkEndpointGroupPscDataIn"]),
                "pscTargetService": t.string().optional(),
                "region": t.string().optional(),
                "cloudFunction": t.proxy(
                    renames["NetworkEndpointGroupCloudFunctionIn"]
                ).optional(),
                "id": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalNetworkEndpointGroupsListNetworkEndpoints"] = compute.post(
        "projects/{project}/global/networkEndpointGroups",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "description": t.string().optional(),
                "annotations": t.struct({"_": t.string().optional()}).optional(),
                "network": t.string().optional(),
                "kind": t.string().optional(),
                "appEngine": t.proxy(
                    renames["NetworkEndpointGroupAppEngineIn"]
                ).optional(),
                "name": t.string().optional(),
                "defaultPort": t.integer().optional(),
                "selfLink": t.string().optional(),
                "networkEndpointType": t.string().optional(),
                "size": t.integer().optional(),
                "creationTimestamp": t.string().optional(),
                "cloudRun": t.proxy(
                    renames["NetworkEndpointGroupCloudRunIn"]
                ).optional(),
                "subnetwork": t.string().optional(),
                "pscData": t.proxy(renames["NetworkEndpointGroupPscDataIn"]),
                "pscTargetService": t.string().optional(),
                "region": t.string().optional(),
                "cloudFunction": t.proxy(
                    renames["NetworkEndpointGroupCloudFunctionIn"]
                ).optional(),
                "id": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalNetworkEndpointGroupsInsert"] = compute.post(
        "projects/{project}/global/networkEndpointGroups",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "zone": t.string().optional(),
                "description": t.string().optional(),
                "annotations": t.struct({"_": t.string().optional()}).optional(),
                "network": t.string().optional(),
                "kind": t.string().optional(),
                "appEngine": t.proxy(
                    renames["NetworkEndpointGroupAppEngineIn"]
                ).optional(),
                "name": t.string().optional(),
                "defaultPort": t.integer().optional(),
                "selfLink": t.string().optional(),
                "networkEndpointType": t.string().optional(),
                "size": t.integer().optional(),
                "creationTimestamp": t.string().optional(),
                "cloudRun": t.proxy(
                    renames["NetworkEndpointGroupCloudRunIn"]
                ).optional(),
                "subnetwork": t.string().optional(),
                "pscData": t.proxy(renames["NetworkEndpointGroupPscDataIn"]),
                "pscTargetService": t.string().optional(),
                "region": t.string().optional(),
                "cloudFunction": t.proxy(
                    renames["NetworkEndpointGroupCloudFunctionIn"]
                ).optional(),
                "id": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNotificationEndpointsList"] = compute.get(
        "projects/{project}/regions/{region}/notificationEndpoints/{notificationEndpoint}",
        t.struct(
            {
                "region": t.string().optional(),
                "notificationEndpoint": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NotificationEndpointOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNotificationEndpointsInsert"] = compute.get(
        "projects/{project}/regions/{region}/notificationEndpoints/{notificationEndpoint}",
        t.struct(
            {
                "region": t.string().optional(),
                "notificationEndpoint": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NotificationEndpointOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNotificationEndpointsDelete"] = compute.get(
        "projects/{project}/regions/{region}/notificationEndpoints/{notificationEndpoint}",
        t.struct(
            {
                "region": t.string().optional(),
                "notificationEndpoint": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NotificationEndpointOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNotificationEndpointsGet"] = compute.get(
        "projects/{project}/regions/{region}/notificationEndpoints/{notificationEndpoint}",
        t.struct(
            {
                "region": t.string().optional(),
                "notificationEndpoint": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NotificationEndpointOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["subnetworksDelete"] = compute.get(
        "projects/{project}/regions/{region}/subnetworks/{subnetwork}",
        t.struct(
            {
                "region": t.string().optional(),
                "subnetwork": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SubnetworkOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["subnetworksExpandIpCidrRange"] = compute.get(
        "projects/{project}/regions/{region}/subnetworks/{subnetwork}",
        t.struct(
            {
                "region": t.string().optional(),
                "subnetwork": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SubnetworkOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["subnetworksPatch"] = compute.get(
        "projects/{project}/regions/{region}/subnetworks/{subnetwork}",
        t.struct(
            {
                "region": t.string().optional(),
                "subnetwork": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SubnetworkOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["subnetworksAggregatedList"] = compute.get(
        "projects/{project}/regions/{region}/subnetworks/{subnetwork}",
        t.struct(
            {
                "region": t.string().optional(),
                "subnetwork": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SubnetworkOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["subnetworksInsert"] = compute.get(
        "projects/{project}/regions/{region}/subnetworks/{subnetwork}",
        t.struct(
            {
                "region": t.string().optional(),
                "subnetwork": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SubnetworkOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["subnetworksListUsable"] = compute.get(
        "projects/{project}/regions/{region}/subnetworks/{subnetwork}",
        t.struct(
            {
                "region": t.string().optional(),
                "subnetwork": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SubnetworkOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["subnetworksSetIamPolicy"] = compute.get(
        "projects/{project}/regions/{region}/subnetworks/{subnetwork}",
        t.struct(
            {
                "region": t.string().optional(),
                "subnetwork": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SubnetworkOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["subnetworksSetPrivateIpGoogleAccess"] = compute.get(
        "projects/{project}/regions/{region}/subnetworks/{subnetwork}",
        t.struct(
            {
                "region": t.string().optional(),
                "subnetwork": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SubnetworkOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["subnetworksGetIamPolicy"] = compute.get(
        "projects/{project}/regions/{region}/subnetworks/{subnetwork}",
        t.struct(
            {
                "region": t.string().optional(),
                "subnetwork": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SubnetworkOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["subnetworksTestIamPermissions"] = compute.get(
        "projects/{project}/regions/{region}/subnetworks/{subnetwork}",
        t.struct(
            {
                "region": t.string().optional(),
                "subnetwork": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SubnetworkOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["subnetworksList"] = compute.get(
        "projects/{project}/regions/{region}/subnetworks/{subnetwork}",
        t.struct(
            {
                "region": t.string().optional(),
                "subnetwork": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SubnetworkOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["subnetworksGet"] = compute.get(
        "projects/{project}/regions/{region}/subnetworks/{subnetwork}",
        t.struct(
            {
                "region": t.string().optional(),
                "subnetwork": t.string().optional(),
                "project": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SubnetworkOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDiskTypesList"] = compute.get(
        "projects/{project}/regions/{region}/diskTypes/{diskType}",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "diskType": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["DiskTypeOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDiskTypesGet"] = compute.get(
        "projects/{project}/regions/{region}/diskTypes/{diskType}",
        t.struct(
            {
                "project": t.string().optional(),
                "region": t.string().optional(),
                "diskType": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["DiskTypeOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["snapshotsTestIamPermissions"] = compute.get(
        "projects/{project}/global/snapshots/{snapshot}",
        t.struct(
            {
                "project": t.string().optional(),
                "snapshot": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SnapshotOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["snapshotsInsert"] = compute.get(
        "projects/{project}/global/snapshots/{snapshot}",
        t.struct(
            {
                "project": t.string().optional(),
                "snapshot": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SnapshotOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["snapshotsSetLabels"] = compute.get(
        "projects/{project}/global/snapshots/{snapshot}",
        t.struct(
            {
                "project": t.string().optional(),
                "snapshot": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SnapshotOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["snapshotsGetIamPolicy"] = compute.get(
        "projects/{project}/global/snapshots/{snapshot}",
        t.struct(
            {
                "project": t.string().optional(),
                "snapshot": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SnapshotOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["snapshotsList"] = compute.get(
        "projects/{project}/global/snapshots/{snapshot}",
        t.struct(
            {
                "project": t.string().optional(),
                "snapshot": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SnapshotOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["snapshotsSetIamPolicy"] = compute.get(
        "projects/{project}/global/snapshots/{snapshot}",
        t.struct(
            {
                "project": t.string().optional(),
                "snapshot": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SnapshotOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["snapshotsDelete"] = compute.get(
        "projects/{project}/global/snapshots/{snapshot}",
        t.struct(
            {
                "project": t.string().optional(),
                "snapshot": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SnapshotOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["snapshotsGet"] = compute.get(
        "projects/{project}/global/snapshots/{snapshot}",
        t.struct(
            {
                "project": t.string().optional(),
                "snapshot": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SnapshotOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["zonesGet"] = compute.get(
        "projects/{project}/zones",
        t.struct(
            {
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ZoneListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["zonesList"] = compute.get(
        "projects/{project}/zones",
        t.struct(
            {
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ZoneListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectRemoteLocationsList"] = compute.get(
        "projects/{project}/global/interconnectRemoteLocations/{interconnectRemoteLocation}",
        t.struct(
            {
                "project": t.string().optional(),
                "interconnectRemoteLocation": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InterconnectRemoteLocationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectRemoteLocationsGet"] = compute.get(
        "projects/{project}/global/interconnectRemoteLocations/{interconnectRemoteLocation}",
        t.struct(
            {
                "project": t.string().optional(),
                "interconnectRemoteLocation": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InterconnectRemoteLocationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupsListInstances"] = compute.get(
        "projects/{project}/regions/{region}/instanceGroups",
        t.struct(
            {
                "region": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["RegionInstanceGroupListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupsGet"] = compute.get(
        "projects/{project}/regions/{region}/instanceGroups",
        t.struct(
            {
                "region": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["RegionInstanceGroupListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupsSetNamedPorts"] = compute.get(
        "projects/{project}/regions/{region}/instanceGroups",
        t.struct(
            {
                "region": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["RegionInstanceGroupListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupsList"] = compute.get(
        "projects/{project}/regions/{region}/instanceGroups",
        t.struct(
            {
                "region": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "filter": t.string().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["RegionInstanceGroupListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceTemplatesInsert"] = compute.get(
        "projects/{project}/regions/{region}/instanceTemplates",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InstanceTemplateListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceTemplatesDelete"] = compute.get(
        "projects/{project}/regions/{region}/instanceTemplates",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InstanceTemplateListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceTemplatesGet"] = compute.get(
        "projects/{project}/regions/{region}/instanceTemplates",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InstanceTemplateListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceTemplatesList"] = compute.get(
        "projects/{project}/regions/{region}/instanceTemplates",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InstanceTemplateListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersAbandonInstances"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersInsert"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersPatchPerInstanceConfigs"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersGet"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersAggregatedList"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersDeleteInstances"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersDelete"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersRecreateInstances"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersUpdatePerInstanceConfigs"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersListErrors"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersListManagedInstances"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersCreateInstances"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersPatch"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersSetInstanceTemplate"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersDeletePerInstanceConfigs"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersList"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersResize"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersListPerInstanceConfigs"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersApplyUpdatesToInstances"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["instanceGroupManagersSetTargetPools"] = compute.post(
        "projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools",
        t.struct(
            {
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "fingerprint": t.string().optional(),
                "targetPools": t.array(t.string()).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalPublicDelegatedPrefixesDelete"] = compute.get(
        "projects/{project}/global/publicDelegatedPrefixes/{publicDelegatedPrefix}",
        t.struct(
            {
                "project": t.string().optional(),
                "publicDelegatedPrefix": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PublicDelegatedPrefixOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalPublicDelegatedPrefixesList"] = compute.get(
        "projects/{project}/global/publicDelegatedPrefixes/{publicDelegatedPrefix}",
        t.struct(
            {
                "project": t.string().optional(),
                "publicDelegatedPrefix": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PublicDelegatedPrefixOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalPublicDelegatedPrefixesInsert"] = compute.get(
        "projects/{project}/global/publicDelegatedPrefixes/{publicDelegatedPrefix}",
        t.struct(
            {
                "project": t.string().optional(),
                "publicDelegatedPrefix": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PublicDelegatedPrefixOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalPublicDelegatedPrefixesPatch"] = compute.get(
        "projects/{project}/global/publicDelegatedPrefixes/{publicDelegatedPrefix}",
        t.struct(
            {
                "project": t.string().optional(),
                "publicDelegatedPrefix": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PublicDelegatedPrefixOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalPublicDelegatedPrefixesGet"] = compute.get(
        "projects/{project}/global/publicDelegatedPrefixes/{publicDelegatedPrefix}",
        t.struct(
            {
                "project": t.string().optional(),
                "publicDelegatedPrefix": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["PublicDelegatedPrefixOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["addressesInsert"] = compute.get(
        "projects/{project}/regions/{region}/addresses",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AddressListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["addressesSetLabels"] = compute.get(
        "projects/{project}/regions/{region}/addresses",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AddressListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["addressesDelete"] = compute.get(
        "projects/{project}/regions/{region}/addresses",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AddressListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["addressesGet"] = compute.get(
        "projects/{project}/regions/{region}/addresses",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AddressListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["addressesAggregatedList"] = compute.get(
        "projects/{project}/regions/{region}/addresses",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AddressListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["addressesMove"] = compute.get(
        "projects/{project}/regions/{region}/addresses",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AddressListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["addressesList"] = compute.get(
        "projects/{project}/regions/{region}/addresses",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "project": t.string().optional(),
                "filter": t.string().optional(),
                "region": t.string().optional(),
                "orderBy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["AddressListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["imageFamilyViewsGet"] = compute.get(
        "projects/{project}/zones/{zone}/imageFamilyViews/{family}",
        t.struct(
            {
                "project": t.string().optional(),
                "family": t.string().optional(),
                "zone": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ImageFamilyViewOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["httpsHealthChecksDelete"] = compute.get(
        "projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}",
        t.struct(
            {
                "project": t.string().optional(),
                "httpsHealthCheck": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HttpsHealthCheckOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["httpsHealthChecksUpdate"] = compute.get(
        "projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}",
        t.struct(
            {
                "project": t.string().optional(),
                "httpsHealthCheck": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HttpsHealthCheckOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["httpsHealthChecksList"] = compute.get(
        "projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}",
        t.struct(
            {
                "project": t.string().optional(),
                "httpsHealthCheck": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HttpsHealthCheckOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["httpsHealthChecksInsert"] = compute.get(
        "projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}",
        t.struct(
            {
                "project": t.string().optional(),
                "httpsHealthCheck": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HttpsHealthCheckOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["httpsHealthChecksPatch"] = compute.get(
        "projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}",
        t.struct(
            {
                "project": t.string().optional(),
                "httpsHealthCheck": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HttpsHealthCheckOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["httpsHealthChecksGet"] = compute.get(
        "projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}",
        t.struct(
            {
                "project": t.string().optional(),
                "httpsHealthCheck": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["HttpsHealthCheckOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetPoolsDelete"] = compute.get(
        "projects/{project}/aggregated/targetPools",
        t.struct(
            {
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetPoolAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetPoolsRemoveInstance"] = compute.get(
        "projects/{project}/aggregated/targetPools",
        t.struct(
            {
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetPoolAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetPoolsList"] = compute.get(
        "projects/{project}/aggregated/targetPools",
        t.struct(
            {
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetPoolAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetPoolsGetHealth"] = compute.get(
        "projects/{project}/aggregated/targetPools",
        t.struct(
            {
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetPoolAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetPoolsSetBackup"] = compute.get(
        "projects/{project}/aggregated/targetPools",
        t.struct(
            {
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetPoolAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetPoolsGet"] = compute.get(
        "projects/{project}/aggregated/targetPools",
        t.struct(
            {
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetPoolAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetPoolsRemoveHealthCheck"] = compute.get(
        "projects/{project}/aggregated/targetPools",
        t.struct(
            {
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetPoolAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetPoolsAddInstance"] = compute.get(
        "projects/{project}/aggregated/targetPools",
        t.struct(
            {
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetPoolAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetPoolsInsert"] = compute.get(
        "projects/{project}/aggregated/targetPools",
        t.struct(
            {
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetPoolAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetPoolsAddHealthCheck"] = compute.get(
        "projects/{project}/aggregated/targetPools",
        t.struct(
            {
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetPoolAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["targetPoolsAggregatedList"] = compute.get(
        "projects/{project}/aggregated/targetPools",
        t.struct(
            {
                "project": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "filter": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "maxResults": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["TargetPoolAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectLocationsList"] = compute.get(
        "projects/{project}/global/interconnectLocations/{interconnectLocation}",
        t.struct(
            {
                "project": t.string().optional(),
                "interconnectLocation": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InterconnectLocationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectLocationsGet"] = compute.get(
        "projects/{project}/global/interconnectLocations/{interconnectLocation}",
        t.struct(
            {
                "project": t.string().optional(),
                "interconnectLocation": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["InterconnectLocationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["reservationsDelete"] = compute.patch(
        "projects/{project}/zones/{zone}/reservations/{reservation}",
        t.struct(
            {
                "updateMask": t.string().optional(),
                "reservation": t.string().optional(),
                "requestId": t.string().optional(),
                "paths": t.string(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "specificReservation": t.proxy(
                    renames["AllocationSpecificSKUReservationIn"]
                ).optional(),
                "satisfiesPzs": t.boolean().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "resourceStatus": t.proxy(
                    renames["AllocationResourceStatusIn"]
                ).optional(),
                "id": t.string().optional(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "resourcePolicies": t.struct({"_": t.string().optional()}).optional(),
                "name": t.string().optional(),
                "status": t.string().optional(),
                "kind": t.string().optional(),
                "specificReservationRequired": t.boolean().optional(),
                "commitment": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["reservationsGetIamPolicy"] = compute.patch(
        "projects/{project}/zones/{zone}/reservations/{reservation}",
        t.struct(
            {
                "updateMask": t.string().optional(),
                "reservation": t.string().optional(),
                "requestId": t.string().optional(),
                "paths": t.string(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "specificReservation": t.proxy(
                    renames["AllocationSpecificSKUReservationIn"]
                ).optional(),
                "satisfiesPzs": t.boolean().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "resourceStatus": t.proxy(
                    renames["AllocationResourceStatusIn"]
                ).optional(),
                "id": t.string().optional(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "resourcePolicies": t.struct({"_": t.string().optional()}).optional(),
                "name": t.string().optional(),
                "status": t.string().optional(),
                "kind": t.string().optional(),
                "specificReservationRequired": t.boolean().optional(),
                "commitment": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["reservationsInsert"] = compute.patch(
        "projects/{project}/zones/{zone}/reservations/{reservation}",
        t.struct(
            {
                "updateMask": t.string().optional(),
                "reservation": t.string().optional(),
                "requestId": t.string().optional(),
                "paths": t.string(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "specificReservation": t.proxy(
                    renames["AllocationSpecificSKUReservationIn"]
                ).optional(),
                "satisfiesPzs": t.boolean().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "resourceStatus": t.proxy(
                    renames["AllocationResourceStatusIn"]
                ).optional(),
                "id": t.string().optional(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "resourcePolicies": t.struct({"_": t.string().optional()}).optional(),
                "name": t.string().optional(),
                "status": t.string().optional(),
                "kind": t.string().optional(),
                "specificReservationRequired": t.boolean().optional(),
                "commitment": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["reservationsAggregatedList"] = compute.patch(
        "projects/{project}/zones/{zone}/reservations/{reservation}",
        t.struct(
            {
                "updateMask": t.string().optional(),
                "reservation": t.string().optional(),
                "requestId": t.string().optional(),
                "paths": t.string(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "specificReservation": t.proxy(
                    renames["AllocationSpecificSKUReservationIn"]
                ).optional(),
                "satisfiesPzs": t.boolean().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "resourceStatus": t.proxy(
                    renames["AllocationResourceStatusIn"]
                ).optional(),
                "id": t.string().optional(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "resourcePolicies": t.struct({"_": t.string().optional()}).optional(),
                "name": t.string().optional(),
                "status": t.string().optional(),
                "kind": t.string().optional(),
                "specificReservationRequired": t.boolean().optional(),
                "commitment": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["reservationsResize"] = compute.patch(
        "projects/{project}/zones/{zone}/reservations/{reservation}",
        t.struct(
            {
                "updateMask": t.string().optional(),
                "reservation": t.string().optional(),
                "requestId": t.string().optional(),
                "paths": t.string(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "specificReservation": t.proxy(
                    renames["AllocationSpecificSKUReservationIn"]
                ).optional(),
                "satisfiesPzs": t.boolean().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "resourceStatus": t.proxy(
                    renames["AllocationResourceStatusIn"]
                ).optional(),
                "id": t.string().optional(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "resourcePolicies": t.struct({"_": t.string().optional()}).optional(),
                "name": t.string().optional(),
                "status": t.string().optional(),
                "kind": t.string().optional(),
                "specificReservationRequired": t.boolean().optional(),
                "commitment": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["reservationsGet"] = compute.patch(
        "projects/{project}/zones/{zone}/reservations/{reservation}",
        t.struct(
            {
                "updateMask": t.string().optional(),
                "reservation": t.string().optional(),
                "requestId": t.string().optional(),
                "paths": t.string(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "specificReservation": t.proxy(
                    renames["AllocationSpecificSKUReservationIn"]
                ).optional(),
                "satisfiesPzs": t.boolean().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "resourceStatus": t.proxy(
                    renames["AllocationResourceStatusIn"]
                ).optional(),
                "id": t.string().optional(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "resourcePolicies": t.struct({"_": t.string().optional()}).optional(),
                "name": t.string().optional(),
                "status": t.string().optional(),
                "kind": t.string().optional(),
                "specificReservationRequired": t.boolean().optional(),
                "commitment": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["reservationsSetIamPolicy"] = compute.patch(
        "projects/{project}/zones/{zone}/reservations/{reservation}",
        t.struct(
            {
                "updateMask": t.string().optional(),
                "reservation": t.string().optional(),
                "requestId": t.string().optional(),
                "paths": t.string(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "specificReservation": t.proxy(
                    renames["AllocationSpecificSKUReservationIn"]
                ).optional(),
                "satisfiesPzs": t.boolean().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "resourceStatus": t.proxy(
                    renames["AllocationResourceStatusIn"]
                ).optional(),
                "id": t.string().optional(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "resourcePolicies": t.struct({"_": t.string().optional()}).optional(),
                "name": t.string().optional(),
                "status": t.string().optional(),
                "kind": t.string().optional(),
                "specificReservationRequired": t.boolean().optional(),
                "commitment": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["reservationsTestIamPermissions"] = compute.patch(
        "projects/{project}/zones/{zone}/reservations/{reservation}",
        t.struct(
            {
                "updateMask": t.string().optional(),
                "reservation": t.string().optional(),
                "requestId": t.string().optional(),
                "paths": t.string(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "specificReservation": t.proxy(
                    renames["AllocationSpecificSKUReservationIn"]
                ).optional(),
                "satisfiesPzs": t.boolean().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "resourceStatus": t.proxy(
                    renames["AllocationResourceStatusIn"]
                ).optional(),
                "id": t.string().optional(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "resourcePolicies": t.struct({"_": t.string().optional()}).optional(),
                "name": t.string().optional(),
                "status": t.string().optional(),
                "kind": t.string().optional(),
                "specificReservationRequired": t.boolean().optional(),
                "commitment": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["reservationsList"] = compute.patch(
        "projects/{project}/zones/{zone}/reservations/{reservation}",
        t.struct(
            {
                "updateMask": t.string().optional(),
                "reservation": t.string().optional(),
                "requestId": t.string().optional(),
                "paths": t.string(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "specificReservation": t.proxy(
                    renames["AllocationSpecificSKUReservationIn"]
                ).optional(),
                "satisfiesPzs": t.boolean().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "resourceStatus": t.proxy(
                    renames["AllocationResourceStatusIn"]
                ).optional(),
                "id": t.string().optional(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "resourcePolicies": t.struct({"_": t.string().optional()}).optional(),
                "name": t.string().optional(),
                "status": t.string().optional(),
                "kind": t.string().optional(),
                "specificReservationRequired": t.boolean().optional(),
                "commitment": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["reservationsUpdate"] = compute.patch(
        "projects/{project}/zones/{zone}/reservations/{reservation}",
        t.struct(
            {
                "updateMask": t.string().optional(),
                "reservation": t.string().optional(),
                "requestId": t.string().optional(),
                "paths": t.string(),
                "zone": t.string().optional(),
                "project": t.string().optional(),
                "specificReservation": t.proxy(
                    renames["AllocationSpecificSKUReservationIn"]
                ).optional(),
                "satisfiesPzs": t.boolean().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "resourceStatus": t.proxy(
                    renames["AllocationResourceStatusIn"]
                ).optional(),
                "id": t.string().optional(),
                "shareSettings": t.proxy(renames["ShareSettingsIn"]).optional(),
                "resourcePolicies": t.struct({"_": t.string().optional()}).optional(),
                "name": t.string().optional(),
                "status": t.string().optional(),
                "kind": t.string().optional(),
                "specificReservationRequired": t.boolean().optional(),
                "commitment": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksSetIamPolicy"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksList"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksDelete"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksGetIamPolicy"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksTestIamPermissions"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksGet"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksStopGroupAsyncReplication"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksStartAsyncReplication"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksInsert"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksRemoveResourcePolicies"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksAddResourcePolicies"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksBulkInsert"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksCreateSnapshot"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksStopAsyncReplication"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksUpdate"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksSetLabels"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionDisksResize"] = compute.post(
        "projects/{project}/regions/{region}/disks/{disk}/resize",
        t.struct(
            {
                "disk": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "sizeGb": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalForwardingRulesGet"] = compute.post(
        "projects/{project}/global/forwardingRules/{forwardingRule}/setTarget",
        t.struct(
            {
                "forwardingRule": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "target": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalForwardingRulesSetLabels"] = compute.post(
        "projects/{project}/global/forwardingRules/{forwardingRule}/setTarget",
        t.struct(
            {
                "forwardingRule": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "target": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalForwardingRulesInsert"] = compute.post(
        "projects/{project}/global/forwardingRules/{forwardingRule}/setTarget",
        t.struct(
            {
                "forwardingRule": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "target": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalForwardingRulesPatch"] = compute.post(
        "projects/{project}/global/forwardingRules/{forwardingRule}/setTarget",
        t.struct(
            {
                "forwardingRule": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "target": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalForwardingRulesDelete"] = compute.post(
        "projects/{project}/global/forwardingRules/{forwardingRule}/setTarget",
        t.struct(
            {
                "forwardingRule": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "target": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalForwardingRulesList"] = compute.post(
        "projects/{project}/global/forwardingRules/{forwardingRule}/setTarget",
        t.struct(
            {
                "forwardingRule": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "target": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalForwardingRulesSetTarget"] = compute.post(
        "projects/{project}/global/forwardingRules/{forwardingRule}/setTarget",
        t.struct(
            {
                "forwardingRule": t.string().optional(),
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "target": t.string(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEdgeSecurityServicesDelete"] = compute.get(
        "projects/{project}/aggregated/networkEdgeSecurityServices",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEdgeSecurityServiceAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEdgeSecurityServicesInsert"] = compute.get(
        "projects/{project}/aggregated/networkEdgeSecurityServices",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEdgeSecurityServiceAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEdgeSecurityServicesPatch"] = compute.get(
        "projects/{project}/aggregated/networkEdgeSecurityServices",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEdgeSecurityServiceAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEdgeSecurityServicesGet"] = compute.get(
        "projects/{project}/aggregated/networkEdgeSecurityServices",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEdgeSecurityServiceAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEdgeSecurityServicesAggregatedList"] = compute.get(
        "projects/{project}/aggregated/networkEdgeSecurityServices",
        t.struct(
            {
                "pageToken": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEdgeSecurityServiceAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["machineImagesSetIamPolicy"] = compute.get(
        "projects/{project}/global/machineImages/{machineImage}",
        t.struct(
            {
                "project": t.string().optional(),
                "machineImage": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["MachineImageOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["machineImagesGetIamPolicy"] = compute.get(
        "projects/{project}/global/machineImages/{machineImage}",
        t.struct(
            {
                "project": t.string().optional(),
                "machineImage": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["MachineImageOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["machineImagesTestIamPermissions"] = compute.get(
        "projects/{project}/global/machineImages/{machineImage}",
        t.struct(
            {
                "project": t.string().optional(),
                "machineImage": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["MachineImageOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["machineImagesList"] = compute.get(
        "projects/{project}/global/machineImages/{machineImage}",
        t.struct(
            {
                "project": t.string().optional(),
                "machineImage": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["MachineImageOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["machineImagesDelete"] = compute.get(
        "projects/{project}/global/machineImages/{machineImage}",
        t.struct(
            {
                "project": t.string().optional(),
                "machineImage": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["MachineImageOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["machineImagesInsert"] = compute.get(
        "projects/{project}/global/machineImages/{machineImage}",
        t.struct(
            {
                "project": t.string().optional(),
                "machineImage": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["MachineImageOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["machineImagesGet"] = compute.get(
        "projects/{project}/global/machineImages/{machineImage}",
        t.struct(
            {
                "project": t.string().optional(),
                "machineImage": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["MachineImageOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["urlMapsAggregatedList"] = compute.put(
        "projects/{project}/global/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string().optional(),
                "id": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "defaultRouteAction": t.proxy(renames["HttpRouteActionIn"]).optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "headerAction": t.proxy(renames["HttpHeaderActionIn"]).optional(),
                "defaultService": t.string().optional(),
                "pathMatchers": t.array(t.proxy(renames["PathMatcherIn"])).optional(),
                "selfLink": t.string().optional(),
                "tests": t.array(t.proxy(renames["UrlMapTestIn"])).optional(),
                "fingerprint": t.string().optional(),
                "hostRules": t.array(t.proxy(renames["HostRuleIn"])).optional(),
                "name": t.string().optional(),
                "defaultUrlRedirect": t.proxy(
                    renames["HttpRedirectActionIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["urlMapsDelete"] = compute.put(
        "projects/{project}/global/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string().optional(),
                "id": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "defaultRouteAction": t.proxy(renames["HttpRouteActionIn"]).optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "headerAction": t.proxy(renames["HttpHeaderActionIn"]).optional(),
                "defaultService": t.string().optional(),
                "pathMatchers": t.array(t.proxy(renames["PathMatcherIn"])).optional(),
                "selfLink": t.string().optional(),
                "tests": t.array(t.proxy(renames["UrlMapTestIn"])).optional(),
                "fingerprint": t.string().optional(),
                "hostRules": t.array(t.proxy(renames["HostRuleIn"])).optional(),
                "name": t.string().optional(),
                "defaultUrlRedirect": t.proxy(
                    renames["HttpRedirectActionIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["urlMapsInsert"] = compute.put(
        "projects/{project}/global/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string().optional(),
                "id": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "defaultRouteAction": t.proxy(renames["HttpRouteActionIn"]).optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "headerAction": t.proxy(renames["HttpHeaderActionIn"]).optional(),
                "defaultService": t.string().optional(),
                "pathMatchers": t.array(t.proxy(renames["PathMatcherIn"])).optional(),
                "selfLink": t.string().optional(),
                "tests": t.array(t.proxy(renames["UrlMapTestIn"])).optional(),
                "fingerprint": t.string().optional(),
                "hostRules": t.array(t.proxy(renames["HostRuleIn"])).optional(),
                "name": t.string().optional(),
                "defaultUrlRedirect": t.proxy(
                    renames["HttpRedirectActionIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["urlMapsInvalidateCache"] = compute.put(
        "projects/{project}/global/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string().optional(),
                "id": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "defaultRouteAction": t.proxy(renames["HttpRouteActionIn"]).optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "headerAction": t.proxy(renames["HttpHeaderActionIn"]).optional(),
                "defaultService": t.string().optional(),
                "pathMatchers": t.array(t.proxy(renames["PathMatcherIn"])).optional(),
                "selfLink": t.string().optional(),
                "tests": t.array(t.proxy(renames["UrlMapTestIn"])).optional(),
                "fingerprint": t.string().optional(),
                "hostRules": t.array(t.proxy(renames["HostRuleIn"])).optional(),
                "name": t.string().optional(),
                "defaultUrlRedirect": t.proxy(
                    renames["HttpRedirectActionIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["urlMapsList"] = compute.put(
        "projects/{project}/global/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string().optional(),
                "id": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "defaultRouteAction": t.proxy(renames["HttpRouteActionIn"]).optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "headerAction": t.proxy(renames["HttpHeaderActionIn"]).optional(),
                "defaultService": t.string().optional(),
                "pathMatchers": t.array(t.proxy(renames["PathMatcherIn"])).optional(),
                "selfLink": t.string().optional(),
                "tests": t.array(t.proxy(renames["UrlMapTestIn"])).optional(),
                "fingerprint": t.string().optional(),
                "hostRules": t.array(t.proxy(renames["HostRuleIn"])).optional(),
                "name": t.string().optional(),
                "defaultUrlRedirect": t.proxy(
                    renames["HttpRedirectActionIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["urlMapsValidate"] = compute.put(
        "projects/{project}/global/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string().optional(),
                "id": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "defaultRouteAction": t.proxy(renames["HttpRouteActionIn"]).optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "headerAction": t.proxy(renames["HttpHeaderActionIn"]).optional(),
                "defaultService": t.string().optional(),
                "pathMatchers": t.array(t.proxy(renames["PathMatcherIn"])).optional(),
                "selfLink": t.string().optional(),
                "tests": t.array(t.proxy(renames["UrlMapTestIn"])).optional(),
                "fingerprint": t.string().optional(),
                "hostRules": t.array(t.proxy(renames["HostRuleIn"])).optional(),
                "name": t.string().optional(),
                "defaultUrlRedirect": t.proxy(
                    renames["HttpRedirectActionIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["urlMapsGet"] = compute.put(
        "projects/{project}/global/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string().optional(),
                "id": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "defaultRouteAction": t.proxy(renames["HttpRouteActionIn"]).optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "headerAction": t.proxy(renames["HttpHeaderActionIn"]).optional(),
                "defaultService": t.string().optional(),
                "pathMatchers": t.array(t.proxy(renames["PathMatcherIn"])).optional(),
                "selfLink": t.string().optional(),
                "tests": t.array(t.proxy(renames["UrlMapTestIn"])).optional(),
                "fingerprint": t.string().optional(),
                "hostRules": t.array(t.proxy(renames["HostRuleIn"])).optional(),
                "name": t.string().optional(),
                "defaultUrlRedirect": t.proxy(
                    renames["HttpRedirectActionIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["urlMapsPatch"] = compute.put(
        "projects/{project}/global/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string().optional(),
                "id": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "defaultRouteAction": t.proxy(renames["HttpRouteActionIn"]).optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "headerAction": t.proxy(renames["HttpHeaderActionIn"]).optional(),
                "defaultService": t.string().optional(),
                "pathMatchers": t.array(t.proxy(renames["PathMatcherIn"])).optional(),
                "selfLink": t.string().optional(),
                "tests": t.array(t.proxy(renames["UrlMapTestIn"])).optional(),
                "fingerprint": t.string().optional(),
                "hostRules": t.array(t.proxy(renames["HostRuleIn"])).optional(),
                "name": t.string().optional(),
                "defaultUrlRedirect": t.proxy(
                    renames["HttpRedirectActionIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["urlMapsUpdate"] = compute.put(
        "projects/{project}/global/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "urlMap": t.string().optional(),
                "id": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "defaultRouteAction": t.proxy(renames["HttpRouteActionIn"]).optional(),
                "description": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "headerAction": t.proxy(renames["HttpHeaderActionIn"]).optional(),
                "defaultService": t.string().optional(),
                "pathMatchers": t.array(t.proxy(renames["PathMatcherIn"])).optional(),
                "selfLink": t.string().optional(),
                "tests": t.array(t.proxy(renames["UrlMapTestIn"])).optional(),
                "fingerprint": t.string().optional(),
                "hostRules": t.array(t.proxy(renames["HostRuleIn"])).optional(),
                "name": t.string().optional(),
                "defaultUrlRedirect": t.proxy(
                    renames["HttpRedirectActionIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSslPoliciesGet"] = compute.get(
        "projects/{project}/regions/{region}/sslPolicies/listAvailableFeatures",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslPoliciesListAvailableFeaturesResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSslPoliciesDelete"] = compute.get(
        "projects/{project}/regions/{region}/sslPolicies/listAvailableFeatures",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslPoliciesListAvailableFeaturesResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSslPoliciesInsert"] = compute.get(
        "projects/{project}/regions/{region}/sslPolicies/listAvailableFeatures",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslPoliciesListAvailableFeaturesResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSslPoliciesPatch"] = compute.get(
        "projects/{project}/regions/{region}/sslPolicies/listAvailableFeatures",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslPoliciesListAvailableFeaturesResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSslPoliciesList"] = compute.get(
        "projects/{project}/regions/{region}/sslPolicies/listAvailableFeatures",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslPoliciesListAvailableFeaturesResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSslPoliciesListAvailableFeatures"] = compute.get(
        "projects/{project}/regions/{region}/sslPolicies/listAvailableFeatures",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "pageToken": t.string().optional(),
                "orderBy": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslPoliciesListAvailableFeaturesResponseOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["imagesList"] = compute.post(
        "projects/{project}/global/images",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "forceCreate": t.boolean().optional(),
                "sourceType": t.string().optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskId": t.string().optional(),
                "id": t.string().optional(),
                "shieldedInstanceInitialState": t.proxy(
                    renames["InitialStateConfigIn"]
                ).optional(),
                "kind": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "description": t.string().optional(),
                "family": t.string().optional(),
                "status": t.string().optional(),
                "rawDisk": t.struct(
                    {
                        "sha1Checksum": t.string().optional(),
                        "containerType": t.string().optional(),
                        "source": t.string().optional(),
                    }
                ).optional(),
                "name": t.string().optional(),
                "storageLocations": t.array(t.string()).optional(),
                "sourceSnapshot": t.string().optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "sourceImageId": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "diskSizeGb": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceImage": t.string().optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "licenses": t.array(t.string()).optional(),
                "architecture": t.string().optional(),
                "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
                "sourceDisk": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "imageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "archiveSizeBytes": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["imagesDeprecate"] = compute.post(
        "projects/{project}/global/images",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "forceCreate": t.boolean().optional(),
                "sourceType": t.string().optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskId": t.string().optional(),
                "id": t.string().optional(),
                "shieldedInstanceInitialState": t.proxy(
                    renames["InitialStateConfigIn"]
                ).optional(),
                "kind": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "description": t.string().optional(),
                "family": t.string().optional(),
                "status": t.string().optional(),
                "rawDisk": t.struct(
                    {
                        "sha1Checksum": t.string().optional(),
                        "containerType": t.string().optional(),
                        "source": t.string().optional(),
                    }
                ).optional(),
                "name": t.string().optional(),
                "storageLocations": t.array(t.string()).optional(),
                "sourceSnapshot": t.string().optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "sourceImageId": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "diskSizeGb": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceImage": t.string().optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "licenses": t.array(t.string()).optional(),
                "architecture": t.string().optional(),
                "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
                "sourceDisk": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "imageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "archiveSizeBytes": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["imagesDelete"] = compute.post(
        "projects/{project}/global/images",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "forceCreate": t.boolean().optional(),
                "sourceType": t.string().optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskId": t.string().optional(),
                "id": t.string().optional(),
                "shieldedInstanceInitialState": t.proxy(
                    renames["InitialStateConfigIn"]
                ).optional(),
                "kind": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "description": t.string().optional(),
                "family": t.string().optional(),
                "status": t.string().optional(),
                "rawDisk": t.struct(
                    {
                        "sha1Checksum": t.string().optional(),
                        "containerType": t.string().optional(),
                        "source": t.string().optional(),
                    }
                ).optional(),
                "name": t.string().optional(),
                "storageLocations": t.array(t.string()).optional(),
                "sourceSnapshot": t.string().optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "sourceImageId": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "diskSizeGb": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceImage": t.string().optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "licenses": t.array(t.string()).optional(),
                "architecture": t.string().optional(),
                "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
                "sourceDisk": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "imageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "archiveSizeBytes": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["imagesSetLabels"] = compute.post(
        "projects/{project}/global/images",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "forceCreate": t.boolean().optional(),
                "sourceType": t.string().optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskId": t.string().optional(),
                "id": t.string().optional(),
                "shieldedInstanceInitialState": t.proxy(
                    renames["InitialStateConfigIn"]
                ).optional(),
                "kind": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "description": t.string().optional(),
                "family": t.string().optional(),
                "status": t.string().optional(),
                "rawDisk": t.struct(
                    {
                        "sha1Checksum": t.string().optional(),
                        "containerType": t.string().optional(),
                        "source": t.string().optional(),
                    }
                ).optional(),
                "name": t.string().optional(),
                "storageLocations": t.array(t.string()).optional(),
                "sourceSnapshot": t.string().optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "sourceImageId": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "diskSizeGb": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceImage": t.string().optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "licenses": t.array(t.string()).optional(),
                "architecture": t.string().optional(),
                "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
                "sourceDisk": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "imageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "archiveSizeBytes": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["imagesGetIamPolicy"] = compute.post(
        "projects/{project}/global/images",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "forceCreate": t.boolean().optional(),
                "sourceType": t.string().optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskId": t.string().optional(),
                "id": t.string().optional(),
                "shieldedInstanceInitialState": t.proxy(
                    renames["InitialStateConfigIn"]
                ).optional(),
                "kind": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "description": t.string().optional(),
                "family": t.string().optional(),
                "status": t.string().optional(),
                "rawDisk": t.struct(
                    {
                        "sha1Checksum": t.string().optional(),
                        "containerType": t.string().optional(),
                        "source": t.string().optional(),
                    }
                ).optional(),
                "name": t.string().optional(),
                "storageLocations": t.array(t.string()).optional(),
                "sourceSnapshot": t.string().optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "sourceImageId": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "diskSizeGb": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceImage": t.string().optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "licenses": t.array(t.string()).optional(),
                "architecture": t.string().optional(),
                "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
                "sourceDisk": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "imageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "archiveSizeBytes": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["imagesPatch"] = compute.post(
        "projects/{project}/global/images",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "forceCreate": t.boolean().optional(),
                "sourceType": t.string().optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskId": t.string().optional(),
                "id": t.string().optional(),
                "shieldedInstanceInitialState": t.proxy(
                    renames["InitialStateConfigIn"]
                ).optional(),
                "kind": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "description": t.string().optional(),
                "family": t.string().optional(),
                "status": t.string().optional(),
                "rawDisk": t.struct(
                    {
                        "sha1Checksum": t.string().optional(),
                        "containerType": t.string().optional(),
                        "source": t.string().optional(),
                    }
                ).optional(),
                "name": t.string().optional(),
                "storageLocations": t.array(t.string()).optional(),
                "sourceSnapshot": t.string().optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "sourceImageId": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "diskSizeGb": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceImage": t.string().optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "licenses": t.array(t.string()).optional(),
                "architecture": t.string().optional(),
                "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
                "sourceDisk": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "imageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "archiveSizeBytes": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["imagesGet"] = compute.post(
        "projects/{project}/global/images",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "forceCreate": t.boolean().optional(),
                "sourceType": t.string().optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskId": t.string().optional(),
                "id": t.string().optional(),
                "shieldedInstanceInitialState": t.proxy(
                    renames["InitialStateConfigIn"]
                ).optional(),
                "kind": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "description": t.string().optional(),
                "family": t.string().optional(),
                "status": t.string().optional(),
                "rawDisk": t.struct(
                    {
                        "sha1Checksum": t.string().optional(),
                        "containerType": t.string().optional(),
                        "source": t.string().optional(),
                    }
                ).optional(),
                "name": t.string().optional(),
                "storageLocations": t.array(t.string()).optional(),
                "sourceSnapshot": t.string().optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "sourceImageId": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "diskSizeGb": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceImage": t.string().optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "licenses": t.array(t.string()).optional(),
                "architecture": t.string().optional(),
                "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
                "sourceDisk": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "imageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "archiveSizeBytes": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["imagesSetIamPolicy"] = compute.post(
        "projects/{project}/global/images",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "forceCreate": t.boolean().optional(),
                "sourceType": t.string().optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskId": t.string().optional(),
                "id": t.string().optional(),
                "shieldedInstanceInitialState": t.proxy(
                    renames["InitialStateConfigIn"]
                ).optional(),
                "kind": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "description": t.string().optional(),
                "family": t.string().optional(),
                "status": t.string().optional(),
                "rawDisk": t.struct(
                    {
                        "sha1Checksum": t.string().optional(),
                        "containerType": t.string().optional(),
                        "source": t.string().optional(),
                    }
                ).optional(),
                "name": t.string().optional(),
                "storageLocations": t.array(t.string()).optional(),
                "sourceSnapshot": t.string().optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "sourceImageId": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "diskSizeGb": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceImage": t.string().optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "licenses": t.array(t.string()).optional(),
                "architecture": t.string().optional(),
                "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
                "sourceDisk": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "imageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "archiveSizeBytes": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["imagesGetFromFamily"] = compute.post(
        "projects/{project}/global/images",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "forceCreate": t.boolean().optional(),
                "sourceType": t.string().optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskId": t.string().optional(),
                "id": t.string().optional(),
                "shieldedInstanceInitialState": t.proxy(
                    renames["InitialStateConfigIn"]
                ).optional(),
                "kind": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "description": t.string().optional(),
                "family": t.string().optional(),
                "status": t.string().optional(),
                "rawDisk": t.struct(
                    {
                        "sha1Checksum": t.string().optional(),
                        "containerType": t.string().optional(),
                        "source": t.string().optional(),
                    }
                ).optional(),
                "name": t.string().optional(),
                "storageLocations": t.array(t.string()).optional(),
                "sourceSnapshot": t.string().optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "sourceImageId": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "diskSizeGb": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceImage": t.string().optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "licenses": t.array(t.string()).optional(),
                "architecture": t.string().optional(),
                "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
                "sourceDisk": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "imageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "archiveSizeBytes": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["imagesTestIamPermissions"] = compute.post(
        "projects/{project}/global/images",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "forceCreate": t.boolean().optional(),
                "sourceType": t.string().optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskId": t.string().optional(),
                "id": t.string().optional(),
                "shieldedInstanceInitialState": t.proxy(
                    renames["InitialStateConfigIn"]
                ).optional(),
                "kind": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "description": t.string().optional(),
                "family": t.string().optional(),
                "status": t.string().optional(),
                "rawDisk": t.struct(
                    {
                        "sha1Checksum": t.string().optional(),
                        "containerType": t.string().optional(),
                        "source": t.string().optional(),
                    }
                ).optional(),
                "name": t.string().optional(),
                "storageLocations": t.array(t.string()).optional(),
                "sourceSnapshot": t.string().optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "sourceImageId": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "diskSizeGb": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceImage": t.string().optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "licenses": t.array(t.string()).optional(),
                "architecture": t.string().optional(),
                "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
                "sourceDisk": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "imageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "archiveSizeBytes": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["imagesInsert"] = compute.post(
        "projects/{project}/global/images",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "forceCreate": t.boolean().optional(),
                "sourceType": t.string().optional(),
                "sourceSnapshotEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "sourceDiskId": t.string().optional(),
                "id": t.string().optional(),
                "shieldedInstanceInitialState": t.proxy(
                    renames["InitialStateConfigIn"]
                ).optional(),
                "kind": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "description": t.string().optional(),
                "family": t.string().optional(),
                "status": t.string().optional(),
                "rawDisk": t.struct(
                    {
                        "sha1Checksum": t.string().optional(),
                        "containerType": t.string().optional(),
                        "source": t.string().optional(),
                    }
                ).optional(),
                "name": t.string().optional(),
                "storageLocations": t.array(t.string()).optional(),
                "sourceSnapshot": t.string().optional(),
                "licenseCodes": t.array(t.string()).optional(),
                "sourceImageId": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "diskSizeGb": t.string().optional(),
                "selfLink": t.string().optional(),
                "sourceImage": t.string().optional(),
                "guestOsFeatures": t.array(
                    t.proxy(renames["GuestOsFeatureIn"])
                ).optional(),
                "licenses": t.array(t.string()).optional(),
                "architecture": t.string().optional(),
                "deprecated": t.proxy(renames["DeprecationStatusIn"]).optional(),
                "sourceDisk": t.string().optional(),
                "sourceSnapshotId": t.string().optional(),
                "imageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "archiveSizeBytes": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "sourceImageEncryptionKey": t.proxy(
                    renames["CustomerEncryptionKeyIn"]
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectsInsert"] = compute.patch(
        "projects/{project}/global/interconnects/{interconnect}",
        t.struct(
            {
                "interconnect": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "operationalStatus": t.string().optional(),
                "googleIpAddress": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "interconnectAttachments": t.array(t.string()).optional(),
                "location": t.string().optional(),
                "name": t.string().optional(),
                "state": t.string().optional(),
                "selfLink": t.string().optional(),
                "interconnectType": t.string().optional(),
                "customerName": t.string().optional(),
                "peerIpAddress": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "linkType": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "googleReferenceId": t.string().optional(),
                "description": t.string().optional(),
                "expectedOutages": t.array(
                    t.proxy(renames["InterconnectOutageNotificationIn"])
                ).optional(),
                "adminEnabled": t.boolean().optional(),
                "provisionedLinkCount": t.integer().optional(),
                "kind": t.string().optional(),
                "requestedLinkCount": t.integer().optional(),
                "nocContactEmail": t.string().optional(),
                "id": t.string().optional(),
                "remoteLocation": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "circuitInfos": t.array(
                    t.proxy(renames["InterconnectCircuitInfoIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectsSetLabels"] = compute.patch(
        "projects/{project}/global/interconnects/{interconnect}",
        t.struct(
            {
                "interconnect": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "operationalStatus": t.string().optional(),
                "googleIpAddress": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "interconnectAttachments": t.array(t.string()).optional(),
                "location": t.string().optional(),
                "name": t.string().optional(),
                "state": t.string().optional(),
                "selfLink": t.string().optional(),
                "interconnectType": t.string().optional(),
                "customerName": t.string().optional(),
                "peerIpAddress": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "linkType": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "googleReferenceId": t.string().optional(),
                "description": t.string().optional(),
                "expectedOutages": t.array(
                    t.proxy(renames["InterconnectOutageNotificationIn"])
                ).optional(),
                "adminEnabled": t.boolean().optional(),
                "provisionedLinkCount": t.integer().optional(),
                "kind": t.string().optional(),
                "requestedLinkCount": t.integer().optional(),
                "nocContactEmail": t.string().optional(),
                "id": t.string().optional(),
                "remoteLocation": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "circuitInfos": t.array(
                    t.proxy(renames["InterconnectCircuitInfoIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectsGet"] = compute.patch(
        "projects/{project}/global/interconnects/{interconnect}",
        t.struct(
            {
                "interconnect": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "operationalStatus": t.string().optional(),
                "googleIpAddress": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "interconnectAttachments": t.array(t.string()).optional(),
                "location": t.string().optional(),
                "name": t.string().optional(),
                "state": t.string().optional(),
                "selfLink": t.string().optional(),
                "interconnectType": t.string().optional(),
                "customerName": t.string().optional(),
                "peerIpAddress": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "linkType": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "googleReferenceId": t.string().optional(),
                "description": t.string().optional(),
                "expectedOutages": t.array(
                    t.proxy(renames["InterconnectOutageNotificationIn"])
                ).optional(),
                "adminEnabled": t.boolean().optional(),
                "provisionedLinkCount": t.integer().optional(),
                "kind": t.string().optional(),
                "requestedLinkCount": t.integer().optional(),
                "nocContactEmail": t.string().optional(),
                "id": t.string().optional(),
                "remoteLocation": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "circuitInfos": t.array(
                    t.proxy(renames["InterconnectCircuitInfoIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectsDelete"] = compute.patch(
        "projects/{project}/global/interconnects/{interconnect}",
        t.struct(
            {
                "interconnect": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "operationalStatus": t.string().optional(),
                "googleIpAddress": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "interconnectAttachments": t.array(t.string()).optional(),
                "location": t.string().optional(),
                "name": t.string().optional(),
                "state": t.string().optional(),
                "selfLink": t.string().optional(),
                "interconnectType": t.string().optional(),
                "customerName": t.string().optional(),
                "peerIpAddress": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "linkType": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "googleReferenceId": t.string().optional(),
                "description": t.string().optional(),
                "expectedOutages": t.array(
                    t.proxy(renames["InterconnectOutageNotificationIn"])
                ).optional(),
                "adminEnabled": t.boolean().optional(),
                "provisionedLinkCount": t.integer().optional(),
                "kind": t.string().optional(),
                "requestedLinkCount": t.integer().optional(),
                "nocContactEmail": t.string().optional(),
                "id": t.string().optional(),
                "remoteLocation": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "circuitInfos": t.array(
                    t.proxy(renames["InterconnectCircuitInfoIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectsGetDiagnostics"] = compute.patch(
        "projects/{project}/global/interconnects/{interconnect}",
        t.struct(
            {
                "interconnect": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "operationalStatus": t.string().optional(),
                "googleIpAddress": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "interconnectAttachments": t.array(t.string()).optional(),
                "location": t.string().optional(),
                "name": t.string().optional(),
                "state": t.string().optional(),
                "selfLink": t.string().optional(),
                "interconnectType": t.string().optional(),
                "customerName": t.string().optional(),
                "peerIpAddress": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "linkType": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "googleReferenceId": t.string().optional(),
                "description": t.string().optional(),
                "expectedOutages": t.array(
                    t.proxy(renames["InterconnectOutageNotificationIn"])
                ).optional(),
                "adminEnabled": t.boolean().optional(),
                "provisionedLinkCount": t.integer().optional(),
                "kind": t.string().optional(),
                "requestedLinkCount": t.integer().optional(),
                "nocContactEmail": t.string().optional(),
                "id": t.string().optional(),
                "remoteLocation": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "circuitInfos": t.array(
                    t.proxy(renames["InterconnectCircuitInfoIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectsList"] = compute.patch(
        "projects/{project}/global/interconnects/{interconnect}",
        t.struct(
            {
                "interconnect": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "operationalStatus": t.string().optional(),
                "googleIpAddress": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "interconnectAttachments": t.array(t.string()).optional(),
                "location": t.string().optional(),
                "name": t.string().optional(),
                "state": t.string().optional(),
                "selfLink": t.string().optional(),
                "interconnectType": t.string().optional(),
                "customerName": t.string().optional(),
                "peerIpAddress": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "linkType": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "googleReferenceId": t.string().optional(),
                "description": t.string().optional(),
                "expectedOutages": t.array(
                    t.proxy(renames["InterconnectOutageNotificationIn"])
                ).optional(),
                "adminEnabled": t.boolean().optional(),
                "provisionedLinkCount": t.integer().optional(),
                "kind": t.string().optional(),
                "requestedLinkCount": t.integer().optional(),
                "nocContactEmail": t.string().optional(),
                "id": t.string().optional(),
                "remoteLocation": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "circuitInfos": t.array(
                    t.proxy(renames["InterconnectCircuitInfoIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectsPatch"] = compute.patch(
        "projects/{project}/global/interconnects/{interconnect}",
        t.struct(
            {
                "interconnect": t.string().optional(),
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "operationalStatus": t.string().optional(),
                "googleIpAddress": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "interconnectAttachments": t.array(t.string()).optional(),
                "location": t.string().optional(),
                "name": t.string().optional(),
                "state": t.string().optional(),
                "selfLink": t.string().optional(),
                "interconnectType": t.string().optional(),
                "customerName": t.string().optional(),
                "peerIpAddress": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "linkType": t.string().optional(),
                "satisfiesPzs": t.boolean().optional(),
                "googleReferenceId": t.string().optional(),
                "description": t.string().optional(),
                "expectedOutages": t.array(
                    t.proxy(renames["InterconnectOutageNotificationIn"])
                ).optional(),
                "adminEnabled": t.boolean().optional(),
                "provisionedLinkCount": t.integer().optional(),
                "kind": t.string().optional(),
                "requestedLinkCount": t.integer().optional(),
                "nocContactEmail": t.string().optional(),
                "id": t.string().optional(),
                "remoteLocation": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "circuitInfos": t.array(
                    t.proxy(renames["InterconnectCircuitInfoIn"])
                ).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendBucketsUpdate"] = compute.get(
        "projects/{project}/global/backendBuckets/{backendBucket}",
        t.struct(
            {
                "project": t.string().optional(),
                "backendBucket": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendBucketOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendBucketsDeleteSignedUrlKey"] = compute.get(
        "projects/{project}/global/backendBuckets/{backendBucket}",
        t.struct(
            {
                "project": t.string().optional(),
                "backendBucket": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendBucketOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendBucketsAddSignedUrlKey"] = compute.get(
        "projects/{project}/global/backendBuckets/{backendBucket}",
        t.struct(
            {
                "project": t.string().optional(),
                "backendBucket": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendBucketOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendBucketsInsert"] = compute.get(
        "projects/{project}/global/backendBuckets/{backendBucket}",
        t.struct(
            {
                "project": t.string().optional(),
                "backendBucket": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendBucketOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendBucketsDelete"] = compute.get(
        "projects/{project}/global/backendBuckets/{backendBucket}",
        t.struct(
            {
                "project": t.string().optional(),
                "backendBucket": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendBucketOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendBucketsList"] = compute.get(
        "projects/{project}/global/backendBuckets/{backendBucket}",
        t.struct(
            {
                "project": t.string().optional(),
                "backendBucket": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendBucketOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendBucketsPatch"] = compute.get(
        "projects/{project}/global/backendBuckets/{backendBucket}",
        t.struct(
            {
                "project": t.string().optional(),
                "backendBucket": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendBucketOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendBucketsSetEdgeSecurityPolicy"] = compute.get(
        "projects/{project}/global/backendBuckets/{backendBucket}",
        t.struct(
            {
                "project": t.string().optional(),
                "backendBucket": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendBucketOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendBucketsGet"] = compute.get(
        "projects/{project}/global/backendBuckets/{backendBucket}",
        t.struct(
            {
                "project": t.string().optional(),
                "backendBucket": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendBucketOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersCreateInstances"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersGet"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersListManagedInstances"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersRecreateInstances"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersDeleteInstances"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersUpdatePerInstanceConfigs"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersInsert"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersListErrors"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersResize"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersSetInstanceTemplate"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersDeletePerInstanceConfigs"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersPatchPerInstanceConfigs"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersListPerInstanceConfigs"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersSetTargetPools"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersDelete"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersAbandonInstances"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersPatch"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersList"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionInstanceGroupManagersApplyUpdatesToInstances"] = compute.post(
        "projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances",
        t.struct(
            {
                "region": t.string().optional(),
                "instanceGroupManager": t.string().optional(),
                "project": t.string().optional(),
                "minimalAction": t.string().optional(),
                "instances": t.array(t.string()).optional(),
                "allInstances": t.boolean().optional(),
                "mostDisruptiveAllowedAction": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionHealthChecksGet"] = compute.post(
        "projects/{project}/regions/{region}/healthChecks",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "type": t.string().optional(),
                "healthyThreshold": t.integer().optional(),
                "tcpHealthCheck": t.proxy(renames["TCPHealthCheckIn"]),
                "logConfig": t.proxy(renames["HealthCheckLogConfigIn"]).optional(),
                "sslHealthCheck": t.proxy(renames["SSLHealthCheckIn"]),
                "unhealthyThreshold": t.integer().optional(),
                "selfLink": t.string().optional(),
                "name": t.string().optional(),
                "timeoutSec": t.integer().optional(),
                "httpHealthCheck": t.proxy(renames["HTTPHealthCheckIn"]),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "checkIntervalSec": t.integer().optional(),
                "id": t.string().optional(),
                "http2HealthCheck": t.proxy(renames["HTTP2HealthCheckIn"]),
                "grpcHealthCheck": t.proxy(renames["GRPCHealthCheckIn"]),
                "httpsHealthCheck": t.proxy(renames["HTTPSHealthCheckIn"]),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionHealthChecksDelete"] = compute.post(
        "projects/{project}/regions/{region}/healthChecks",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "type": t.string().optional(),
                "healthyThreshold": t.integer().optional(),
                "tcpHealthCheck": t.proxy(renames["TCPHealthCheckIn"]),
                "logConfig": t.proxy(renames["HealthCheckLogConfigIn"]).optional(),
                "sslHealthCheck": t.proxy(renames["SSLHealthCheckIn"]),
                "unhealthyThreshold": t.integer().optional(),
                "selfLink": t.string().optional(),
                "name": t.string().optional(),
                "timeoutSec": t.integer().optional(),
                "httpHealthCheck": t.proxy(renames["HTTPHealthCheckIn"]),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "checkIntervalSec": t.integer().optional(),
                "id": t.string().optional(),
                "http2HealthCheck": t.proxy(renames["HTTP2HealthCheckIn"]),
                "grpcHealthCheck": t.proxy(renames["GRPCHealthCheckIn"]),
                "httpsHealthCheck": t.proxy(renames["HTTPSHealthCheckIn"]),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionHealthChecksUpdate"] = compute.post(
        "projects/{project}/regions/{region}/healthChecks",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "type": t.string().optional(),
                "healthyThreshold": t.integer().optional(),
                "tcpHealthCheck": t.proxy(renames["TCPHealthCheckIn"]),
                "logConfig": t.proxy(renames["HealthCheckLogConfigIn"]).optional(),
                "sslHealthCheck": t.proxy(renames["SSLHealthCheckIn"]),
                "unhealthyThreshold": t.integer().optional(),
                "selfLink": t.string().optional(),
                "name": t.string().optional(),
                "timeoutSec": t.integer().optional(),
                "httpHealthCheck": t.proxy(renames["HTTPHealthCheckIn"]),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "checkIntervalSec": t.integer().optional(),
                "id": t.string().optional(),
                "http2HealthCheck": t.proxy(renames["HTTP2HealthCheckIn"]),
                "grpcHealthCheck": t.proxy(renames["GRPCHealthCheckIn"]),
                "httpsHealthCheck": t.proxy(renames["HTTPSHealthCheckIn"]),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionHealthChecksPatch"] = compute.post(
        "projects/{project}/regions/{region}/healthChecks",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "type": t.string().optional(),
                "healthyThreshold": t.integer().optional(),
                "tcpHealthCheck": t.proxy(renames["TCPHealthCheckIn"]),
                "logConfig": t.proxy(renames["HealthCheckLogConfigIn"]).optional(),
                "sslHealthCheck": t.proxy(renames["SSLHealthCheckIn"]),
                "unhealthyThreshold": t.integer().optional(),
                "selfLink": t.string().optional(),
                "name": t.string().optional(),
                "timeoutSec": t.integer().optional(),
                "httpHealthCheck": t.proxy(renames["HTTPHealthCheckIn"]),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "checkIntervalSec": t.integer().optional(),
                "id": t.string().optional(),
                "http2HealthCheck": t.proxy(renames["HTTP2HealthCheckIn"]),
                "grpcHealthCheck": t.proxy(renames["GRPCHealthCheckIn"]),
                "httpsHealthCheck": t.proxy(renames["HTTPSHealthCheckIn"]),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionHealthChecksList"] = compute.post(
        "projects/{project}/regions/{region}/healthChecks",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "type": t.string().optional(),
                "healthyThreshold": t.integer().optional(),
                "tcpHealthCheck": t.proxy(renames["TCPHealthCheckIn"]),
                "logConfig": t.proxy(renames["HealthCheckLogConfigIn"]).optional(),
                "sslHealthCheck": t.proxy(renames["SSLHealthCheckIn"]),
                "unhealthyThreshold": t.integer().optional(),
                "selfLink": t.string().optional(),
                "name": t.string().optional(),
                "timeoutSec": t.integer().optional(),
                "httpHealthCheck": t.proxy(renames["HTTPHealthCheckIn"]),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "checkIntervalSec": t.integer().optional(),
                "id": t.string().optional(),
                "http2HealthCheck": t.proxy(renames["HTTP2HealthCheckIn"]),
                "grpcHealthCheck": t.proxy(renames["GRPCHealthCheckIn"]),
                "httpsHealthCheck": t.proxy(renames["HTTPSHealthCheckIn"]),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionHealthChecksInsert"] = compute.post(
        "projects/{project}/regions/{region}/healthChecks",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "type": t.string().optional(),
                "healthyThreshold": t.integer().optional(),
                "tcpHealthCheck": t.proxy(renames["TCPHealthCheckIn"]),
                "logConfig": t.proxy(renames["HealthCheckLogConfigIn"]).optional(),
                "sslHealthCheck": t.proxy(renames["SSLHealthCheckIn"]),
                "unhealthyThreshold": t.integer().optional(),
                "selfLink": t.string().optional(),
                "name": t.string().optional(),
                "timeoutSec": t.integer().optional(),
                "httpHealthCheck": t.proxy(renames["HTTPHealthCheckIn"]),
                "kind": t.string().optional(),
                "description": t.string().optional(),
                "checkIntervalSec": t.integer().optional(),
                "id": t.string().optional(),
                "http2HealthCheck": t.proxy(renames["HTTP2HealthCheckIn"]),
                "grpcHealthCheck": t.proxy(renames["GRPCHealthCheckIn"]),
                "httpsHealthCheck": t.proxy(renames["HTTPSHealthCheckIn"]),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesAddSignedUrlKey"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesSetIamPolicy"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesPatch"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesAggregatedList"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesGetIamPolicy"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesDeleteSignedUrlKey"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesInsert"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesGet"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesSetEdgeSecurityPolicy"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesList"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesSetSecurityPolicy"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesUpdate"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesDelete"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["backendServicesGetHealth"] = compute.post(
        "projects/{project}/global/backendServices/{backendService}/getHealth",
        t.struct(
            {
                "project": t.string(),
                "backendService": t.string().optional(),
                "group": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["BackendServiceGroupHealthOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectAttachmentsAggregatedList"] = compute.post(
        "projects/{project}/regions/{region}/interconnectAttachments/{resource}/setLabels",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resource": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectAttachmentsGet"] = compute.post(
        "projects/{project}/regions/{region}/interconnectAttachments/{resource}/setLabels",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resource": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectAttachmentsList"] = compute.post(
        "projects/{project}/regions/{region}/interconnectAttachments/{resource}/setLabels",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resource": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectAttachmentsInsert"] = compute.post(
        "projects/{project}/regions/{region}/interconnectAttachments/{resource}/setLabels",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resource": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectAttachmentsDelete"] = compute.post(
        "projects/{project}/regions/{region}/interconnectAttachments/{resource}/setLabels",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resource": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectAttachmentsPatch"] = compute.post(
        "projects/{project}/regions/{region}/interconnectAttachments/{resource}/setLabels",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resource": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["interconnectAttachmentsSetLabels"] = compute.post(
        "projects/{project}/regions/{region}/interconnectAttachments/{resource}/setLabels",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resource": t.string().optional(),
                "labelFingerprint": t.string().optional(),
                "labels": t.struct({"_": t.string().optional()}).optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["securityPoliciesListPreconfiguredExpressionSets"] = compute.post(
        "projects/{project}/global/securityPolicies/{securityPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "project": t.string().optional(),
                "validateOnly": t.boolean().optional(),
                "securityPolicy": t.string().optional(),
                "rateLimitOptions": t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsIn"]
                ).optional(),
                "preconfiguredWafConfig": t.proxy(
                    renames["SecurityPolicyRulePreconfiguredWafConfigIn"]
                ).optional(),
                "match": t.proxy(renames["SecurityPolicyRuleMatcherIn"]).optional(),
                "kind": t.string().optional(),
                "redirectOptions": t.proxy(
                    renames["SecurityPolicyRuleRedirectOptionsIn"]
                ).optional(),
                "preview": t.boolean().optional(),
                "action": t.string().optional(),
                "headerAction": t.proxy(
                    renames["SecurityPolicyRuleHttpHeaderActionIn"]
                ).optional(),
                "description": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["securityPoliciesAggregatedList"] = compute.post(
        "projects/{project}/global/securityPolicies/{securityPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "project": t.string().optional(),
                "validateOnly": t.boolean().optional(),
                "securityPolicy": t.string().optional(),
                "rateLimitOptions": t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsIn"]
                ).optional(),
                "preconfiguredWafConfig": t.proxy(
                    renames["SecurityPolicyRulePreconfiguredWafConfigIn"]
                ).optional(),
                "match": t.proxy(renames["SecurityPolicyRuleMatcherIn"]).optional(),
                "kind": t.string().optional(),
                "redirectOptions": t.proxy(
                    renames["SecurityPolicyRuleRedirectOptionsIn"]
                ).optional(),
                "preview": t.boolean().optional(),
                "action": t.string().optional(),
                "headerAction": t.proxy(
                    renames["SecurityPolicyRuleHttpHeaderActionIn"]
                ).optional(),
                "description": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["securityPoliciesInsert"] = compute.post(
        "projects/{project}/global/securityPolicies/{securityPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "project": t.string().optional(),
                "validateOnly": t.boolean().optional(),
                "securityPolicy": t.string().optional(),
                "rateLimitOptions": t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsIn"]
                ).optional(),
                "preconfiguredWafConfig": t.proxy(
                    renames["SecurityPolicyRulePreconfiguredWafConfigIn"]
                ).optional(),
                "match": t.proxy(renames["SecurityPolicyRuleMatcherIn"]).optional(),
                "kind": t.string().optional(),
                "redirectOptions": t.proxy(
                    renames["SecurityPolicyRuleRedirectOptionsIn"]
                ).optional(),
                "preview": t.boolean().optional(),
                "action": t.string().optional(),
                "headerAction": t.proxy(
                    renames["SecurityPolicyRuleHttpHeaderActionIn"]
                ).optional(),
                "description": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["securityPoliciesGetRule"] = compute.post(
        "projects/{project}/global/securityPolicies/{securityPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "project": t.string().optional(),
                "validateOnly": t.boolean().optional(),
                "securityPolicy": t.string().optional(),
                "rateLimitOptions": t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsIn"]
                ).optional(),
                "preconfiguredWafConfig": t.proxy(
                    renames["SecurityPolicyRulePreconfiguredWafConfigIn"]
                ).optional(),
                "match": t.proxy(renames["SecurityPolicyRuleMatcherIn"]).optional(),
                "kind": t.string().optional(),
                "redirectOptions": t.proxy(
                    renames["SecurityPolicyRuleRedirectOptionsIn"]
                ).optional(),
                "preview": t.boolean().optional(),
                "action": t.string().optional(),
                "headerAction": t.proxy(
                    renames["SecurityPolicyRuleHttpHeaderActionIn"]
                ).optional(),
                "description": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["securityPoliciesRemoveRule"] = compute.post(
        "projects/{project}/global/securityPolicies/{securityPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "project": t.string().optional(),
                "validateOnly": t.boolean().optional(),
                "securityPolicy": t.string().optional(),
                "rateLimitOptions": t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsIn"]
                ).optional(),
                "preconfiguredWafConfig": t.proxy(
                    renames["SecurityPolicyRulePreconfiguredWafConfigIn"]
                ).optional(),
                "match": t.proxy(renames["SecurityPolicyRuleMatcherIn"]).optional(),
                "kind": t.string().optional(),
                "redirectOptions": t.proxy(
                    renames["SecurityPolicyRuleRedirectOptionsIn"]
                ).optional(),
                "preview": t.boolean().optional(),
                "action": t.string().optional(),
                "headerAction": t.proxy(
                    renames["SecurityPolicyRuleHttpHeaderActionIn"]
                ).optional(),
                "description": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["securityPoliciesList"] = compute.post(
        "projects/{project}/global/securityPolicies/{securityPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "project": t.string().optional(),
                "validateOnly": t.boolean().optional(),
                "securityPolicy": t.string().optional(),
                "rateLimitOptions": t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsIn"]
                ).optional(),
                "preconfiguredWafConfig": t.proxy(
                    renames["SecurityPolicyRulePreconfiguredWafConfigIn"]
                ).optional(),
                "match": t.proxy(renames["SecurityPolicyRuleMatcherIn"]).optional(),
                "kind": t.string().optional(),
                "redirectOptions": t.proxy(
                    renames["SecurityPolicyRuleRedirectOptionsIn"]
                ).optional(),
                "preview": t.boolean().optional(),
                "action": t.string().optional(),
                "headerAction": t.proxy(
                    renames["SecurityPolicyRuleHttpHeaderActionIn"]
                ).optional(),
                "description": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["securityPoliciesSetLabels"] = compute.post(
        "projects/{project}/global/securityPolicies/{securityPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "project": t.string().optional(),
                "validateOnly": t.boolean().optional(),
                "securityPolicy": t.string().optional(),
                "rateLimitOptions": t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsIn"]
                ).optional(),
                "preconfiguredWafConfig": t.proxy(
                    renames["SecurityPolicyRulePreconfiguredWafConfigIn"]
                ).optional(),
                "match": t.proxy(renames["SecurityPolicyRuleMatcherIn"]).optional(),
                "kind": t.string().optional(),
                "redirectOptions": t.proxy(
                    renames["SecurityPolicyRuleRedirectOptionsIn"]
                ).optional(),
                "preview": t.boolean().optional(),
                "action": t.string().optional(),
                "headerAction": t.proxy(
                    renames["SecurityPolicyRuleHttpHeaderActionIn"]
                ).optional(),
                "description": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["securityPoliciesAddRule"] = compute.post(
        "projects/{project}/global/securityPolicies/{securityPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "project": t.string().optional(),
                "validateOnly": t.boolean().optional(),
                "securityPolicy": t.string().optional(),
                "rateLimitOptions": t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsIn"]
                ).optional(),
                "preconfiguredWafConfig": t.proxy(
                    renames["SecurityPolicyRulePreconfiguredWafConfigIn"]
                ).optional(),
                "match": t.proxy(renames["SecurityPolicyRuleMatcherIn"]).optional(),
                "kind": t.string().optional(),
                "redirectOptions": t.proxy(
                    renames["SecurityPolicyRuleRedirectOptionsIn"]
                ).optional(),
                "preview": t.boolean().optional(),
                "action": t.string().optional(),
                "headerAction": t.proxy(
                    renames["SecurityPolicyRuleHttpHeaderActionIn"]
                ).optional(),
                "description": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["securityPoliciesGet"] = compute.post(
        "projects/{project}/global/securityPolicies/{securityPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "project": t.string().optional(),
                "validateOnly": t.boolean().optional(),
                "securityPolicy": t.string().optional(),
                "rateLimitOptions": t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsIn"]
                ).optional(),
                "preconfiguredWafConfig": t.proxy(
                    renames["SecurityPolicyRulePreconfiguredWafConfigIn"]
                ).optional(),
                "match": t.proxy(renames["SecurityPolicyRuleMatcherIn"]).optional(),
                "kind": t.string().optional(),
                "redirectOptions": t.proxy(
                    renames["SecurityPolicyRuleRedirectOptionsIn"]
                ).optional(),
                "preview": t.boolean().optional(),
                "action": t.string().optional(),
                "headerAction": t.proxy(
                    renames["SecurityPolicyRuleHttpHeaderActionIn"]
                ).optional(),
                "description": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["securityPoliciesDelete"] = compute.post(
        "projects/{project}/global/securityPolicies/{securityPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "project": t.string().optional(),
                "validateOnly": t.boolean().optional(),
                "securityPolicy": t.string().optional(),
                "rateLimitOptions": t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsIn"]
                ).optional(),
                "preconfiguredWafConfig": t.proxy(
                    renames["SecurityPolicyRulePreconfiguredWafConfigIn"]
                ).optional(),
                "match": t.proxy(renames["SecurityPolicyRuleMatcherIn"]).optional(),
                "kind": t.string().optional(),
                "redirectOptions": t.proxy(
                    renames["SecurityPolicyRuleRedirectOptionsIn"]
                ).optional(),
                "preview": t.boolean().optional(),
                "action": t.string().optional(),
                "headerAction": t.proxy(
                    renames["SecurityPolicyRuleHttpHeaderActionIn"]
                ).optional(),
                "description": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["securityPoliciesPatch"] = compute.post(
        "projects/{project}/global/securityPolicies/{securityPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "project": t.string().optional(),
                "validateOnly": t.boolean().optional(),
                "securityPolicy": t.string().optional(),
                "rateLimitOptions": t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsIn"]
                ).optional(),
                "preconfiguredWafConfig": t.proxy(
                    renames["SecurityPolicyRulePreconfiguredWafConfigIn"]
                ).optional(),
                "match": t.proxy(renames["SecurityPolicyRuleMatcherIn"]).optional(),
                "kind": t.string().optional(),
                "redirectOptions": t.proxy(
                    renames["SecurityPolicyRuleRedirectOptionsIn"]
                ).optional(),
                "preview": t.boolean().optional(),
                "action": t.string().optional(),
                "headerAction": t.proxy(
                    renames["SecurityPolicyRuleHttpHeaderActionIn"]
                ).optional(),
                "description": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["securityPoliciesPatchRule"] = compute.post(
        "projects/{project}/global/securityPolicies/{securityPolicy}/patchRule",
        t.struct(
            {
                "priority": t.integer().optional(),
                "project": t.string().optional(),
                "validateOnly": t.boolean().optional(),
                "securityPolicy": t.string().optional(),
                "rateLimitOptions": t.proxy(
                    renames["SecurityPolicyRuleRateLimitOptionsIn"]
                ).optional(),
                "preconfiguredWafConfig": t.proxy(
                    renames["SecurityPolicyRulePreconfiguredWafConfigIn"]
                ).optional(),
                "match": t.proxy(renames["SecurityPolicyRuleMatcherIn"]).optional(),
                "kind": t.string().optional(),
                "redirectOptions": t.proxy(
                    renames["SecurityPolicyRuleRedirectOptionsIn"]
                ).optional(),
                "preview": t.boolean().optional(),
                "action": t.string().optional(),
                "headerAction": t.proxy(
                    renames["SecurityPolicyRuleHttpHeaderActionIn"]
                ).optional(),
                "description": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSslCertificatesGet"] = compute.get(
        "projects/{project}/regions/{region}/sslCertificates",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "region": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslCertificateListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSslCertificatesDelete"] = compute.get(
        "projects/{project}/regions/{region}/sslCertificates",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "region": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslCertificateListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSslCertificatesInsert"] = compute.get(
        "projects/{project}/regions/{region}/sslCertificates",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "region": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslCertificateListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionSslCertificatesList"] = compute.get(
        "projects/{project}/regions/{region}/sslCertificates",
        t.struct(
            {
                "returnPartialSuccess": t.boolean().optional(),
                "region": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "project": t.string().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["SslCertificateListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["externalVpnGatewaysInsert"] = compute.get(
        "projects/{project}/global/externalVpnGateways/{externalVpnGateway}",
        t.struct(
            {
                "project": t.string().optional(),
                "externalVpnGateway": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ExternalVpnGatewayOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["externalVpnGatewaysSetLabels"] = compute.get(
        "projects/{project}/global/externalVpnGateways/{externalVpnGateway}",
        t.struct(
            {
                "project": t.string().optional(),
                "externalVpnGateway": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ExternalVpnGatewayOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["externalVpnGatewaysTestIamPermissions"] = compute.get(
        "projects/{project}/global/externalVpnGateways/{externalVpnGateway}",
        t.struct(
            {
                "project": t.string().optional(),
                "externalVpnGateway": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ExternalVpnGatewayOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["externalVpnGatewaysList"] = compute.get(
        "projects/{project}/global/externalVpnGateways/{externalVpnGateway}",
        t.struct(
            {
                "project": t.string().optional(),
                "externalVpnGateway": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ExternalVpnGatewayOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["externalVpnGatewaysDelete"] = compute.get(
        "projects/{project}/global/externalVpnGateways/{externalVpnGateway}",
        t.struct(
            {
                "project": t.string().optional(),
                "externalVpnGateway": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ExternalVpnGatewayOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["externalVpnGatewaysGet"] = compute.get(
        "projects/{project}/global/externalVpnGateways/{externalVpnGateway}",
        t.struct(
            {
                "project": t.string().optional(),
                "externalVpnGateway": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["ExternalVpnGatewayOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["httpHealthChecksUpdate"] = compute.post(
        "projects/{project}/global/httpHealthChecks",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "unhealthyThreshold": t.integer().optional(),
                "name": t.string().optional(),
                "id": t.string().optional(),
                "timeoutSec": t.integer().optional(),
                "host": t.string().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "requestPath": t.string().optional(),
                "checkIntervalSec": t.integer().optional(),
                "selfLink": t.string().optional(),
                "healthyThreshold": t.integer().optional(),
                "port": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["httpHealthChecksPatch"] = compute.post(
        "projects/{project}/global/httpHealthChecks",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "unhealthyThreshold": t.integer().optional(),
                "name": t.string().optional(),
                "id": t.string().optional(),
                "timeoutSec": t.integer().optional(),
                "host": t.string().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "requestPath": t.string().optional(),
                "checkIntervalSec": t.integer().optional(),
                "selfLink": t.string().optional(),
                "healthyThreshold": t.integer().optional(),
                "port": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["httpHealthChecksDelete"] = compute.post(
        "projects/{project}/global/httpHealthChecks",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "unhealthyThreshold": t.integer().optional(),
                "name": t.string().optional(),
                "id": t.string().optional(),
                "timeoutSec": t.integer().optional(),
                "host": t.string().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "requestPath": t.string().optional(),
                "checkIntervalSec": t.integer().optional(),
                "selfLink": t.string().optional(),
                "healthyThreshold": t.integer().optional(),
                "port": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["httpHealthChecksGet"] = compute.post(
        "projects/{project}/global/httpHealthChecks",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "unhealthyThreshold": t.integer().optional(),
                "name": t.string().optional(),
                "id": t.string().optional(),
                "timeoutSec": t.integer().optional(),
                "host": t.string().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "requestPath": t.string().optional(),
                "checkIntervalSec": t.integer().optional(),
                "selfLink": t.string().optional(),
                "healthyThreshold": t.integer().optional(),
                "port": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["httpHealthChecksList"] = compute.post(
        "projects/{project}/global/httpHealthChecks",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "unhealthyThreshold": t.integer().optional(),
                "name": t.string().optional(),
                "id": t.string().optional(),
                "timeoutSec": t.integer().optional(),
                "host": t.string().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "requestPath": t.string().optional(),
                "checkIntervalSec": t.integer().optional(),
                "selfLink": t.string().optional(),
                "healthyThreshold": t.integer().optional(),
                "port": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["httpHealthChecksInsert"] = compute.post(
        "projects/{project}/global/httpHealthChecks",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "unhealthyThreshold": t.integer().optional(),
                "name": t.string().optional(),
                "id": t.string().optional(),
                "timeoutSec": t.integer().optional(),
                "host": t.string().optional(),
                "description": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "requestPath": t.string().optional(),
                "checkIntervalSec": t.integer().optional(),
                "selfLink": t.string().optional(),
                "healthyThreshold": t.integer().optional(),
                "port": t.integer().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkAttachmentsSetIamPolicy"] = compute.get(
        "projects/{project}/aggregated/networkAttachments",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkAttachmentAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkAttachmentsGet"] = compute.get(
        "projects/{project}/aggregated/networkAttachments",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkAttachmentAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkAttachmentsGetIamPolicy"] = compute.get(
        "projects/{project}/aggregated/networkAttachments",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkAttachmentAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkAttachmentsDelete"] = compute.get(
        "projects/{project}/aggregated/networkAttachments",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkAttachmentAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkAttachmentsTestIamPermissions"] = compute.get(
        "projects/{project}/aggregated/networkAttachments",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkAttachmentAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkAttachmentsInsert"] = compute.get(
        "projects/{project}/aggregated/networkAttachments",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkAttachmentAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkAttachmentsList"] = compute.get(
        "projects/{project}/aggregated/networkAttachments",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkAttachmentAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkAttachmentsAggregatedList"] = compute.get(
        "projects/{project}/aggregated/networkAttachments",
        t.struct(
            {
                "filter": t.string().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkAttachmentAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEndpointGroupsDetachNetworkEndpoints"] = compute.get(
        "projects/{project}/aggregated/networkEndpointGroups",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEndpointGroupAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEndpointGroupsList"] = compute.get(
        "projects/{project}/aggregated/networkEndpointGroups",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEndpointGroupAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEndpointGroupsInsert"] = compute.get(
        "projects/{project}/aggregated/networkEndpointGroups",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEndpointGroupAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEndpointGroupsDelete"] = compute.get(
        "projects/{project}/aggregated/networkEndpointGroups",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEndpointGroupAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEndpointGroupsAttachNetworkEndpoints"] = compute.get(
        "projects/{project}/aggregated/networkEndpointGroups",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEndpointGroupAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEndpointGroupsListNetworkEndpoints"] = compute.get(
        "projects/{project}/aggregated/networkEndpointGroups",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEndpointGroupAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEndpointGroupsGet"] = compute.get(
        "projects/{project}/aggregated/networkEndpointGroups",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEndpointGroupAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEndpointGroupsTestIamPermissions"] = compute.get(
        "projects/{project}/aggregated/networkEndpointGroups",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEndpointGroupAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["networkEndpointGroupsAggregatedList"] = compute.get(
        "projects/{project}/aggregated/networkEndpointGroups",
        t.struct(
            {
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["NetworkEndpointGroupAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routesGet"] = compute.get(
        "projects/{project}/global/routes",
        t.struct(
            {
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["RouteListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routesInsert"] = compute.get(
        "projects/{project}/global/routes",
        t.struct(
            {
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["RouteListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routesDelete"] = compute.get(
        "projects/{project}/global/routes",
        t.struct(
            {
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["RouteListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["routesList"] = compute.get(
        "projects/{project}/global/routes",
        t.struct(
            {
                "project": t.string().optional(),
                "maxResults": t.integer().optional(),
                "filter": t.string().optional(),
                "orderBy": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["RouteListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["diskTypesGet"] = compute.get(
        "projects/{project}/aggregated/diskTypes",
        t.struct(
            {
                "filter": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["DiskTypeAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["diskTypesList"] = compute.get(
        "projects/{project}/aggregated/diskTypes",
        t.struct(
            {
                "filter": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["DiskTypeAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["diskTypesAggregatedList"] = compute.get(
        "projects/{project}/aggregated/diskTypes",
        t.struct(
            {
                "filter": t.string().optional(),
                "returnPartialSuccess": t.boolean().optional(),
                "pageToken": t.string().optional(),
                "maxResults": t.integer().optional(),
                "project": t.string().optional(),
                "orderBy": t.string().optional(),
                "includeAllScopes": t.boolean().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["DiskTypeAggregatedListOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesCloneRules"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesRemoveAssociation"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesGet"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesPatchRule"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesList"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesSetIamPolicy"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesAddRule"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesGetAssociation"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesDelete"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesAddAssociation"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesGetEffectiveFirewalls"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesGetRule"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesGetIamPolicy"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesRemoveRule"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesPatch"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesTestIamPermissions"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionNetworkFirewallPoliciesInsert"] = compute.post(
        "projects/{project}/regions/{region}/firewallPolicies",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "kind": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "ruleTupleCount": t.integer().optional(),
                "associations": t.array(
                    t.proxy(renames["FirewallPolicyAssociationIn"])
                ).optional(),
                "name": t.string().optional(),
                "shortName": t.string().optional(),
                "description": t.string().optional(),
                "selfLink": t.string().optional(),
                "rules": t.array(t.proxy(renames["FirewallPolicyRuleIn"])).optional(),
                "displayName": t.string().optional(),
                "id": t.string().optional(),
                "parent": t.string().optional(),
                "fingerprint": t.string().optional(),
                "selfLinkWithId": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["publicAdvertisedPrefixesPatch"] = compute.post(
        "projects/{project}/global/publicAdvertisedPrefixes",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "ipCidrRange": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "fingerprint": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "dnsVerificationIp": t.string().optional(),
                "publicDelegatedPrefixs": t.array(
                    t.proxy(renames["PublicAdvertisedPrefixPublicDelegatedPrefixIn"])
                ).optional(),
                "sharedSecret": t.string().optional(),
                "kind": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["publicAdvertisedPrefixesDelete"] = compute.post(
        "projects/{project}/global/publicAdvertisedPrefixes",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "ipCidrRange": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "fingerprint": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "dnsVerificationIp": t.string().optional(),
                "publicDelegatedPrefixs": t.array(
                    t.proxy(renames["PublicAdvertisedPrefixPublicDelegatedPrefixIn"])
                ).optional(),
                "sharedSecret": t.string().optional(),
                "kind": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["publicAdvertisedPrefixesList"] = compute.post(
        "projects/{project}/global/publicAdvertisedPrefixes",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "ipCidrRange": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "fingerprint": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "dnsVerificationIp": t.string().optional(),
                "publicDelegatedPrefixs": t.array(
                    t.proxy(renames["PublicAdvertisedPrefixPublicDelegatedPrefixIn"])
                ).optional(),
                "sharedSecret": t.string().optional(),
                "kind": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["publicAdvertisedPrefixesGet"] = compute.post(
        "projects/{project}/global/publicAdvertisedPrefixes",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "ipCidrRange": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "fingerprint": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "dnsVerificationIp": t.string().optional(),
                "publicDelegatedPrefixs": t.array(
                    t.proxy(renames["PublicAdvertisedPrefixPublicDelegatedPrefixIn"])
                ).optional(),
                "sharedSecret": t.string().optional(),
                "kind": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["publicAdvertisedPrefixesInsert"] = compute.post(
        "projects/{project}/global/publicAdvertisedPrefixes",
        t.struct(
            {
                "project": t.string().optional(),
                "requestId": t.string().optional(),
                "ipCidrRange": t.string().optional(),
                "description": t.string().optional(),
                "status": t.string().optional(),
                "fingerprint": t.string().optional(),
                "id": t.string().optional(),
                "selfLink": t.string().optional(),
                "dnsVerificationIp": t.string().optional(),
                "publicDelegatedPrefixs": t.array(
                    t.proxy(renames["PublicAdvertisedPrefixPublicDelegatedPrefixIn"])
                ).optional(),
                "sharedSecret": t.string().optional(),
                "kind": t.string().optional(),
                "name": t.string().optional(),
                "creationTimestamp": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalAddressesSetLabels"] = compute.post(
        "projects/{project}/global/addresses/{address}/move",
        t.struct(
            {
                "requestId": t.string().optional(),
                "address": t.string().optional(),
                "project": t.string().optional(),
                "description": t.string().optional(),
                "destinationAddress": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalAddressesDelete"] = compute.post(
        "projects/{project}/global/addresses/{address}/move",
        t.struct(
            {
                "requestId": t.string().optional(),
                "address": t.string().optional(),
                "project": t.string().optional(),
                "description": t.string().optional(),
                "destinationAddress": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalAddressesGet"] = compute.post(
        "projects/{project}/global/addresses/{address}/move",
        t.struct(
            {
                "requestId": t.string().optional(),
                "address": t.string().optional(),
                "project": t.string().optional(),
                "description": t.string().optional(),
                "destinationAddress": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalAddressesList"] = compute.post(
        "projects/{project}/global/addresses/{address}/move",
        t.struct(
            {
                "requestId": t.string().optional(),
                "address": t.string().optional(),
                "project": t.string().optional(),
                "description": t.string().optional(),
                "destinationAddress": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalAddressesInsert"] = compute.post(
        "projects/{project}/global/addresses/{address}/move",
        t.struct(
            {
                "requestId": t.string().optional(),
                "address": t.string().optional(),
                "project": t.string().optional(),
                "description": t.string().optional(),
                "destinationAddress": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalAddressesMove"] = compute.post(
        "projects/{project}/global/addresses/{address}/move",
        t.struct(
            {
                "requestId": t.string().optional(),
                "address": t.string().optional(),
                "project": t.string().optional(),
                "description": t.string().optional(),
                "destinationAddress": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["resourcePoliciesGetIamPolicy"] = compute.delete(
        "projects/{project}/regions/{region}/resourcePolicies/{resourcePolicy}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resourcePolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["resourcePoliciesAggregatedList"] = compute.delete(
        "projects/{project}/regions/{region}/resourcePolicies/{resourcePolicy}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resourcePolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["resourcePoliciesList"] = compute.delete(
        "projects/{project}/regions/{region}/resourcePolicies/{resourcePolicy}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resourcePolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["resourcePoliciesInsert"] = compute.delete(
        "projects/{project}/regions/{region}/resourcePolicies/{resourcePolicy}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resourcePolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["resourcePoliciesSetIamPolicy"] = compute.delete(
        "projects/{project}/regions/{region}/resourcePolicies/{resourcePolicy}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resourcePolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["resourcePoliciesTestIamPermissions"] = compute.delete(
        "projects/{project}/regions/{region}/resourcePolicies/{resourcePolicy}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resourcePolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["resourcePoliciesGet"] = compute.delete(
        "projects/{project}/regions/{region}/resourcePolicies/{resourcePolicy}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resourcePolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["resourcePoliciesDelete"] = compute.delete(
        "projects/{project}/regions/{region}/resourcePolicies/{resourcePolicy}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "region": t.string().optional(),
                "project": t.string().optional(),
                "resourcePolicy": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalOperationsGet"] = compute.delete(
        "projects/{project}/global/operations/{operation}",
        t.struct(
            {
                "project": t.string().optional(),
                "operation": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.struct({"_": t.string().optional()}),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalOperationsAggregatedList"] = compute.delete(
        "projects/{project}/global/operations/{operation}",
        t.struct(
            {
                "project": t.string().optional(),
                "operation": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.struct({"_": t.string().optional()}),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalOperationsWait"] = compute.delete(
        "projects/{project}/global/operations/{operation}",
        t.struct(
            {
                "project": t.string().optional(),
                "operation": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.struct({"_": t.string().optional()}),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalOperationsList"] = compute.delete(
        "projects/{project}/global/operations/{operation}",
        t.struct(
            {
                "project": t.string().optional(),
                "operation": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.struct({"_": t.string().optional()}),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalOperationsDelete"] = compute.delete(
        "projects/{project}/global/operations/{operation}",
        t.struct(
            {
                "project": t.string().optional(),
                "operation": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.struct({"_": t.string().optional()}),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalOrganizationOperationsDelete"] = compute.get(
        "locations/global/operations/{operation}",
        t.struct(
            {
                "parentId": t.string().optional(),
                "operation": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalOrganizationOperationsList"] = compute.get(
        "locations/global/operations/{operation}",
        t.struct(
            {
                "parentId": t.string().optional(),
                "operation": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["globalOrganizationOperationsGet"] = compute.get(
        "locations/global/operations/{operation}",
        t.struct(
            {
                "parentId": t.string().optional(),
                "operation": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionUrlMapsValidate"] = compute.delete(
        "projects/{project}/regions/{region}/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "urlMap": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionUrlMapsUpdate"] = compute.delete(
        "projects/{project}/regions/{region}/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "urlMap": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionUrlMapsGet"] = compute.delete(
        "projects/{project}/regions/{region}/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "urlMap": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionUrlMapsPatch"] = compute.delete(
        "projects/{project}/regions/{region}/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "urlMap": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionUrlMapsList"] = compute.delete(
        "projects/{project}/regions/{region}/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "urlMap": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionUrlMapsInsert"] = compute.delete(
        "projects/{project}/regions/{region}/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "urlMap": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )
    functions["regionUrlMapsDelete"] = compute.delete(
        "projects/{project}/regions/{region}/urlMaps/{urlMap}",
        t.struct(
            {
                "requestId": t.string().optional(),
                "project": t.string().optional(),
                "region": t.string().optional(),
                "urlMap": t.string().optional(),
                "auth": t.string().optional(),
            }
        ),
        t.proxy(renames["OperationOut"]),
        auth_token_field="auth",
        content_type="application/json",
    )

    return Import(
        importer="compute", renames=renames, types=Box(types), functions=Box(functions)
    )
